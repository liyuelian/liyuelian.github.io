<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>视图和视图解析器</title>
    <link href="/2023/02/08/23-33-40/"/>
    <url>/2023/02/08/23-33-40/</url>
    
    <content type="html"><![CDATA[<h1 id="视图和视图解析器"><a href="#视图和视图解析器" class="headerlink" title="视图和视图解析器"></a>视图和视图解析器</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h2><ol><li><p>在SpringMVC中的目标方法，最终返回的都是一个<strong>视图</strong>（有各种视图）</p><blockquote><p>注意，这里的视图是一个类对象，不是一个页面！！</p></blockquote></li><li><p>返回的视图都会由一个视图解析器来处理（视图解析器有很多种）</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902.png" style="zoom: 20%;" /></li></ol><h2 id="2-自定义视图"><a href="#2-自定义视图" class="headerlink" title="2.自定义视图"></a>2.自定义视图</h2><h3 id="2-1为什么需要自定义视图"><a href="#2-1为什么需要自定义视图" class="headerlink" title="2.1为什么需要自定义视图"></a>2.1为什么需要自定义视图</h3><ol><li><p>在默认情况下，我们都是返回默认的视图，然后返回的视图交由 SpringMVC 的 <code>InternalResourcesViewResolver</code> 默认视图解析器来处理的：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206213632558.png" alt="image-20230206213632558" style="zoom:60%;" /></li><li><p>在实际开发中，因为业务需求，我们有时候需要自定义视图解析器</p></li><li><p>视图解析器可以配置多个，按照指定的顺序来对视图进行解析。如果上一个视图解析器不匹配，下一个视图解析器就会去解析视图，以此类推。</p></li></ol><h3 id="2-2应用实例"><a href="#2-2应用实例" class="headerlink" title="2.2应用实例"></a>2.2应用实例</h3><p>执行流程：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207171939607.png" alt="image-20230207171939607" style="zoom:67%;" /><ol><li><p>view.jsp，请求到 Handler</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;自定义视图测试&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;自定义视图测试&lt;/h1&gt;<br>&lt;a href=<span class="hljs-string">&quot;goods/buy&quot;</span>&gt;点击到自定义视图&lt;/a&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></li><li><p>GoodsHandler.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.li.web.viewresolver;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 李</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/goods&quot;)</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodsHandler</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(value = &quot;/buy&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">buy</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;----------buy()---------&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;liView&quot;</span>;<span class="hljs-comment">//自定义视图名</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自定义视图 MyView.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.li.web.viewresolver;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.view.AbstractView;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 李</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * 1. MyView 继承了AbstractView，就可以作为了一个视图使用</span><br><span class="hljs-comment"> * 2. <span class="hljs-doctag">@Component</span>(value = &quot;myView&quot;) ，该视图会注入到容器中，id为 liView</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component(value = &quot;liView&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractView</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">renderMergedOutputModel</span><span class="hljs-params">(Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//1.完成视图渲染</span><br>        System.out.println(<span class="hljs-string">&quot;进入到自己的视图...&quot;</span>);<br><br>        <span class="hljs-comment">//2.并且确定我们要跳转的页面，如 /WEB-INF/pages/my_view.jsp</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 1.下面就是请求转发到 /WEB-INF/pages/my_view.jsp</span><br><span class="hljs-comment">         * 2.该路径会被springmvc解析成 /web工程路径/WEB-INF/pages/my_view.jsp</span><br><span class="hljs-comment">         */</span><br>        request.getRequestDispatcher(<span class="hljs-string">&quot;/WEB-INF/pages/my_view.jsp&quot;</span>)<br>                .forward(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>结果页面 my_view.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;my_view&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;进入到my_view页面&lt;/h1&gt;<br>&lt;p&gt;从自定义视图来的...&lt;/p&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></li><li><p>springDispatcherServlet-servlet.xml 配置自定义视图解析器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--1.指定扫描的包--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.li.web&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--2.配置视图解析器[默认的视图解析器]--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--配置属性 suffix(后缀) 和 prefix(前缀)--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/pages/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--3.</span><br><span class="hljs-comment">    3.1 配置自定义视图解析器 BeanNameViewResolver</span><br><span class="hljs-comment">    3.2 BeanNameViewResolver 可以解析我们自定义的视图</span><br><span class="hljs-comment">    3.3 属性 order 表示视图节解析器执行的顺序，值越小优先级越高</span><br><span class="hljs-comment">    3.4 order 的默认值为最低优先级-LOWEST_PRECEDENCE</span><br><span class="hljs-comment">    3.5 默认的视图解析器就是最低优先级，因此我们的自定义解析器会先执行</span><br><span class="hljs-comment"> --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;99&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--4.加入两个常规的配置--&gt;</span><br><span class="hljs-comment">&lt;!--支持SpringMVC的高级功能，比如：JSR303校验，映射动态请求--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br><span class="hljs-comment">&lt;!--将SpringMVC不能处理的请求，交给tomcat处理，比如css，js--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>测试，访问view.jsp，点击超链接</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207175529158.png" alt="image-20230207175529158" style="zoom:67%;" /></li><li><p>成功跳转到 my_view.jsp</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207175601984.png" alt="image-20230207175601984" style="zoom:67%;" /></li><li><p>后台输出如下：说明整个执行流程如图所示。</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207175629231.png" alt="image-20230207175629231" style="zoom:67%;" /></li></ol><h3 id="2-3创建自定义视图的步骤"><a href="#2-3创建自定义视图的步骤" class="headerlink" title="2.3创建自定义视图的步骤"></a>2.3创建自定义视图的步骤</h3><ol><li>自定义一个视图：创建一个 View 的 bean，该 bean 需要继承自 AbstractView，并实现renderMergedOutputModel方法</li><li>并把自定义 View 加入到 IOC 容器中</li><li>自定义视图的视图解析器，使用 BeanNameViewResolver，这个视图解析器也需要配置到 ioc 容器文件中</li><li>BeanNameViewResolver 的调用优先级需要设置一下，设置 order 比 Integer.MAX_VALUE 小的值，以确保其在默认的视图解析器之前被调用</li></ol><h3 id="2-4Debug源码-自定义视图解析器执行流程"><a href="#2-4Debug源码-自定义视图解析器执行流程" class="headerlink" title="2.4Debug源码-自定义视图解析器执行流程"></a>2.4Debug源码-自定义视图解析器执行流程</h3><p>自定义视图-工作流程：</p><ol><li>SpringMVC 调用目标方法，返回自定义 View 在 IOC 容器中的 id</li><li>SpringMVC 调用 BeanNameViewResolver 视图解析器：从 IOC 容器中获取返回 id 值对应的 bean，即自定义的 View 的对象</li><li>SpringMVC 调用自定义视图的 renderMergedOutputModel 方法，渲染视图</li><li>说明：如果 SpringMVC 调用 Handler 的目标方法时，返回的自定义 View ，在 IOC 容器中的 id 不存在，则仍然按照默认的视图解析器机制处理。</li></ol><blockquote><p>Debug-01</p></blockquote><p>（1）在GoodsHandler的目标方法中打上断点：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207181443199.png" alt="image-20230207181443199" style="zoom:67%;" /><p>（2）点击debug，访问view.jsp，点击超链接，可以看到后台光标跳转到断点处：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207182111043.png" alt="image-20230207182111043" style="zoom:67%;" /><p>（3）在源码 BeanNameViewResolver 的 resolveViewName 方法处打上断点：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207181949587.png" alt="image-20230207181949587" style="zoom:67%;" /><p>（4）点击Resume，光标跳转到了这个断点处，viewName 的值就是自定义视图对象的 id：这里完成视图解析</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207182357898.png" alt="image-20230207182357898" style="zoom:60%;" /><p>resolveViewName 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> View <span class="hljs-title function_">resolveViewName</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>   <span class="hljs-comment">//获取ioc容器对象</span><br>   <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> obtainApplicationContext();<br>   <span class="hljs-comment">//如果容器对象中不存在 目标方法返回的自定义视图对象id</span><br>   <span class="hljs-keyword">if</span> (!context.containsBean(viewName)) &#123;<br>      <span class="hljs-comment">// Allow for ViewResolver chaining...</span><br>      <span class="hljs-comment">//就返回null，让默认的视图解析器处理该视图</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>   &#125;<br>   <span class="hljs-comment">//判断自定义的视图是不是 org.springframework.web.servlet.View 类型</span><br>   <span class="hljs-keyword">if</span> (!context.isTypeMatch(viewName, View.class)) &#123;<br>      <span class="hljs-comment">//如果不是</span><br>      <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>         logger.debug(<span class="hljs-string">&quot;Found bean named &#x27;&quot;</span> + viewName + <span class="hljs-string">&quot;&#x27; but it does not implement View&quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// Since we&#x27;re looking into the general ApplicationContext here,</span><br>      <span class="hljs-comment">// let&#x27;s accept this as a non-match and allow for chaining as well...</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>   &#125;<br>   <span class="hljs-comment">//如果是，就返回这个自定义视图对象</span><br>   <span class="hljs-keyword">return</span> context.getBean(viewName, View.class);<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207183628224.png" alt="image-20230207183628224" style="zoom:67%;" /><p>（5）在自定义视图对象里打上断点：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207183815264.png" alt="image-20230207183815264" style="zoom:67%;" /><p>（6）点击 resume，光标跳转到该断点：在这里完成视图渲染，并转发到结果页面</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207183923620.png" alt="image-20230207183923620" style="zoom:67%;" /><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207184246555.png" alt="image-20230207184246555" style="zoom:67%;" /><p>（7）最后由 tomcat 将数据返回给客户端：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207184459844.png" alt="image-20230207184459844" style="zoom:67%;" /><h3 id="2-5Debug源码-默认视图解析器执行流程"><a href="#2-5Debug源码-默认视图解析器执行流程" class="headerlink" title="2.5Debug源码-默认视图解析器执行流程"></a>2.5Debug源码-默认视图解析器执行流程</h3><p>将默认视图解析器的优先级调高：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207184950399.png" alt="image-20230207184950399" style="zoom:60%;" /><blockquote><p>debug-02</p></blockquote><p>（1）仍然在GoodsHandler中添加断点：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207192822730.png" alt="image-20230207192822730" style="zoom:67%;" /><p>（2）浏览器访问 view.jsp，可以看到后台光标跳转到了断点处：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207193027494.png" alt="image-20230207193027494" style="zoom:67%;" /><p>（3）分别在默认视图解析器(InternalResourceViewResolver)和自定义视图解析器(BeanNameViewResolver) 中的方法中打上断点：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207193313100.png" alt="image-20230207193313100" style="zoom:67%;" /><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207193321152.png" alt="image-20230207193321152" style="zoom:67%;" /><p>（4）点击resume，可以看到光标先跳到了默认视图解析器的 buildView 方法中：因为默认解析器的优先级在之前设置为最高。</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207193631707.png" alt="image-20230207193631707" style="zoom:67%;" /><p>buildView 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> AbstractUrlBasedView <span class="hljs-title function_">buildView</span><span class="hljs-params">(String viewName)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>   <span class="hljs-comment">//根据目标方法返回的viewName创建一个View对象</span><br>   <span class="hljs-type">InternalResourceView</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> (InternalResourceView) <span class="hljs-built_in">super</span>.buildView(viewName);<br>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.alwaysInclude != <span class="hljs-literal">null</span>) &#123;<br>      view.setAlwaysInclude(<span class="hljs-built_in">this</span>.alwaysInclude);<br>   &#125;<br>   view.setPreventDispatchLoop(<span class="hljs-literal">true</span>);<br>   <span class="hljs-keyword">return</span> view;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 View 对象的 url 是按照你配置的前缀和后缀，拼接完成的 url</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207194350281.png" alt="image-20230207194350281" style="zoom: 58%;" /><p>（5）之后就会到该View对象进行视图渲染，然后由Tomcat将数据返回给客户端。</p><p>但是如果该url下没有&#x2F;WEB-INF&#x2F;pages&#x2F;liView.jsp文件，就会报错：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207195118671.png" alt="image-20230207195118671" style="zoom:50%;" /><h3 id="2-6Debug源码-自定义View不存在，会走默认视图解析机制"><a href="#2-6Debug源码-自定义View不存在，会走默认视图解析机制" class="headerlink" title="2.6Debug源码-自定义View不存在，会走默认视图解析机制"></a>2.6Debug源码-自定义View不存在，会走默认视图解析机制</h3><p>视图解析器可以配置多个，按照指定的顺序来对视图进行解析。如果上一个视图解析器不匹配，下一个视图解析器就会去解析视图，以此类推：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207195521100.png" alt="image-20230207195521100" style="zoom:60%;" /><ol><li><p>在容器文件中，将默认的视图解析器调用优先级降低，提高自定义视图解析器的调用优先级。见2.2的容器文件配置</p></li><li><p>删除2.2中的自定义视图MyView.java。也就是说，自定义视图解析器解析目标方法返回的视图对象时，将会无法解析该视图，因为它不存在。</p></li><li><p>这时就会去调用下一个优先级的视图解析器，即默认视图解析器。</p></li></ol><blockquote><p>debug-03</p></blockquote><p>（1）仍然在GoodsHandler中添加断点：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207192822730.png" alt="image-20230207192822730" style="zoom:67%;" /><p>（2）浏览器访问 view.jsp，可以看到后台光标跳转到了断点处：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207193027494.png" alt="image-20230207193027494" style="zoom:67%;" /><p>（3）在自定义的视图解析器 BeanNameViewResolver 中打上断点：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207200552990.png" alt="image-20230207200552990" style="zoom:60%;" /><p>（4）点击resume，可以看到光标跳转到该断点处：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207200655556.png" alt="image-20230207200655556" style="zoom:60%;" /><p>（5）因为在容器文件中找不到该视图对象的id了，因此会进入第一个分支，方法直接返回 null</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207200857797.png" alt="image-20230207200857797" style="zoom:60%;" /><p>（6）点击step over，光标跳转到中央控制器的 resolveViewName 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> View <span class="hljs-title function_">resolveViewName</span><span class="hljs-params">(String viewName, <span class="hljs-meta">@Nullable</span> Map&lt;String, Object&gt; model,</span><br><span class="hljs-params">      Locale locale, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.viewResolvers != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">//循环调用视图解析器，直到某个视图解析器返回的view不为null</span><br>      <span class="hljs-keyword">for</span> (ViewResolver viewResolver : <span class="hljs-built_in">this</span>.viewResolvers) &#123;<br>         <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> viewResolver.resolveViewName(viewName, locale);<br>         <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> view;<br>         &#125;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207201505383.png" alt="image-20230207201505383" style="zoom:60%;" /><p>因为自定义视图解析器会返回 null，因此这里进入第二次循环，由默认的视图解析器去进行解析，然后返回对应的视图：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207202159365.png" alt="image-20230207202159365" style="zoom:60%;" /><p>（7）在该方法中打上断点，点击 resume，可以看到此时 view 是由默认的视图解析器返回的视图对象，走的是默认机制。 </p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207203001876.png" alt="image-20230207203001876" style="zoom:60%;" /><p>（8）下一个就按照默认机制拼接的 url 去访问该页面，并进行渲染。然后由Tomcat返回给客户端。如果根据 url 找不到该页面，就报404错误。</p><hr><p><strong>补充：如果默认视图解析器优先级高，自定义的视图解析器优先级低，但是默认视图解析器返回的的View为null，这时候会继续调用自定义的视图解析器吗？</strong></p><p>答：事实上，默认视图解析器返回的 View 不会为 null。</p><p>因为它是根据目标方法返回的字符串+你配置的前后缀进行 url 的拼接。只要目标方法返回了一个字符串，默认视图处理器就不会返回 null。</p><blockquote><p>如果目标方法返回的是 null 呢？将会以目标方法的路径名称+配置的前后缀作为寻找页面的 url</p></blockquote><p><strong>因此在循环调用视图处理器的时候，一旦循环到默认视图处理器，就不会调用后面的自定义视图解析器。</strong></p><h2 id="3-目标方法直接指定转发或重定向"><a href="#3-目标方法直接指定转发或重定向" class="headerlink" title="3.目标方法直接指定转发或重定向"></a>3.目标方法直接指定转发或重定向</h2><h3 id="3-1使用实例"><a href="#3-1使用实例" class="headerlink" title="3.1使用实例"></a>3.1使用实例</h3><p>目标方法中指定转发或者重定向：</p><ol><li>默认返回的方式是请求转发，然后用视图处理器进行处理。</li><li>但是也可以在目标方法中直接指定重定向或者转发的 url 的地址。</li><li>注意：如果指定重定向，则不能定向到 &#x2F;WEB-INF 目录中。因为该目录为 Tomcat 的内部目录。</li></ol><blockquote><p>例子</p></blockquote><ol><li><p>view.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;请求转发或重定向&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;请求转发或重定向&lt;/h1&gt;<br>&lt;a href=<span class="hljs-string">&quot;goods/order&quot;</span>&gt;测试在目标方法找中指定请求转发或重定向&lt;/a&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></li><li><p>GoodsHandler.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.li.web.viewresolver;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 李</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/goods&quot;)</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodsHandler</span> &#123;<br>    <span class="hljs-comment">//演示直接指定请求转发或者重定向</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/order&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">order</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;=========order()=========&quot;</span>);<br>        <span class="hljs-comment">//请求转发到 /WEB-INF/pages/my_view.jsp</span><br>        <span class="hljs-comment">//下面的路径会被解析/web工程路径/WEB-INF/pages/my_view.jsp</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/WEB-INF/pages/my_view.jsp&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>访问 view.jsp，点击超链接：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207210928762.png" alt="image-20230207210928762" style="zoom:67%;" /></li><li><p>成功进入到请求转发的页面：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207210953307.png" alt="image-20230207210953307" style="zoom:67%;" /><blockquote><p>请求转发也可以转发到WEB-INF目录之外的页面。</p></blockquote></li><li><p>修改 GoodsHandler.java 的 order 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//演示直接指定请求转发或者重定向</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/order&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">order</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;=========order()=========&quot;</span>);<br>    <span class="hljs-comment">//重定向</span><br>    <span class="hljs-comment">//1.对于重定向来说，不能重定向到/WEB-INF/目录下</span><br>    <span class="hljs-comment">//2.redirect 为重定向的关键字</span><br>    <span class="hljs-comment">//3./login.jsp 是在服务器解析的，解析为 /web工程路径/login.jsp</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/login.jsp&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>redeployTomcat，访问 view.jsp，点击超链接，可以看到成功重定向到 login.jsp页面</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207212618227.png" alt="image-20230207212618227" style="zoom:55%;" /><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230207212638759.png" alt="image-20230207212638759" style="zoom:60%;" /></li></ol><h3 id="3-2Debug-指定请求转发流程分析"><a href="#3-2Debug-指定请求转发流程分析" class="headerlink" title="3.2Debug-指定请求转发流程分析"></a>3.2Debug-指定请求转发流程分析</h3><p>通过debug查看SpringMVC指定的请求转发的方式，是如何执行到我们原生的请求转发方法的：</p><p>（1）在GoodsHandler.java的目标方法中打上断点：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230208191749490.png" alt="image-20230208191749490" style="zoom:67%;" /><p>（2）点击debug，在浏览器访问 view.jsp，点击该页面的链接，访问目标方法，后台的光标跳转到断点处：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230208192127650.png" alt="image-20230208192127650" style="zoom:67%;" /><p>（3）在源码 DispatcherServlet.java 中打上断点：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230208192401169.png" alt="image-20230208192401169" style="zoom:60%;" /><p>（4）点击 resume，光标跳转到断点处，点击step over，可以看到 传入的viewName 为 “forward:&#x2F;WEB-INF&#x2F;pages&#x2F;my_view.jsp”</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230208192819535.png" alt="image-20230208192819535" style="zoom:60%;" /><p>（5）返回的 View 视图对象如下：view中了一个名为 “forward:” 的 bean 对象</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230208193409132.png" alt="image-20230208193409132" style="zoom:60%;" /><p>（6）点击 step over，光标跳转到 DispatcherServlet.java 的 render() 方法，即视图的渲染方法：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230208193751059.png" alt="image-20230208193751059" style="zoom:67%;" /><p>（7）点击step into，光标跳转到 AbstractView 的 render() 方法中：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230208194023198.png" alt="image-20230208194023198" style="zoom:67%;" /><p>（8）该方法有一个 renderMergedOutputModel() 方法：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230208194112837.png" alt="image-20230208194112837" style="zoom:67%;" /><p>（9）step into 该方法，光标跳转到 InternalResourceView(默认视图解析器)的 renderMergedOutputModel() 方法中，该方法<strong>最终调用了 Servlet 原生的请求转发方法</strong>：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230208194634474.png" alt="image-20230208194634474" style="zoom:67%;" /><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230208194640512.png" alt="image-20230208194640512" style="zoom:67%;" /><p>然后将结果返回给 tomcat，tomcat 再把结果响应给浏览器。</p><h3 id="3-3Debug-指定重定向流程分析"><a href="#3-3Debug-指定重定向流程分析" class="headerlink" title="3.3Debug-指定重定向流程分析"></a>3.3Debug-指定重定向流程分析</h3><p>（1）还是在 GoodsHandler.java 的目标方法中打上断点：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230208195457552.png" alt="image-20230208195457552" style="zoom:67%;" /><p>（2）点击debug，访问 view.jsp，点击给页面的超链接以访问目标方法，可以看到光标跳转到断点处：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230208195733483.png" alt="image-20230208195733483" style="zoom:67%;" /><p>（3）仍然在 DispatcherServlet.java 的 resolveViewName() 方法中打上断点：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230208195931898.png" alt="image-20230208195931898" style="zoom:67%;" /><p>（4）点击resume，点击 step over，当前的 viewName 如下：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230208200131037.png" alt="image-20230208200131037" style="zoom:65%;" /><p>（5）生成的视图对象 view：view对象中包含了一个名为 “redirect:” 的 bean 对象</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230208200320856.png" alt="image-20230208200320856" style="zoom:60%;" /><p>（6）点击 step over，光标跳转到 DispatcherServlet.java 的 render() 方法，即视图的渲染方法：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230208193751059.png" alt="image-20230208193751059" style="zoom:67%;" /><p>（7）点击step into，光标跳转到 AbstractView 的 render() 方法中：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230208194023198.png" alt="image-20230208194023198" style="zoom:67%;" /><p>（8）该方法有一个 renderMergedOutputModel() 方法：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230208194112837.png" alt="image-20230208194112837" style="zoom:67%;" /><p>（9）step into 该方法，这次光标跳转到 RedirectView 的 renderMergedOutputModel() 方法中，然后调用 Servlet 原生的 sendRedirect() 方法。</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230208201207354.png" alt="image-20230208201207354" style="zoom:63%;" /><h2 id="4-练习"><a href="#4-练习" class="headerlink" title="4.练习"></a>4.练习</h2><ol><li>将之前的 SpringMVC映射数据请求，数据模型，视图和视图解析 的案例再写一遍。</li><li>Debug过的源码再走一遍</li><li>完成一个简单的用户登录案例：<ul><li>(1)编写登录页面 login.jsp</li><li>(2)LoginHandler 的 doLogin() 方法，如果用户输入用户名为 olien，密码为 123 就可以登录</li><li>(3)创建 Javabean：User.java</li><li>(4)表单提交数据到 doLogin 方法，以 User 对象接收</li><li>(5)登录成功，到页面 login_ok.jsp，并显示登录欢迎信息</li><li>(6)登录失败，到页面 login_error.jsp，并给出重新登录的超链接</li></ul></li></ol><p>login.jsp：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;登录&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h3&gt;登录页面&lt;/h3&gt;<br>&lt;form action=<span class="hljs-string">&quot;user/login&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>    u:&lt;input name=<span class="hljs-string">&quot;username&quot;</span> type=<span class="hljs-string">&quot;text&quot;</span>/&gt; &lt;br/&gt;<br>    p:&lt;input name=<span class="hljs-string">&quot;pwd&quot;</span> type=<span class="hljs-string">&quot;password&quot;</span>/&gt; &lt;br/&gt;<br>    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;登录&quot;</span>/&gt;<br>&lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>LoginHandler.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.li.web.hw;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 李</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginHandler</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(value = &quot;/login&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doLogin</span><span class="hljs-params">(User user)</span> &#123;<span class="hljs-comment">//自动匹配到形参</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;olien&quot;</span>.equals(user.getUsername()) &amp;&amp; <span class="hljs-string">&quot;123&quot;</span>.equals(user.getPwd())) &#123;<br>            <span class="hljs-comment">//默认将数据放入request域</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/WEB-INF/pages/login_ok.jsp&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/WEB-INF/pages/login_error.jsp&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>User.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.li.web.hw;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 李</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String pwd;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> username;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUsername</span><span class="hljs-params">(String username)</span> &#123;<br>        <span class="hljs-built_in">this</span>.username = username;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPwd</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> pwd;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPwd</span><span class="hljs-params">(String pwd)</span> &#123;<br>        <span class="hljs-built_in">this</span>.pwd = pwd;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>login_ok.jsp：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;登录成功&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h2&gt;欢迎 $&#123;requestScope.user.username&#125;登录成功！&lt;/h2&gt;<br>&lt;h2&gt;您的密码为 $&#123;requestScope.user.pwd&#125;&lt;/h2&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>login_error.jsp：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;登录失败&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;登录失败&lt;/h1&gt;<br>&lt;%--浏览器会解析为 http:<span class="hljs-comment">//localhost:8080/springmvc/login.jsp--%&gt;</span><br>&lt;a href=<span class="hljs-string">&quot;&lt;%=request.getContextPath()%&gt;/login.jsp&quot;</span>&gt;登录失败，点击返回重新登录&lt;/a&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>测试：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/%E8%A7%86%E5%9B%BE%E5%92%8C%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8%E7%BB%83%E4%B9%A0.gif" style="zoom:67%;" />]]></content>
    
    
    <categories>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模型数据</title>
    <link href="/2023/02/08/23-31-39/"/>
    <url>/2023/02/08/23-31-39/</url>
    
    <content type="html"><![CDATA[<h1 id="模型数据"><a href="#模型数据" class="headerlink" title="模型数据"></a>模型数据</h1><h2 id="1-数据放入request"><a href="#1-数据放入request" class="headerlink" title="1.数据放入request"></a>1.数据放入request</h2><ul><li>说明：开发中，控制器&#x2F;处理器中获取的数据如何放入request域，然后在前端（vue&#x2F;jsp&#x2F;…）取出显示？</li></ul><blockquote><p>先来看一个例子</p></blockquote><p>应用实例需求：表单提交信息，后端获取信息，并通过request转发到另一个页面，显示信息。</p><p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206181733509.png" alt="image-20230206181733509" style="zoom:70%;" /> <img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206181746223.png" alt="image-20230206181746223" style="zoom:67%;" /></p><p><strong>需要知道的是：前端提交的数据，springmvc会自动地封装到java对象中，同时 springmvc 会自动地将其放入request 域中，这样我们就可以在跳转的下一个页面取出数据。</strong></p><hr><ol><li><p>mode_date.jsp提交数据：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;model_data&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;form action=<span class="hljs-string">&quot;vote/vote05&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>  主人id：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;id&quot;</span>/&gt;&lt;br/&gt;<br>  主人名：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;name&quot;</span>/&gt;&lt;br/&gt;<br>  宠物id：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;pet.id&quot;</span>/&gt;&lt;br/&gt;<br>  宠物名：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;pet.name&quot;</span>/&gt;&lt;br/&gt;<br>  &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;添加主人和宠物&quot;</span>/&gt;&lt;br/&gt;<br>&lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></li><li><p>VoteHandler.java：</p><p>springmvc会自动将数据封装到Javabean中，并将获取的model模型放入到request域中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.li.web.requestparam;<br><br><span class="hljs-keyword">import</span> com.li.entity.Master;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 李</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/vote&quot;)</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoteHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1.提交的数据-&gt;springmvc会自动地封装到 java对象</span><br><span class="hljs-comment">     * -&gt;同时 springmvc 会自动地将其放入request域中</span><br><span class="hljs-comment">     * 2.这样就可以在跳转的下一个页面取出数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/vote05&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test05</span><span class="hljs-params">(Master master)</span> &#123;<br>        <span class="hljs-comment">//springmvc会自动的把获取的model模型放入request域中，名字就是 master</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;vote_ok&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>转发的页面 vote_ok.jsp：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;vote_ok&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;取出request域中的信息&lt;/h1&gt;<br>主人的id=$&#123;requestScope.master.id&#125;<br>主人的名字=$&#123;requestScope.master.name&#125;<br>宠物的id=$&#123;requestScope.master.pet.id&#125;<br>宠物的名字=$&#123;requestScope.master.pet.name&#125;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></li></ol><p>访问mode_date.jsp，提交数据：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206184133385.png" alt="image-20230206184133385" style="zoom:50%;" /><p>转发页面vote_ok.jsp成功地拿到了request域中的信息：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206184201411.png" alt="image-20230206184201411" style="zoom: 60%;" /><hr><p><strong>从上述代码中可以看出springmvc会自动将获取的model数据添加到request域中。同时我们也可以手动添加修改数据，并放入到request域中，有如下三种方式：</strong></p><h3 id="1-1方式1-通过HttpServletRequest放入request域"><a href="#1-1方式1-通过HttpServletRequest放入request域" class="headerlink" title="1.1方式1-通过HttpServletRequest放入request域"></a>1.1方式1-通过HttpServletRequest放入request域</h3><ol><li><p>这种方式就是原生的javaweb方式，可以在request域中以k-v形式，直接放入普通字符串，也可以放入对象</p></li><li><p>同时springmvc 自动放入request域的model也可以被修改</p></li><li><p>注意：springmvc放入request域中的对象的key值，是按照对象的类型（首字母小写）存放的，和方法的形参名无关</p></li></ol><p>修改VoteHandler.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/vote05&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test05</span><span class="hljs-params">(Master master100, HttpServletRequest request)</span> &#123;<br>    <span class="hljs-comment">//1.springmvc会自动的把获取的model模型放入request域中，名字就是 master</span><br>    <span class="hljs-comment">//2.也可以手动添加数据到request域中</span><br>    request.setAttribute(<span class="hljs-string">&quot;address&quot;</span>, <span class="hljs-string">&quot;beijing&quot;</span>);<br>    <span class="hljs-comment">//3.同时可以修改 master的属性值</span><br>    master100.setName(<span class="hljs-string">&quot;hahahah&quot;</span>);<br>    <span class="hljs-comment">//4.分析一下springmvc默认存放对象到request域中，属性名是如何确定的？</span><br>    <span class="hljs-comment">//  是按对象的类型（首字母小写）放入的，和方法的形参名无关</span><br>    <span class="hljs-comment">//  因此我们在转发的页面按照该名称是可以拿出来的</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;vote_ok&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>mode_date.jsp不变，vote_ok.jsp添加address获取。</p><p>提交数据：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206190545490.png" alt="image-20230206190545490" style="zoom:67%;" /><p>转发页面获取的数据：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206190608418.png" alt="image-20230206190608418" style="zoom: 50%;" /><h3 id="1-2方式2-通过请求的方法参数Map-lt-String-Object-gt-放入request域"><a href="#1-2方式2-通过请求的方法参数Map-lt-String-Object-gt-放入request域" class="headerlink" title="1.2方式2-通过请求的方法参数Map&lt;String,Object&gt;放入request域"></a>1.2方式2-通过请求的方法参数Map&lt;String,Object&gt;放入request域</h3><p><strong>springmvc会遍历map，将map中的k-v存放到request域中。因此你会发现在转发页面中，直接通过${requestScope.key}也可以获取属性的数据。</strong></p><p>修改VoteHandler.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 演示通过Map&lt;String,Object&gt;设置数据到request域</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/vote06&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test06</span><span class="hljs-params">(Master master, Map&lt;String, Object&gt; map)</span> &#123;<br>    <span class="hljs-comment">//需求是通过map对象，添加属性到request域中</span><br>    map.put(<span class="hljs-string">&quot;address&quot;</span>, <span class="hljs-string">&quot;tianjin&quot;</span>);<br>    <span class="hljs-comment">//原理分析：springmvc会遍历map，将map中的k-v存放到request域中</span><br>    <span class="hljs-comment">//因此你会发现在转发页面中，直接通过$&#123;requestScope.address&#125;也可以获取address的数据</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;vote_ok&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>model_data.jsp不变</p><p>vote_ok.jsp：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;vote_ok&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;取出request域中的信息&lt;/h1&gt;<br>主人的address=$&#123;requestScope.address&#125;<br>主人的id=$&#123;requestScope.master.id&#125;<br>主人的名字=$&#123;requestScope.master.name&#125;<br>宠物的id=$&#123;requestScope.master.pet.id&#125;<br>宠物的名字=$&#123;requestScope.master.pet.name&#125;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>model_data.jsp：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206191844823.png" alt="image-20230206191844823" style="zoom:60%;" /><p>vote_ok.jsp：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206191849974.png" alt="image-20230206191849974" style="zoom: 50%;" /><p><strong>注意事项：</strong></p><ol><li><p>我们知道，表单提交的数据会被springmvc自动封装成对象，并放入request域中。而且springmvc会扫描map，将里面的k-v也放到request域中。</p></li><li><p>这意味着，如果map的中某个key和之前自动封装的对象同名，那么在springmvc扫描map的时候，原先的request的对象的属性值会被map中同名key的value值<strong>覆盖</strong>。</p></li></ol><h3 id="1-3方式3-通过返回ModelAndView对象实现request域数据"><a href="#1-3方式3-通过返回ModelAndView对象实现request域数据" class="headerlink" title="1.3方式3-通过返回ModelAndView对象实现request域数据"></a>1.3方式3-通过返回ModelAndView对象实现request域数据</h3><ol><li>表单数据被springmvc封装到master对象</li><li>master对象被springmvc封装到request域中</li><li><strong>ModelAndView的属性也会被springmvc放入到request域中</strong></li><li>因此转发的页面中可以通过request域获取到所有数据</li></ol><p>修改 VoteHandler.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//演示通过返回ModelAndView对象，将数据放入到request域中</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/vote07&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">test07</span><span class="hljs-params">(Master master)</span> &#123;<br>    <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">modelAndView</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>();<br>    <span class="hljs-comment">//放入属性到 ModelAndView对象</span><br>    modelAndView.addObject(<span class="hljs-string">&quot;address&quot;</span>, <span class="hljs-string">&quot;shanghai~~&quot;</span>);<br>    <span class="hljs-comment">//指定要跳转的视图名称</span><br>    modelAndView.setViewName(<span class="hljs-string">&quot;vote_ok&quot;</span>);<br>    <span class="hljs-keyword">return</span> modelAndView;<br>&#125;<br></code></pre></td></tr></table></figure><p>model_data.jsp不变</p><p>vote_ok.jsp：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;vote_ok&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;取出request域中的信息&lt;/h1&gt;<br>主人的address=$&#123;requestScope.address&#125;<br>主人的id=$&#123;requestScope.master.id&#125;<br>主人的名字=$&#123;requestScope.master.name&#125;<br>宠物的id=$&#123;requestScope.master.pet.id&#125;<br>宠物的名字=$&#123;requestScope.master.pet.name&#125;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>model_data.jsp：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206200644063.png" alt="image-20230206200644063" style="zoom:60%;" /><p>vote_ok.jsp：可以看到在ModelAndView中的数据已经被放入到了request对象中，因此可以直接获取</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206200724038.png" alt="image-20230206200724038" style="zoom:60%;" /><p><strong>注意事项：</strong></p><ol><li><p>从本质上看，请求响应的方return “xxx”，只是返回了一个字符串，其实本质上底层是返回了一个ModelAndView 对象，只是默认被封装起来了。</p></li><li><p>ModelAndView 既可以包含 model 数据，也可以包含视图信息。</p></li><li><p>ModelAndView 对象的 addObject 方法可以添加key-val数据，添加的数据默认被 springmvc 扫描放在request域中。</p></li><li><p>ModelAndView 对象的 setView 方法可以指定视图名称。</p></li><li><p>这里ModelAndView 被 springmvc 扫描，将属性放入request域中的操作，和之前map被springmvc扫描非常相似。同样的，ModelAndView中的属性被放入request域中时，如果request域中已经有同名属性了，那么将会进行覆盖操作。</p></li></ol><h2 id="2-数据放入session"><a href="#2-数据放入session" class="headerlink" title="2.数据放入session"></a>2.数据放入session</h2><ul><li>说明：开发中，控制器&#x2F;处理器中获取的数据如何放入session域，然后在前端（vue&#x2F;jsp&#x2F;…）取出显示？</li></ul><blockquote><p>应用实例</p></blockquote><p>仍然以之前的例子说明：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206181733509.png" alt="image-20230206181733509" style="zoom:70%;" /><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206202910589.png" alt="image-20230206202910589" style="zoom:67%;" /><ol><li><p>model_date.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;model_data&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;添加信息[测试session]&lt;/h1&gt;<br>&lt;form action=<span class="hljs-string">&quot;vote/vote08&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>  主人id：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;id&quot;</span>/&gt;&lt;br/&gt;<br>  主人名：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;name&quot;</span>/&gt;&lt;br/&gt;<br>  宠物id：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;pet.id&quot;</span>/&gt;&lt;br/&gt;<br>  宠物名：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;pet.name&quot;</span>/&gt;&lt;br/&gt;<br>  &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;添加主人和宠物&quot;</span>/&gt;&lt;br/&gt;<br>&lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></li><li><p>修改VoteHandler.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//演示如何将数据设置到session域中</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/vote08&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test08</span><span class="hljs-params">(Master master,HttpSession session)</span> &#123;<br>    <span class="hljs-comment">//master对象默认放在request域中</span><br>    <span class="hljs-comment">//因此要手动将数据放入session中</span><br>    session.setAttribute(<span class="hljs-string">&quot;master&quot;</span>,master);<br>    session.setAttribute(<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;guangzhou&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;vote_ok&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>vote_ok.jsp：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;vote_ok&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;取出session域中的信息&lt;/h1&gt;<br>主人的address=$&#123;sessionScope.address&#125;&lt;br/&gt;<br>主人的id=$&#123;sessionScope.master.id&#125;&lt;br/&gt;<br>主人的名字=$&#123;sessionScope.master.name&#125;&lt;br/&gt;<br>宠物的id=$&#123;sessionScope.master.pet.id&#125;&lt;br/&gt;<br>宠物的名字=$&#123;sessionScope.master.pet.name&#125;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></li></ol><p>model_data.jsp：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206203843271.png" alt="image-20230206203843271" style="zoom:60%;" /><p>vote_ok.jsp：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206203849600.png" alt="image-20230206203849600" style="zoom:60%;" /><h2 id="3-ModelAttribute实现prepare方法"><a href="#3-ModelAttribute实现prepare方法" class="headerlink" title="3.@ModelAttribute实现prepare方法"></a>3.@ModelAttribute实现prepare方法</h2><h3 id="3-1基本说明"><a href="#3-1基本说明" class="headerlink" title="3.1基本说明"></a>3.1基本说明</h3><p>开发中，有时需要使用某个前置方法（如prepareXXX，名称随意）给目标方法准备一个模型对象</p><ol><li>@ModelAttribute 注解可以实现这样的需求</li><li>在某个方法上添加了@ModelAttribute注解后，这个方法就是前置方法。在调用该Handler的任何一个方法时，都会先调用这个前置方法。</li></ol><blockquote><p>应用实例</p></blockquote><ol><li><p>修改VoteHandler.java，增加方法，并测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/vote09&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test09</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;test09被调用...&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;vote_ok&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@RequestMapping(value = &quot;/vote10&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test10</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;test10被调用...&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;vote_ok&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1.当 Handler的一个方法被 <span class="hljs-doctag">@ModelAttribute</span> 修饰时，这个方法就是前置方法</span><br><span class="hljs-comment"> * 2.该 Handler中的其他方法被调用时，都会先调用这个前置方法</span><br><span class="hljs-comment"> * 3.类似spring的aop的前置通知</span><br><span class="hljs-comment"> * 4.前置方法会切入到其他方法前执行[底层还是aop机制]</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@ModelAttribute</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareModel</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;prepareModel()---完成准备工作&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分别在浏览器中方法test09，test10方法</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206205955916.png" alt="image-20230206205955916" style="zoom:67%;" /></li><li><p>后台输出：可以看到每次目标方法被访问前，都会调用前置方法prepareModel()</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206210025190.png" alt="image-20230206210025190" style="zoom:67%;" /></li></ol><h3 id="3-2-ModelAttribute的最佳实践"><a href="#3-2-ModelAttribute的最佳实践" class="headerlink" title="3.2@ModelAttribute的最佳实践"></a>3.2@ModelAttribute的最佳实践</h3><ul><li>修改用户信息（就是这种机制的经典应用），流程如下：<ol><li>在修改前，在前置方法中从数据库查出这个用户的数据</li><li>在修改方法（目标方法）中，可以使用前置方法的（从数据库查出的）用户数据</li><li>如果表单中对用户的某个属性修改了，则以新的数据为准。如果没有修改或不能修改，就以前置方法查出的用户数据为准，就保持原来的值。</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RequestMapping和Rest</title>
    <link href="/2023/02/08/23-31-38/"/>
    <url>/2023/02/08/23-31-38/</url>
    
    <content type="html"><![CDATA[<h1 id="RequestMapping和Rest"><a href="#RequestMapping和Rest" class="headerlink" title="RequestMapping和Rest"></a>RequestMapping和Rest</h1><h2 id="1-RequestMapping"><a href="#1-RequestMapping" class="headerlink" title="1.@RequestMapping"></a>1.@RequestMapping</h2><h3 id="1-1基本使用"><a href="#1-1基本使用" class="headerlink" title="1.1基本使用"></a>1.1基本使用</h3><p>@RequestMapping注解可以指定控制器（处理器） 的某个方法的请求url</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230202212828452.png" alt="image-20230202212828452" style="zoom:60%;" /><h3 id="1-2-RequestMapping其他使用方式"><a href="#1-2-RequestMapping其他使用方式" class="headerlink" title="1.2@RequestMapping其他使用方式"></a>1.2@RequestMapping其他使用方式</h3><h4 id="1-2-1修饰方法和类"><a href="#1-2-1修饰方法和类" class="headerlink" title="1.2.1修饰方法和类"></a>1.2.1修饰方法和类</h4><p>@RequestMapping注解可以修饰方法，还可以修饰类。</p><p>当同时修饰类和方法时，请求的url就是组合形式：<code>/类请求值/方法请求值</code></p><blockquote><p>例子</p></blockquote><p>（1）UserHandler.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.li.web;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 李</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;)</span><br><span class="hljs-meta">@Controller</span>  <span class="hljs-comment">//UserHandler就是一个处理器/控制器,注入到spring容器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1.method = RequestMethod.POST 表示请求buy方法必须是post请求</span><br><span class="hljs-comment">     * 2.RequestMethod 四个常用的选项 ：GET, POST, PUT, DELETE</span><br><span class="hljs-comment">     * 3.如果没有配置 RequestMethod，SpringMVC控制器默认支持 get和 post两种方式</span><br><span class="hljs-comment">     * 4.buy()方法对应的完整请求url = http://ip:port/web工程路径/user/buy</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/buy&quot;, method = RequestMethod.POST)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">buy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;购买商品&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）request.jsp：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;购买商品&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;购买商品&lt;/h1&gt;<br>&lt;%--<br>buy()方法对应的完整请求 url = http:<span class="hljs-comment">//ip:port/web工程路径/user/buy</span><br>--%&gt;<br>&lt;form action=<span class="hljs-string">&quot;user/buy&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>    购买人:&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;username&quot;</span>/&gt;&lt;br/&gt;<br>    购买量:&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;nums&quot;</span>/&gt;&lt;br/&gt;<br>    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>/&gt;<br>&lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>（3）success.jsp：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;操作成功&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;恭喜，操作成功！&lt;/h1&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>在浏览器中访问 <code>http://localhost:8080/springmvc/request.jsp</code>，点击提交按钮，结果如下：</p><p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230203191741074.png" alt="image-20230203191741074" style="zoom: 50%;" /> <img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230203191828499.png" alt="image-20230203191828499" style="zoom:50%;" /></p><h4 id="1-2-2指定请求方式"><a href="#1-2-2指定请求方式" class="headerlink" title="1.2.2指定请求方式"></a>1.2.2指定请求方式</h4><ol><li><p>@RequestMapping 可以指定请求的方式（post&#x2F;get&#x2F;put&#x2F;delete…），请求方式要和指定方式一致，否则报错：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230203192822882.png" alt="image-20230203192822882" style="zoom: 50%;" /></li><li><p>SpringMVC 控制器默认支持get 和 post两种请求方式，即如果没有指定 method，可以接收 get 和 post请求</p></li></ol><h4 id="1-2-3指定params和headers，支持简单表达式"><a href="#1-2-3指定params和headers，支持简单表达式" class="headerlink" title="1.2.3指定params和headers，支持简单表达式"></a>1.2.3指定params和headers，支持简单表达式</h4><ol><li><code>param1</code>：表示请求必须包含名为 param1 的请求参数</li><li><code>!param1</code>：表示请求不能包含名为 param1 的请求参数</li><li><code>param1 != value1</code>：表示请求包含名为 param1 的请求参数，但其值不能为 value1</li><li><code>&#123;&quot;param1 = value1&quot;, &quot;param2&quot;&#125;</code>：请求必须包含名为 param1 和 param2 的两个请求参数，且 param1的值必须为 value1</li></ol><blockquote><p>应用实例</p></blockquote><p>（1）修改UserHandler.java，增加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//...</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;)</span><br><span class="hljs-meta">@Controller</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserHandler</span> &#123;<br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1.params = &quot;bookId&quot; 表示请求该方式时，必须给一个名为 bookId的参数</span><br><span class="hljs-comment">     * 2.search(String bookId)&#123;&#125; 表示请求目标方法时，</span><br><span class="hljs-comment">     *  携带的 bookId参数的值会被填充到目标方法的同名形参中</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bookId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/find&quot;, params = &quot;bookId&quot;, method = RequestMethod.GET)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">search</span><span class="hljs-params">(String bookId)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;查询书籍 bookId=&quot;</span> + bookId);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）request.jsp </p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;购买商品&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;演示params的使用&lt;/h1&gt;<br>&lt;a href=<span class="hljs-string">&quot;user/find?bookId=100&quot;</span>&gt;查询书籍&lt;/a&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>（3） success.jsp 不变。</p><p>（4）redeployTomcat，在浏览器地址栏访问：<code>http://localhost:8080/springmvc/request.jsp</code>，点击查询书籍超链接，结果如下：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230203203244672.png" alt="image-20230203203244672" style="zoom: 50%;" /><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230203203931702.png" alt="image-20230203203931702" style="zoom:50%;" /><p>（5）修改UserHandler.java，指定参数的值&#x3D;100。</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230203204158727.png" alt="image-20230203204158727" style="zoom:67%;" /><p>（6）修改request.jsp，修改发送的值为200.</p><p>（7）redeployTomcat，重新范文request.jsp，点击超链接，这里可以看到出现异常，因为发送的值和方法指定的值不一样。</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230203204520955.png" alt="image-20230203204520955" style="zoom:67%;" /><h4 id="1-2-4支持Ant-风格资源地址"><a href="#1-2-4支持Ant-风格资源地址" class="headerlink" title="1.2.4支持Ant 风格资源地址"></a>1.2.4支持Ant 风格资源地址</h4><ol><li><code>?</code>：匹配文件名中的一个字符</li><li><code>*</code>：匹配文件名中的任意字符，长度任意</li><li><code>**</code>：匹配多层路径</li><li>Ant 风格的 url 地址举例：<ul><li><code>/user/*/createUser</code>：匹配 &#x2F;user&#x2F;aaa&#x2F;createUser、&#x2F;user&#x2F;bbb&#x2F;createUser 等 URL</li><li><code>/user/**/createUser</code>：匹配 &#x2F;user&#x2F;createUser、&#x2F;user&#x2F;aaa&#x2F;bbb&#x2F;createUser 等 URL</li><li><code>/user/createUser??</code>： 匹配 &#x2F;user&#x2F;createUserab、&#x2F;user&#x2F;createUsercd 等 URL</li></ul></li></ol><blockquote><p>应用实例</p></blockquote><p>（1）修改UserHandler.java，增加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//...</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;)</span><br><span class="hljs-meta">@Controller</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserHandler</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 要求：可以匹配 /user/message/aa, /user/message/aa/bb/cc</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@RequestMapping</span>(value = &quot;/message/**&quot;)</span><br><span class="hljs-comment">     *  表示可以匹配多层的路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/message/**&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">im</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;发送消息&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）修改request.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;购买商品&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;演示 Ant 风格的请求资源方式&lt;/h1&gt;<br>&lt;a href=<span class="hljs-string">&quot;user/message/aa&quot;</span>&gt;发送消息 <span class="hljs-number">1</span>&lt;/a&gt;&lt;br&gt;<br>&lt;a href=<span class="hljs-string">&quot;user/message/aa/bb/cc&quot;</span>&gt;发送消息 <span class="hljs-number">2</span>&lt;/a&gt;&lt;br&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>（3） success.jsp 不变。</p><p>（4）redeployTomcat，在浏览器地址栏访问：<code>http://localhost:8080/springmvc/request.jsp</code>，分别点击两个超链接，都能成功访问方法，并跳转到success.jsp</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230203211052829.png" alt="image-20230203211052829" style="zoom: 50%;" /><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230203211132423.png" alt="image-20230203211132423" style="zoom: 50%;" /><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230203211202176.png" alt="image-20230203211202176" style="zoom: 50%;" /><h4 id="1-2-5可配合-PathVariable映射URL绑定的占位符"><a href="#1-2-5可配合-PathVariable映射URL绑定的占位符" class="headerlink" title="1.2.5可配合@PathVariable映射URL绑定的占位符"></a>1.2.5可配合@PathVariable映射URL绑定的占位符</h4><ol><li>@RequestMapping 还可以配合 @PathVariable（路径变量） 映射 URL 绑定的占位符</li><li>这样就不需要在url地址栏上带参数名了，更加简洁明了</li></ol><blockquote><p>例子</p></blockquote><p>request.jsp页面如下，其中 kristina 和 300 皆为参数值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>占位符的演示<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;user/reg/kristina/300&quot;</span>&gt;</span>占位符的演示<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（1）修改UserHandler.java，增加方法，注意@PathVariable(“username”) 不能少</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//...</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;)</span><br><span class="hljs-meta">@Controller</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 我们希望目标方法获取到username和 userid</span><br><span class="hljs-comment">     * 前端页面为：&lt;a href=&quot;user/reg/kristina/300&quot;&gt;占位符的演示&lt;/a&gt;</span><br><span class="hljs-comment">     * 1. value = &quot;/reg/&#123;username&#125;/&#123;userid&#125;&quot;</span><br><span class="hljs-comment">     *    表示 kristina=&gt;&#123;username&#125; ,300=&gt;&#123;userid&#125;</span><br><span class="hljs-comment">     * 2.通过 <span class="hljs-doctag">@PathVariable</span> 将变量赋给对应的形参</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/reg/&#123;username&#125;/&#123;userid&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">register</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;username&quot;)</span> String name,</span><br><span class="hljs-params">                           <span class="hljs-meta">@PathVariable(&quot;userid&quot;)</span> <span class="hljs-type">int</span> id)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;接收到的参数--username=&quot;</span> + name + <span class="hljs-string">&quot;--userid=&quot;</span> + id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）success.jsp不变</p><p>（3）redeployTomcat，访问 <code>http://localhost:8080/springmvc/request.jsp</code>，点击超链接，成功访问到success.jsp，后台输出如下：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230203213818006.png" alt="image-20230203213818006" style="zoom:70%;" /><h4 id="1-2-6注意事项和使用细节"><a href="#1-2-6注意事项和使用细节" class="headerlink" title="1.2.6注意事项和使用细节"></a>1.2.6注意事项和使用细节</h4><ol><li><p>映射的URL不能重复，否则报错：</p><blockquote><p><a href="https://baijiahao.baidu.com/s?id=1732802142647372124&wfr=spider&for=pc">注意：Spring MVC controller路径是否能够重复？</a></p></blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">Caused by: java.lang.IllegalStateException: Ambiguous mapping. Cannot map &#x27;userHandler&#x27; method <br>com.li.web.UserHandler<span class="hljs-params">#</span>buy()<br>to &#123;POST [/user/buy]&#125;: There is already &#x27;userHandler&#x27; bean method<br></code></pre></td></tr></table></figure></li><li><p>各种请求的简写形式</p><p><code>@RequestMapping(value=&quot;/buy&quot;,method=RequestMethod.POST)</code> 等价于 <code>@PostMapping(value=&quot;buy&quot;)</code></p><p>以此类推，还有 <code>@GetMapping</code>，<code>@PostMapping</code>，<code>@PutMapping</code>，<code>@DeleteMapping</code></p></li><li><p>如果我们确定表单或者超链接会提交某个字段数据，比如email，要求提交的参数名和目标方法的参数名保持一致。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * hello3(String email)&#123;&#125; 如果请求参数有email=xx，就会将传递的参数值赋给String email</span><br><span class="hljs-comment"> * 但是要求名称保持一致！如果不一致，那么接收不到数据，而是null</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> email</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(value = &quot;/hello3&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello3</span><span class="hljs-params">(String email)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;hello3= &quot;</span> + email);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230203220142357.png" alt="image-20230203220142357" style="zoom:67%;" /></li></ol><h4 id="1-2-7练习"><a href="#1-2-7练习" class="headerlink" title="1.2.7练习"></a>1.2.7练习</h4><p>编写一个表单，以Post方式提交表单信息，后端编写ComputerHandler，可以接收到表单信息</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230203220422270.png" alt="image-20230203220422270" style="zoom: 50%;" /><p>computer.jsp：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;hw-电脑信息&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;电脑信息&lt;/h1&gt;<br>&lt;form action=<span class="hljs-string">&quot;computer/info&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>    品牌：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;brand&quot;</span>/&gt;&lt;br/&gt;<br>    价格：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;price&quot;</span>/&gt;&lt;br/&gt;<br>    数量：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;nums&quot;</span>/&gt;&lt;br/&gt;<br>    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span>&gt;<br>&lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>ComputerHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.li.web;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 李</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;/computer&quot;)</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComputerHandler</span> &#123;<br>    <span class="hljs-comment">//注意接收的参数名要和info方法的形参名一致</span><br>    <span class="hljs-meta">@PostMapping(&quot;/info&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">info</span><span class="hljs-params">(String brand, String price, String nums)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;brand=&quot;</span> + brand +<br>                <span class="hljs-string">&quot; price=&quot;</span> + price + <span class="hljs-string">&quot; nums=&quot;</span> + nums);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>redeployTomcat，访问：<code>http://localhost:8080/springmvc/computer.jsp</code>，输入信息，点击提交表单。</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230203221946716.png" alt="image-20230203221946716" style="zoom: 50%;" /><p>后台输出：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230203222022381.png" alt="image-20230203222022381" style="zoom:67%;" /><h3 id="1-3Postman接口测试工具"><a href="#1-3Postman接口测试工具" class="headerlink" title="1.3Postman接口测试工具"></a>1.3Postman接口测试工具</h3><h4 id="1-3-1Postman介绍"><a href="#1-3-1Postman介绍" class="headerlink" title="1.3.1Postman介绍"></a>1.3.1Postman介绍</h4><ul><li><p>Postman是什么？</p><ol><li>Postman是一款功能超级强大的用于发送HTTP请求的测试工具</li><li>是做WEB页面开发和测试的人员的常用工具</li><li>它可以创建和发送任何HTTP请求（Get&#x2F;Post&#x2F;Put&#x2F;Delete…）</li></ol></li><li><p>Postman相关资源</p><ol><li>官方网站：<a href="https://www.postman.com/">https://www.postman.com/</a></li><li>文档：<a href="https://learning.postman.com/docs/getting-started/introduction/">https://learning.postman.com/docs/getting-started/introduction/</a></li><li>下载地址：<a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a></li></ol></li></ul><blockquote><p>具体安装步骤</p></blockquote><p>（1）下载Postman软件</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230204183500108.png" alt="image-20230204183500108" style="zoom: 50%;" /><p>（2）安装</p><ol><li><p>右键安装包，选择用管理员身份运行。Postman不会让你选择安装路径，会直接安装，一般安装在系统盘</p></li><li><p>安装成功后，桌面上会出现快捷图标</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230204183814920.png" alt="image-20230204183814920" style="zoom:80%;" /></li></ol><h4 id="1-3-2Postman快速入门"><a href="#1-3-2Postman快速入门" class="headerlink" title="1.3.2Postman快速入门"></a>1.3.2Postman快速入门</h4><p>快速入门需求说明：使用 Postman向 <code>http://www.baidu.com</code> 发出 get请求，得到返回的 html格式数据</p><blockquote><p>快速入门-实现步骤</p></blockquote><ol><li><p>进入Postman，默认界面如下：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230204184844296.png" alt="image-20230204184844296" style="zoom:67%;" /></li><li><p>创建Http Request，如果你已经创建过，会直接进入Workspace</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230204185028684.png" alt="image-20230204185028684" style="zoom: 67%;" /><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230204185206183.png" alt="image-20230204185206183" style="zoom: 50%;" /></li><li><p>在新页面输入要测试的 url，点击save</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230204193214282.png" alt="image-20230204193214282" style="zoom: 50%;" /></li><li><p>在弹出的新窗口中点击Create a collection</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230204193350020.png" alt="image-20230204193350020" style="zoom: 50%;" /></li><li><p>在弹出的新窗口中填入collection名称，点击create，然后点击save</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230204193557974.png" alt="image-20230204193557974" style="zoom:67%;" /></li><li><p>配置完毕的界面</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230204194310950.png" alt="image-20230204194310950" style="zoom:80%;" /></li><li><p>点击Send按钮，即可向目标url发送请求，获取返回数据</p></li></ol><h4 id="1-3-3Postman完成Controller层测试"><a href="#1-3-3Postman完成Controller层测试" class="headerlink" title="1.3.3Postman完成Controller层测试"></a>1.3.3Postman完成Controller层测试</h4><p><strong>（1）测试用例1</strong></p><p>使用Postman，完成对之前编写的UserHandler方法的请求测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;)</span><br><span class="hljs-meta">@Controller</span>  <span class="hljs-comment">//UserHandler就是一个处理器/控制器,注入到spring容器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserHandler</span> &#123;<br><span class="hljs-meta">@RequestMapping(value = &quot;/find&quot;, params = &quot;bookId=100&quot;, method = RequestMethod.GET)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">search</span><span class="hljs-params">(String bookId)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;查询书籍 bookId=&quot;</span> + bookId);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>测试</p></blockquote><ol><li>确定请求地址url：<code>http://localhost:8080/springmvc/user/find</code></li><li>使用请求的方式：Get</li><li>确定请求的参数&#x2F;数据：bookId&#x3D;100</li><li>确定 Header有没有特殊的指定：无</li></ol><p>点击Send，返回数据，测试成功。</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230204200932993.png" alt="image-20230204200932993" style="zoom:67%;" /><p><strong>（2）测试用例2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;)</span><br><span class="hljs-meta">@Controller</span>  <span class="hljs-comment">//UserHandler就是一个处理器/控制器,注入到spring容器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserHandler</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(value = &quot;/message/**&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">im</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;发送消息&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>测试</p></blockquote><ol><li>确定请求地址url：<code>http://localhost:8080/springmvc/user/message/aa/bb/cc</code></li><li>使用请求的方式：Get 或者 Post</li><li>确定请求的参数&#x2F;数据：无</li><li>确定 Header有没有特殊的指定：无</li></ol><p>点击Send，返回数据，测试成功。</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230204201536846.png" alt="image-20230204201536846" style="zoom:67%;" /><p><strong>（3）测试用例3</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;)</span><br><span class="hljs-meta">@Controller</span>  <span class="hljs-comment">//UserHandler就是一个处理器/控制器,注入到spring容器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserHandler</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(value = &quot;/reg/&#123;username&#125;/&#123;userid&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">register</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;username&quot;)</span> String name,</span><br><span class="hljs-params">                           <span class="hljs-meta">@PathVariable(&quot;userid&quot;)</span> <span class="hljs-type">int</span> id)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;接收到的参数--username=&quot;</span> + name + <span class="hljs-string">&quot;--userid=&quot;</span> + id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>测试</p></blockquote><ol><li>确定请求地址url：<code>http://localhost:8080/springmvc/user/reg/jack/1000</code></li><li>使用请求的方式：Get 或者 Post</li><li>确定请求的参数&#x2F;数据：无</li><li>确定 Header有没有特殊的指定：无</li></ol><p>点击Send，返回数据，测试成功。</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230204202044934.png" alt="image-20230204202044934" style="zoom:67%;" /><blockquote><p>关于Postman的其他使用，在讲解框架和项目时，再具体演示</p></blockquote><h2 id="2-REST-优雅的url请求风格"><a href="#2-REST-优雅的url请求风格" class="headerlink" title="2.REST-优雅的url请求风格"></a>2.REST-优雅的url请求风格</h2><h3 id="2-1REST基本介绍"><a href="#2-1REST基本介绍" class="headerlink" title="2.1REST基本介绍"></a>2.1REST基本介绍</h3><blockquote><p><a href="https://blog.csdn.net/Huang405267467/article/details/124158131">REST风格详细介绍</a></p></blockquote><ol><li><p>REST：即 Representational State Transfer，表述性状态传递。它结构清晰，同时可以隐藏行为。</p></li><li><p>通过一个url来直观展示传统风格与REST风格的区别：</p><ul><li><p>传统风格：<br>当我们在浏览器上访问一些资源时，可以看到有些网页的url为</p><p><code>http://localhost/students/selectById?id=1</code> （该地址表示查找id为1的students对象）</p><p><code>http://localhost/students/saveStudent</code>（该地址表示保存students信息）</p></li><li><p>REST风格：<br><code>http://localhosts/student/1  </code></p><p><code>http://localhosts/student</code></p></li></ul><p>通过这两种风格的对比，我们可以看到REST风格的一部分优点：</p><p>（1）可以隐藏资源访问行为（如隐藏了selectById等），这样就无法通过地址得知对资源进行了哪种操作</p><p>（2）可以明显的看到其书写简化了，不仅书写简化了，在开发时代码也可以简化。</p></li><li><p>HTTP 协议里，四个表示操作方式的动词：GET，POST，PUT，DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源，PUT用来更新资源，DELETE用来删除资源。</p></li><li><p>传统的url通过参数说明 crud的类型，而rest则是通过 get&#x2F;post&#x2F;put&#x2F;delete 来说明 crud的类型</p></li></ol><ul><li><strong>REST的核心过滤器</strong><ol><li>当前的浏览器只支持 post&#x2F;get 请求，因此为了得到 put&#x2F;delete 的请求方式，需要使用 Spring 提供的<code>HiddenHttpMethodFilter</code> 过滤器进行转换。</li><li>HiddenHttpMethodFilter ：浏览器form表单只支持GET 和 POST请求，而DELETE、PUT 等method并不支持，Spring 添加了一个过滤器，可以将这些请求转换为标准的http方法，使得支持这四种请求方式。</li><li>需要特别注意：<strong>HiddenHttpMethodFilter 只能对 post请求方式进行转换</strong></li><li>这个过滤器需要在web.xml中配置</li></ol></li></ul><h3 id="2-2Rest风格的url-完成crud操作"><a href="#2-2Rest风格的url-完成crud操作" class="headerlink" title="2.2Rest风格的url-完成crud操作"></a>2.2Rest风格的url-完成crud操作</h3><h4 id="2-2-1需求说明"><a href="#2-2-1需求说明" class="headerlink" title="2.2.1需求说明"></a>2.2.1需求说明</h4><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230204205731358.png" alt="image-20230204205731358" style="zoom:77%;" /><h4 id="2-2-2代码实现"><a href="#2-2-2代码实现" class="headerlink" title="2.2.2代码实现"></a>2.2.2代码实现</h4><ol><li><p>修改web.xml添加 HiddenHttpMethodFilter过滤器，它的作用是将post请求转换为指定的delete或put请求</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置HiddenHttpMethodFilter过滤器</span><br><span class="hljs-comment">    1.它的作用是将以post方式提交的delete请求和put请求进行转换</span><br><span class="hljs-comment">    2.配置url-pattern为/*，表示所有请求都经过hiddenHttpMethodFilter过滤</span><br><span class="hljs-comment">    --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在SpringDispatcherServlet-servlet.xml添加两个常规的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--加入两个常规的配置--&gt;</span><br><span class="hljs-comment">&lt;!--支持SpringMVC的高级功能，比如：JSR303校验，映射动态请求--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br><span class="hljs-comment">&lt;!--将SpringMVC不能处理的请求，交给tomcat处理，比如css，js--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>注意：mvc:annotion添加的是后缀为mvc的命名空间：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230205162517025.png" alt="image-20230205162517025" style="zoom:67%;" /></li><li><p>创建rest.jsp</p><blockquote><p><a href="https://blog.csdn.net/JOEYYJ/article/details/121513921">Idea中导入jquery无法生效的解决方法</a></p></blockquote><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;rest&lt;/title&gt;<br>    &lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&quot;script/jquery-3.6.0.min.js&quot;</span>&gt;&lt;/script&gt;<br>    &lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>        $(function () &#123;<br>            $(<span class="hljs-string">&quot;#deleteBook&quot;</span>).click(function () &#123;<br>                <span class="hljs-comment">//将当前的超链接的href的值，赋给hiddenForm表单的action属性</span><br>                $(<span class="hljs-string">&quot;#hiddenForm&quot;</span>).attr(<span class="hljs-string">&quot;action&quot;</span>, <span class="hljs-built_in">this</span>.href);<br>                $(<span class="hljs-string">&quot;:hidden&quot;</span>).val(<span class="hljs-string">&quot;DELETE&quot;</span>);<span class="hljs-comment">//给hidden的_method参数赋值为delete</span><br>                $(<span class="hljs-string">&quot;#hiddenForm&quot;</span>).submit();<span class="hljs-comment">//提交表单</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//改变超链接行为，不再提交</span><br>            &#125;)<br><br>            <span class="hljs-comment">//与上同理，不一样的是这里原本就是表单post请求</span><br>            $(<span class="hljs-string">&quot;#updateBook&quot;</span>).click(function () &#123;<br>                <span class="hljs-comment">//带上目标请求格式,HiddenHttpMethodFilter会自动将post请求转成你指定的格式</span><br>                $(<span class="hljs-string">&quot;:hidden&quot;</span>).val(<span class="hljs-string">&quot;PUT&quot;</span>);<span class="hljs-comment">//给hidden的_method参数赋值为put</span><br>            &#125;)<br>        &#125;)<br>    &lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h2&gt;Rest风格的crud操作案例&lt;/h2&gt;<br>&lt;hr/&gt;<br><br>&lt;h3&gt;rest风格的url 查询书籍[get]&lt;/h3&gt;<br>&lt;a href=<span class="hljs-string">&quot;user/book/200&quot;</span>&gt;点击查询书籍&lt;/a&gt;<br>&lt;hr/&gt;<br><br>&lt;h3&gt;rest风格的url 添加书籍[post]&lt;/h3&gt;<br>&lt;form action=<span class="hljs-string">&quot;user/book&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>    name:&lt;input name=<span class="hljs-string">&quot;bookName&quot;</span> type=<span class="hljs-string">&quot;text&quot;</span>/&gt;&lt;br/&gt;<br>    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;添加书籍&quot;</span>/&gt;<br>&lt;/form&gt;<br>&lt;hr/&gt;<br><br>&lt;h3&gt;rest风格的url 删除书籍[delete]&lt;/h3&gt;<br>&lt;%--说明：<br><span class="hljs-number">1.</span>在默认情况下，超链接是get请求<br><span class="hljs-number">2.</span>要将get请求转成SpringMVC可以识别的delete，就要考虑HiddenHttpMethodFilter机制：<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_METHOD_PARAM</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;_method&quot;</span>;<br>   -------------------------------------<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; ALLOWED_METHODS =<br>      Collections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(),<br>          HttpMethod.DELETE.name(), HttpMethod.PATCH.name()));<br>   -------------------------------------<br>   <span class="hljs-comment">//获取请求的方式，如果是post方式，就进行处理</span><br>   <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;POST&quot;</span>.equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">paramValue</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-built_in">this</span>.methodParam);<br>         <span class="hljs-keyword">if</span> (StringUtils.hasLength(paramValue)) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> paramValue.toUpperCase(Locale.ENGLISH);<br>            <span class="hljs-keyword">if</span> (ALLOWED_METHODS.contains(method)) &#123;<span class="hljs-comment">//若指定method在ALLOWED_METHODS中存在</span><br>               <span class="hljs-comment">//进行包装，转换为springmvc可以解析的请求</span><br>                requestToUse = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpMethodRequestWrapper</span>(request, method);<br>            &#125;<br>         &#125;<br>      &#125;<br>   --------------------------------------<br><span class="hljs-number">3.</span>从上述代码可以看到，HiddenHttpMethodFilter 过滤器可以对以<br>    Post方式提交的delete，put，patch转换成springmvc识别的RequestMethod.DElETE，RequestMethod.PUT...<br><span class="hljs-number">4.</span>但是当前的超链接为 get请求，怎么将get请求转换成 post的请求方式呢？<br><span class="hljs-number">5.</span>我们可以使用jquery来进行处理，让用户点击超链接的时候，走一个表单的请求<br>--%&gt;<br>&lt;a href=<span class="hljs-string">&quot;user/book/600&quot;</span> id=<span class="hljs-string">&quot;deleteBook&quot;</span>&gt;删除指定id的书籍&lt;/a&gt;<br>&lt;form action=<span class="hljs-string">&quot;&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span> id=<span class="hljs-string">&quot;hiddenForm&quot;</span>&gt;<br>    &lt;input type=<span class="hljs-string">&quot;hidden&quot;</span> name=<span class="hljs-string">&quot;_method&quot;</span>/&gt;<br>&lt;/form&gt;<br>&lt;hr/&gt;<br><br>&lt;h3&gt;rest风格的url 修改书籍[put]&lt;/h3&gt;<br>&lt;form action=<span class="hljs-string">&quot;user/book/666&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span> id=<span class="hljs-string">&quot;updateBook&quot;</span>&gt;<br>    &lt;input type=<span class="hljs-string">&quot;hidden&quot;</span> name=<span class="hljs-string">&quot;_method&quot;</span>&gt;<br>    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;修改书籍&quot;</span>/&gt;<br>&lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></li><li><p>BookHandle.java</p><ol><li>下面的代码中可以看到，许多方法的REST风格匹配的url是一样的，但是由于它们的请求方式不同，所以匹配到的方法不同。这也是rest风格的优点：不仅简化了url，而且隐藏了行为。</li><li>所以实际上SpringMVC的Controller层的url是可以相同的，会另外根据请求方式的不同来匹配方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.li.web.rest;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 李</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * 用于处理rest风格的请求-crud</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/user&quot;)</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">bookHandler</span> &#123;<br>    <span class="hljs-comment">//查询[get]</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/book/&#123;id&#125;&quot;, method = RequestMethod.GET)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBook</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> String id)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;查询书籍 id=&quot;</span> + id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//添加[post]</span><br>    <span class="hljs-meta">@PostMapping(value = &quot;/book&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">addBook</span><span class="hljs-params">(String bookName)</span> &#123;<span class="hljs-comment">//注意参数名字要和表单提交的参数名称一致</span><br>        System.out.println(<span class="hljs-string">&quot;添加书籍 bookName=&quot;</span> + bookName);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//删除[delete]</span><br>    <span class="hljs-meta">@DeleteMapping(value = &quot;/book/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">delBook</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> String id)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;删除书籍 id=&quot;</span> + id);<br>        <span class="hljs-comment">//return &quot;success&quot;;//这样写，返回会报错：HTTP Status 405 - JSPs only permit GET POST or HEAD</span><br>        <span class="hljs-comment">//redirect:/user/success 重定向，会被解析成 /web工程路径/user/success,然后返回给浏览器解析</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/user/success&quot;</span>;<span class="hljs-comment">//重定向到一个没有指定method的 Handler方法</span><br>    &#125;<br><br>    <span class="hljs-comment">//如果请求是 /user/success,就转发到success.jsp</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/success&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">successGeneral</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<span class="hljs-comment">//该方法转发到success.jsp页面</span><br>    &#125;<br><br>    <span class="hljs-meta">@PutMapping(value = &quot;/book/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">updateBook</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> String id)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;修改书籍 id=&quot;</span> + id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/user/success&quot;</span>;<span class="hljs-comment">//同理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>success.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;操作成功&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;恭喜，操作成功！&lt;/h1&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></li><li><p>测试，redeployTomcat，访问：<code>http://localhost:8080/springmvc/rest.jsp</code>，在分别点击四种提交方式，前端页面和后台输出如下：</p><p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230205202322764.png" alt="image-20230205202322764" style="zoom:67%;" /> <img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230205203330172.png" alt="image-20230205203330172" style="zoom:67%;" /></p></li></ol><h4 id="2-2-3注意事项和使用细节"><a href="#2-2-3注意事项和使用细节" class="headerlink" title="2.2.3注意事项和使用细节"></a>2.2.3注意事项和使用细节</h4><ol><li><p>HiddenHttpMethodFilter在将 post请求转成 delete&#x2F;put请求时，是按照 <code>_method</code> 参数名来读取的</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230205203712186.png" alt="image-20230205203712186" style="zoom:60%;" /></li><li><p>如果web项目是运行在 Tomcat8及以上，会发现被过滤成 DELETE和 PUT请求后，到达控制器Controller时能顺利执行，但是返回（forward）会报HTTP 405 提示：HTTP Status 405 - JSPs only permit GET POST or HEAD。意为JSP只允许GET POST 或 HEAD</p><p>（1）解决方式1：使用Tomcat7</p><p>（2）解决方式2：将请求转发（forward）改为重定向（redirect），重定向到一个Handler，由Handler转发到页面。</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230205204252465.png" alt="image-20230205204252465" style="zoom:60%;" /></li><li><p>页面测试时，如果出现点击修改书籍，仍然走的是删除url，可能是浏览器缓存等原因，换成Chrome即可。如果再不行，使用js修改表单的hidden的_method的值</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC映射请求数据</title>
    <link href="/2023/02/08/23-31-38/"/>
    <url>/2023/02/08/23-31-38/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC映射请求数据"><a href="#SpringMVC映射请求数据" class="headerlink" title="SpringMVC映射请求数据"></a>SpringMVC映射请求数据</h1><h2 id="1-获取参数值"><a href="#1-获取参数值" class="headerlink" title="1.获取参数值"></a>1.获取参数值</h2><p>在开发中，如何获取到 <code> http://xxx/url?参数名1=参数值1&amp;参数名2=参数值2</code> 中的参数？</p><p>之前的案例中我们知道：提交的url的参数名必须和映射的方法中的形参名保持一致。否则方法获取的是null。</p><p>但是如果url的参数名和方法的形参名不一致，又要获取该参数，应该怎么解决这个问题？</p><p>答案是使用 <strong>@RequestParam</strong> 注解。</p><blockquote><p>应用实例</p></blockquote><ol><li>request_parameter.jsp：</li></ol><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;测试request_parameter&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h2&gt;获取到超链接参数值&lt;/h2&gt;<br>&lt;a href=<span class="hljs-string">&quot;vote/vote01?name=jack&quot;</span>&gt;获取超链接的参数&lt;/a&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>VoteHandler.java：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.li.web.requestparam;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 李</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/vote&quot;)</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoteHandler</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1.获取到超链接传递的数据</span><br><span class="hljs-comment">     * 请求为 http://localhost:8080/springmvc/vote/vote01?name=xxx</span><br><span class="hljs-comment">     * (即提交的参数名和方法形参名不一致)</span><br><span class="hljs-comment">     * 2.<span class="hljs-doctag">@RequestParam</span> 表示会接收提交的参数</span><br><span class="hljs-comment">     * 3.value = &quot;name&quot; 表示提交的参数名是name</span><br><span class="hljs-comment">     * 4.required = false 表示该参数可以没有（默认true，表示必须有该参数）</span><br><span class="hljs-comment">     * 5.当我们使用了 <span class="hljs-doctag">@RequestParam</span>(value = &quot;name&quot;, required = false) 后，</span><br><span class="hljs-comment">     * 请求的参数名和方法形参名可以不一致</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/vote01&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test01</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;name&quot;, required = false)</span> String username)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;获取到的username=&quot;</span> + username);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>访问<code>http://localhost:8080/springmvc/request_parameter.jsp</code>，点击超链接。</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230205200906238.png" alt="image-20230205200906238" style="zoom:67%;" /></li><li><p>后台输出如下，说明在提交参数和方法形参名不一致的情况下，通过@RequestParam 注解可以获取到参数</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230205201018260.png" alt="image-20230205201018260" style="zoom:80%;" /></li></ol><h2 id="2-获取http请求消息头"><a href="#2-获取http请求消息头" class="headerlink" title="2.获取http请求消息头"></a>2.获取http请求消息头</h2><p>开发中，如何获取到http请求的消息头信息（使用较少）</p><p>在映射的方法的形参前添加<code>@RequestHeader(value=&quot;要获取的Header参数&quot;)</code>，即可获取相关信息，然后将其值赋给方法的形参。</p><blockquote><p>应用实例</p></blockquote><ol><li>在VoteHandler.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.li.web.requestparam;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestHeader;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 李</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/vote&quot;)</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoteHandler</span> &#123;<br><br>    <span class="hljs-comment">//需求：获取请求头的Accept-Encoding和 Host</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/vote02&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test02</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String ae,</span><br><span class="hljs-params">                         <span class="hljs-meta">@RequestHeader(value = &quot;Host&quot;)</span> String host)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Accept-Encoding=&quot;</span> + ae);<br>        System.out.println(<span class="hljs-string">&quot;Host=&quot;</span> + host);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>浏览器地址栏发送请求 <code>http://localhost:8080/springmvc/vote/vote02</code>，后台输出：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230205211624109.png" alt="image-20230205211624109" style="zoom:80%;" /></li></ol><h2 id="3-获取Javabean形式的数据"><a href="#3-获取Javabean形式的数据" class="headerlink" title="3.获取Javabean形式的数据"></a>3.获取Javabean形式的数据</h2><ul><li>在开发中，如何获取到Javabean的数据？即如何按照java对象的形式来接收数据？</li></ul><p>使用场景说明：例如，在实际开发中提交一个表单。表单提交后，希望在后端handler接收到表单数据时，自动地将这些数据封装到某个Javabean中。</p><blockquote><p>应用实例</p></blockquote><ol><li>Pet.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.li.entity;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 李</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * entity</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Pet&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>Master.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.li.entity;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 李</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * entity</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Master</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Pet pet;<span class="hljs-comment">//对象的属性级联</span><br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Pet <span class="hljs-title function_">getPet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> pet;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPet</span><span class="hljs-params">(Pet pet)</span> &#123;<br>        <span class="hljs-built_in">this</span>.pet = pet;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Master&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, pet=&quot;</span> + pet +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>VoteHandler.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.li.web.requestparam;<br><br><span class="hljs-keyword">import</span> com.li.entity.Master;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 李</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/vote&quot;)</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoteHandler</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 演示如果获取到提交数据-&gt;怎么封装成java对象</span><br><span class="hljs-comment">     * 说明：</span><br><span class="hljs-comment">     * 1.方法的形参用对应的类型指定即可，SpringMVC会自动进行封装</span><br><span class="hljs-comment">     * 2.但是要求提交数据的参数名要和对象的属性名保持一致</span><br><span class="hljs-comment">     * 3.如果对象的属性又是一个对象，则通过 属性.属性的属性</span><br><span class="hljs-comment">     * 如 pet.name，pet.id（pet为master的属性），这就是级联操作</span><br><span class="hljs-comment">     * 4.如果提交的数据的参数和对象的字段不一致，则对象的属性值输出为null</span><br><span class="hljs-comment">     * 5.底层仍然是通过反射+注解这一套机制来完成的</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> master</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/vote03&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test03</span><span class="hljs-params">(Master master)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;master=&quot;</span> + master);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>request_parameter.jsp</li></ol><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;测试request_parameter&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;%--&lt;h2&gt;获取到超链接参数值&lt;/h2&gt;--%&gt;<br>&lt;%--&lt;a href=<span class="hljs-string">&quot;vote/vote01?name=jack&quot;</span>&gt;获取超链接的参数&lt;/a&gt;--%&gt;<br><br>&lt;h1&gt;添加主人信息&lt;/h1&gt;<br>&lt;%--<br>    <span class="hljs-number">1.</span>表单的数据就对应一个Master对象<br>    <span class="hljs-number">2.</span>提交的数据参数名和master对象的参数名要一致<br>--%&gt;<br>&lt;form action=<span class="hljs-string">&quot;vote/vote03&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>    主人id：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;id&quot;</span>/&gt;&lt;br/&gt;<br>    主人名：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;name&quot;</span>/&gt;&lt;br/&gt;<br>    宠物id：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;pet.id&quot;</span>/&gt;&lt;br/&gt;<br>    宠物名：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;pet.name&quot;</span>/&gt;&lt;br/&gt;<br>    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;添加主人和宠物&quot;</span>/&gt;&lt;br/&gt;<br>&lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>访问request_parameter.jsp页面，输入表单信息，点击提交：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206173054179.png" alt="image-20230206173054179" style="zoom:60%;" /><p>后台输出如下，成功获取到提交的数据，并将其封装到对象中。</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206173014789.png" alt="image-20230206173014789" style="zoom:67%;" /><p>如果某个字段没有匹配到数据，就为null：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206173926907.png" alt="image-20230206173926907" style="zoom:67%;" /><p><strong>注意事项：</strong></p><ol><li>支持级联数据获取</li><li>表单的控件名称要和Javabean对象的名称对应</li></ol><h2 id="4-获取servlet-api"><a href="#4-获取servlet-api" class="headerlink" title="4.获取servlet api"></a>4.获取servlet api</h2><p><strong>说明</strong></p><ol><li><p>SpringMVC也可以使用原生的servlet api</p></li><li><p>使用servlet api，需要引入tomcat&#x2F;lib 下的 servlet-api.jar</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206174547390.png" alt="image-20230206174547390" style="zoom:77%;" /></li></ol><blockquote><p>应用实例</p></blockquote><ol><li>VoteHandler.java</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.li.web.requestparam;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 李</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/vote&quot;)</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoteHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用servlet api来获取提交的数据</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/vote04&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test04</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                         HttpServletResponse response)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">pwd</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;pwd&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;username=&quot;</span> + username + <span class="hljs-string">&quot; pwd=&quot;</span> + pwd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>request_parameter.jsp</li></ol><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;测试request_parameter&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;演示原生servlet api使用&lt;/h1&gt;<br>&lt;form action=<span class="hljs-string">&quot;vote/vote04&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>    用户：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;username&quot;</span>/&gt;&lt;br/&gt;<br>    密码：&lt;input type=<span class="hljs-string">&quot;password&quot;</span> name=<span class="hljs-string">&quot;pwd&quot;</span>/&gt;&lt;br/&gt;<br>    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;登录&quot;</span>/&gt;&lt;br/&gt;<br>&lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>访问request_parameter.jsp，提交表单信息：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206175304157.png" alt="image-20230206175304157" style="zoom:67%;" /><p>后台输出：<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206175325669.png" alt="image-20230206175325669" style="zoom:67%;" /></p><p><strong>注意事项：</strong></p><ol><li>除了HttpServletRequest，HttpServletResponse，其他对象也可以通过这样的形式获取：HttpSession，java.security.Principal，InputStream，OutputStreamWriter，Reader，Writer</li><li>其中一些对象也可以通过 HttpServletRequest&#x2F;HttpServletResponse对象来获取，比如Session对象，既可以通过参数传入，也可以通过request.getSession()获取，效果一样。推荐通过参数形式传入，更加简单明了</li></ol><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/vote04&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test04</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                     HttpServletResponse response,</span><br><span class="hljs-params">                     HttpSession session)</span> &#123;<span class="hljs-comment">//通过参数形式传入session</span><br>    <span class="hljs-comment">//原生的servlet方式获取session</span><br>    <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session2</span> <span class="hljs-operator">=</span> request.getSession();<br>    <span class="hljs-comment">//通过参数传入的session对象和通过原生方式得到的session对象是同一个对象</span><br>    System.out.println(session);<br>    System.out.println(session2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230206180852668.png" alt="image-20230206180852668" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC介绍</title>
    <link href="/2023/02/08/23-30-36/"/>
    <url>/2023/02/08/23-30-36/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC介绍"><a href="#SpringMVC介绍" class="headerlink" title="SpringMVC介绍"></a>SpringMVC介绍</h1><h2 id="1-离线文档"><a href="#1-离线文档" class="headerlink" title="1.离线文档"></a>1.离线文档</h2><p>解压 spring-5.3.8-dist.zip文件。</p><p>位置：spring-framework-5.3.8&#x2F;docs&#x2F;reference&#x2F;html&#x2F;web.html#spring-web</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230202181914295.png" alt="image-20230202181914295" style="zoom:67%;" /><h2 id="2-SpringMVC基本介绍"><a href="#2-SpringMVC基本介绍" class="headerlink" title="2.SpringMVC基本介绍"></a>2.SpringMVC基本介绍</h2><h3 id="2-1SpringMVC特点-amp-概述"><a href="#2-1SpringMVC特点-amp-概述" class="headerlink" title="2.1SpringMVC特点&amp;概述"></a>2.1SpringMVC特点&amp;概述</h3><ol><li><p>SpringMVC 从易用性，效率上都比曾经流行的 Struts2 更好</p></li><li><p>SpringMVC 是 WEB 层框架：SpringMVC接管了 web层组件，比如控制器，视图，视图解析，返回给用户的数据格式，同时支持 MVC 的开发模式&#x2F;开发架构</p></li><li><p>SpringMVC 通过注解，让 POJO 成为控制器，不需要继承类或者实现接口</p></li><li><p>SpringMVC 采用低耦合的组件设计方式，具有更好的拓展和灵活性</p></li><li><p>支持 REST 格式的 URL 请求</p></li><li><p>SpringMVC 是基于 Spring 的，它的核心包为 spring-webmvc-xxx.jar 和 spring-web-xxx.jar</p></li></ol><h3 id="2-2Spring-SpringMVC-SpringBoot的关系"><a href="#2-2Spring-SpringMVC-SpringBoot的关系" class="headerlink" title="2.2Spring SpringMVC SpringBoot的关系"></a>2.2Spring SpringMVC SpringBoot的关系</h3><ol><li>SpringMVC 只是 Spring 处理 WEB 层的一个模块&#x2F;组件，SpringMVC 的基石是 Servlet</li><li>SpringBoot 是为了简化开发者的使用而推出的一个框架（约定优于配置，简化了Spring的配置流程），它包含很多组件&#x2F;框架，Spring 就是最核心的内容之一，也包含了 SpringMVC</li><li>三者之间的关系是：<strong>Spring Boot &gt; Spring &gt; SpringMVC</strong></li></ol><h2 id="3-SpringMVC的快速入门"><a href="#3-SpringMVC的快速入门" class="headerlink" title="3.SpringMVC的快速入门"></a>3.SpringMVC的快速入门</h2><h3 id="3-1需求说明"><a href="#3-1需求说明" class="headerlink" title="3.1需求说明"></a>3.1需求说明</h3><p>需求说明：使用SpringMVC，完成一个最基本的测试案例——登录案例</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230202185633326.png" alt="image-20230202185633326" style="zoom:67%;" /><h3 id="3-2SpringMVC登录流程分析"><a href="#3-2SpringMVC登录流程分析" class="headerlink" title="3.2SpringMVC登录流程分析"></a>3.2SpringMVC登录流程分析</h3><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/SpringMVC%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.png" style="zoom: 67%;" /><h3 id="3-3代码实现"><a href="#3-3代码实现" class="headerlink" title="3.3代码实现"></a>3.3代码实现</h3><ol><li><p>创建Java项目，添加 web支持并配置 tomcat</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230202193635101.png" alt="image-20230202193635101" style="zoom:60%;" /></li><li><p>导入SpringMVC 开发需要的jar包</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230202194018945.png" alt="image-20230202194018945" style="zoom:60%;" /></li><li><p>src目录下创建spring的容器文件applicationContext-mvc.xml（名称随意）</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230202204606328.png" alt="image-20230202204606328" style="zoom:67%;" /></li><li><p>在WEB-INF&#x2F;web.xml文件中配置前端控制器（中央控制器）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置前端控制器/中央控制器/分发控制器，负责处理所有的应用请求--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--配置属性 contextConfigLocation,指定 DispatcherServlet 去操作的 spring容器配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext-mvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--在web项目启动时，就自动的加载 DispatcherServlet实例，1表示加载的顺序号--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--1.配置的url-pattern为 /，表示用户的请求都经过 DispatcherServlet</span><br><span class="hljs-comment">        2.这样配置也支持 rest 风格的url请求--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>web目录下创建login.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;登录&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h3&gt;登录页面&lt;/h3&gt;<br>&lt;%--<br>    action=<span class="hljs-string">&quot;login&quot;</span>: 这样写实际上是相对路径，而相对路径是以当前的浏览器地址栏而言。<br>    因此实际上这里表示的 url 是 http:<span class="hljs-comment">//localhost:8080/web工程路径/login</span><br>--%&gt;<br>&lt;form action=<span class="hljs-string">&quot;login&quot;</span>&gt;<br>    u:&lt;input name=<span class="hljs-string">&quot;username&quot;</span> type=<span class="hljs-string">&quot;text&quot;</span>/&gt; &lt;br/&gt;<br>    p:&lt;input name=<span class="hljs-string">&quot;password&quot;</span> type=<span class="hljs-string">&quot;password&quot;</span>/&gt; &lt;br/&gt;<br>    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;登录&quot;</span>/&gt;<br>&lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>关于web工程路径，详见 Javaweb–day18-web工程路径</p></blockquote><ol start="6"><li><p>创建 src&#x2F;com&#x2F;li&#x2F;web&#x2F;UserServlet.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.li.web;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 李</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * 1.如果我们使用了SpringMVC，在一个类上标识 <span class="hljs-doctag">@Controller</span></span><br><span class="hljs-comment"> * 2.表示将该类视为一个控制器，注入到容器</span><br><span class="hljs-comment"> * 3.比原生的 servlet方便很多</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServlet</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 编写login方法，响应用户请求</span><br><span class="hljs-comment">     * 1.login()方法用于响应用户的登录请求</span><br><span class="hljs-comment">     * 2.<span class="hljs-doctag">@RequestMapping</span>(value = &quot;/login&quot;)</span><br><span class="hljs-comment">     *    类似于我们原生的Servlet配置的url-pattern，不同的是这里是给方法配置url映射</span><br><span class="hljs-comment">     * 3.当用户在浏览器地址栏输入 http://localhost:8080/web工程路径/login</span><br><span class="hljs-comment">     *    就能够访问当到 login()方法</span><br><span class="hljs-comment">     * 4.return &quot;login_ok&quot;; 表示返回结果给视图解析器（InternalResourceViewResolver），</span><br><span class="hljs-comment">     *    视图解析器会根据配置，来决定提交到哪一个页面，如：</span><br><span class="hljs-comment">     * &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="hljs-comment">     *    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;/&gt;</span><br><span class="hljs-comment">     *    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;</span><br><span class="hljs-comment">     * &lt;/bean&gt;</span><br><span class="hljs-comment">     * 根据上面的配置，return &quot;login_ok&quot;; 就是转发到 /WEB-INF/pages/login_ok.jsp</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/login&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;login ok...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login_ok&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建web&#x2F;WEB-INF&#x2F;pages&#x2F;login_ok.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;登录成功&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;恭喜，登录成功！&lt;/h1&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></li><li><p>配置容器文件applicationContext-mvc.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--指定扫描的包--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.li.web&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--配置视图解析器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--配置属性 suffix(后缀) 和 prefix(前缀)--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/pages/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>整体的文件位置如下：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230202212119630.png" alt="image-20230202212119630" style="zoom:67%;" /></li><li><p>启动tomcat，访问 <code>http://localhost:8080/springmvc/login.jsp</code>，访问成功：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230202211845571.png" alt="image-20230202211845571" style="zoom:60%;" /></li><li><p>点击登录，成功访问到login_ok.jsp</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230202212014130.png" alt="image-20230202212014130" style="zoom: 55%;" /></li></ol><h3 id="3-4注意事项和细节说明"><a href="#3-4注意事项和细节说明" class="headerlink" title="3.4注意事项和细节说明"></a>3.4注意事项和细节说明</h3><ol><li><p>这里的UserServlet 需要注解成一个@Controller，我们称之为一个Handler处理器</p></li><li><p>在UserServlet 指定 url 时，value 可以省略（注意是省略“value”字符，不是省略值）</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230202212828452.png" alt="image-20230202212828452" style="zoom:67%;" /></li><li><p>关于SpringMVC 的 DispatcherServlet 的配置文件，如果不在web.xml中指定spring配置文件，则默认在<code>/WEB-INF/</code>目录下找名为 <code>springDispatcherServlet-servlet.xml</code> 的spring配置文件。</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230202215055842.png" alt="image-20230202215055842" style="zoom:67%;" /><p>因此，我们将之前的spring容器文件移动到&#x2F;web-INF&#x2F;目录下，并注释掉web.xml配置的<code>&lt;init-param&gt;</code>，然后将容器文件重命名为 springDispatcherServlet-servlet.xml，重启tomcat，依然可以成功运行。</p></li></ol><h2 id="4-SpringMVC执行流程"><a href="#4-SpringMVC执行流程" class="headerlink" title="4.SpringMVC执行流程"></a>4.SpringMVC执行流程</h2><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%902.png" style="zoom: 50%;" />]]></content>
    
    
    <categories>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客搭建记录</title>
    <link href="/2023/01/12/22-36-04/"/>
    <url>/2023/01/12/22-36-04/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo博客搭建记录"><a href="#Hexo博客搭建记录" class="headerlink" title="Hexo博客搭建记录"></a>Hexo博客搭建记录</h1><blockquote><p>参考视频：<a href="https://www.bilibili.com/video/av44544186/?vd_source=7e137c3a1559f85aacb1f151bb0a830d">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程</a></p><p>以下命令操作建议使用管理员权限完成</p></blockquote><h2 id="1-nodejs-amp-hexo-安装"><a href="#1-nodejs-amp-hexo-安装" class="headerlink" title="1. nodejs &amp; hexo 安装"></a>1. nodejs &amp; hexo 安装</h2><p>1.首先下载node.js，并安装（安装node时，会自动安装npm），安装完毕后在控制台输入<code>node -v</code>，如果显示版本则说明安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">D:\&gt;node -v<br>v16.18.1<br><br>D:\&gt;npm -v<br>8.19.2<br></code></pre></td></tr></table></figure><p>2.安装cnpm，命令为<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><p>（因为这里我已经下过了，所以显示可能不准确）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">D:\&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org<br>npm WARN deprecated @npmcli/move-file@2.0.1: This functionality has been moved to @npmcli/fs<br><br>added 4 packages, removed 6 packages, and changed 415 packages <span class="hljs-keyword">in</span> 1m<br><br>11 packages are looking <span class="hljs-keyword">for</span> funding<br>  run `npm fund` <span class="hljs-keyword">for</span> details<br></code></pre></td></tr></table></figure><p>输入<code>cnpm -v</code>，如果出现下面的字样说明安装cnpm成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">D:\&gt;cnpm -v<br>cnpm@9.0.1 (D:\apps\nodejs16.18.1\node_global\node_modules\cnpm\lib\parse_argv.js)<br>npm@8.19.3 (D:\apps\nodejs16.18.1\node_global\node_modules\cnpm\node_modules\npm\index.js)<br>node@16.18.1 (D:\apps\nodejs16.18.1\node.exe)<br>npminstall@7.3.1 (D:\apps\nodejs16.18.1\node_global\node_modules\cnpm\node_modules\npminstall\lib\index.js)<br>prefix=D:\apps\nodejs16.18.1\node_global<br>win32 x64 10.0.19044<br>registry=https://registry.npmmirror.com<br></code></pre></td></tr></table></figure><p>3.使用cnpm安装hexo，命令<code>cnpm install -g hexo-cli</code>，安装完毕后使用命令<code>hexo -v</code>，如果出现以下字样说明安装hexo成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">D:\&gt;hexo -v<br>hexo-cli: 4.3.0<br>os: win32 10.0.19044<br>node: 16.18.1<br>v8: 9.4.146.26-node.22<br>uv: 1.43.0<br>zlib: 1.2.11<br>brotli: 1.0.9<br>ares: 1.18.1<br>modules: 93<br>nghttp2: 1.47.0<br>napi: 8<br>llhttp: 6.0.10<br>openssl: 1.1.1q+quic<br>cldr: 41.0<br>icu: 71.1<br>tz: 2022b<br>unicode: 14.0<br>ngtcp2: 0.8.1<br>nghttp3: 0.7.0<br></code></pre></td></tr></table></figure><h2 id="2-使用hexo搭建博客"><a href="#2-使用hexo搭建博客" class="headerlink" title="2.使用hexo搭建博客"></a>2.使用hexo搭建博客</h2><p>1.首先使用命令<code>hexo init &lt;yourBlogName&gt;</code>：创建你的站点目录，并使用hexo初始化该文件夹</p><blockquote><p>如果在搭建博客的过程中有问题，只要把文件夹删掉重来即可</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">D:\&gt;hexo init blog<br>INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git<br>INFO  Install dependencies<br>INFO  Start blogging with Hexo!<br></code></pre></td></tr></table></figure><p>初始化成功后，站点目录下生成的文件：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112003332202.png" alt="image-20230112003332202" style="zoom:67%;" /><p>2.使用命令<code>hexo s</code>，启动博客（注意要之前的目录下运行），博客在本地的4000端口启动，访问<a href="http://localhost:4000/">http://localhost:4000/</a> 即可以看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">D:\blog&gt;hexo s<br>INFO  Validating config<br>INFO  Start processing<br>INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.<br></code></pre></td></tr></table></figure><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112004204737.png" alt="image-20230112004204737" style="zoom:50%;" /><p>3.使用命令<code>hexo n &quot;文章名&quot;</code>，创建博客文章。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">D:\blog&gt;hexo n <span class="hljs-string">&quot;我的第一篇博客文章&quot;</span><br>INFO  Validating config<br>INFO  Created: D:\blog\<span class="hljs-built_in">source</span>\_posts\我的第一篇博客文章.md<br></code></pre></td></tr></table></figure><p>进入对应的目录下，可以看到已经成功生成文件，然后就可以在文件中写博客了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">D:\blog&gt;<span class="hljs-built_in">cd</span> D:\blog\<span class="hljs-built_in">source</span>\_posts\<br>D:\blog\<span class="hljs-built_in">source</span>\_posts&gt;<span class="hljs-built_in">dir</span><br> 驱动器 D 中的卷是 Data<br> 卷的序列号是 8A15-B825<br><br> D:\blog\<span class="hljs-built_in">source</span>\_posts 的目录<br><br>2023/01/12  00:48    &lt;DIR&gt;          .<br>2023/01/12  00:48    &lt;DIR&gt;          ..<br>2023/01/12  00:08               876 hello-world.md<br>2023/01/12  00:48                75 我的第一篇博客文章.md<br>               2 个文件            951 字节<br>               2 个目录 1,724,429,172,736 可用字节<br></code></pre></td></tr></table></figure><p>4.返回博客目录，使用命令<code>hexo clean</code>清理一下缓存文件，使用命令<code>hexo g</code>在hexo站点根目录下生成public文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">D:\blog\<span class="hljs-built_in">source</span>\_posts&gt;<span class="hljs-built_in">cd</span> ../..<br><br>D:\blog&gt;hexo clean<br>INFO  Validating config<br>INFO  Deleted database.<br><br>D:\blog&gt;hexo g<br>INFO  Validating config<br>INFO  Start processing<br>INFO  Files loaded <span class="hljs-keyword">in</span> 157 ms<br>INFO  Generated: archives/index.html<br>INFO  Generated: index.html<br>INFO  Generated: tags/杂记/index.html<br>INFO  Generated: archives/2023/01/index.html<br>INFO  Generated: js/jquery-3.4.1.min.js<br>INFO  Generated: fancybox/jquery.fancybox.min.css<br>INFO  Generated: css/fonts/fontawesome-webfont.woff<br>INFO  Generated: fancybox/jquery.fancybox.min.js<br>INFO  Generated: archives/2023/index.html<br>INFO  Generated: js/script.js<br>INFO  Generated: css/style.css<br>INFO  Generated: css/fonts/fontawesome-webfont.ttf<br>INFO  Generated: css/images/banner.jpg<br>INFO  Generated: css/fonts/fontawesome-webfont.eot<br>INFO  Generated: css/fonts/FontAwesome.otf<br>INFO  Generated: css/fonts/fontawesome-webfont.woff2<br>INFO  Generated: 2023/01/12/hello-world/index.html<br>INFO  Generated: 2023/01/12/我的第一篇博客文章/index.html<br>INFO  Generated: css/fonts/fontawesome-webfont.svg<br>INFO  19 files generated <span class="hljs-keyword">in</span> 360 ms<br><br>D:\blog&gt;<br></code></pre></td></tr></table></figure><p>5.然后重新启动服务，浏览器访问端口，成功生成新的文章。</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112010050731.png" alt="image-20230112010050731" style="zoom:67%;" /><h2 id="3-将博客部署到github"><a href="#3-将博客部署到github" class="headerlink" title="3.将博客部署到github"></a>3.将博客部署到github</h2><p>1.登录github，创建新仓库，仓库名必须如下：</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112010910756.png" alt="image-20230112010910756" style="zoom:67%;" /><p>其他选项默认，然后点击创建仓库。</p><p>2.使用命令<code>npm install hexo-deployer-git --save</code>，安装git。</p><p>注意设置用户名和邮件：(随意)</p><p><code>git config --global user.name &lt;你的用户名&gt;</code><br><code>git config --global user.email &lt;你的邮箱&gt;</code></p><p>3.在hexo博客目录下的 _config.yml 文件，最后几行改为如下形式，然后保存。</p><blockquote><p>注意：每个冒号后面要加空格</p></blockquote><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112012113713.png" alt="image-20230112012113713" style="zoom:67%;" /><p>4.使用命令<code>hexo d</code>，将博客部署到github中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">D:\blog&gt;hexo d<br>INFO  Validating config<br>INFO  Deploying: git<br>INFO  Setting up Git deployment...<br>Initialized empty Git repository <span class="hljs-keyword">in</span> D:/blog/.deploy_git/.git/<br>...<br>...<br>Enumerating objects: 39, <span class="hljs-keyword">done</span>.<br>Counting objects: 100% (39/39), <span class="hljs-keyword">done</span>.<br>Delta compression using up to 8 threads<br>Compressing objects: 100% (29/29), <span class="hljs-keyword">done</span>.<br>Writing objects: 100% (39/39), 886.59 KiB | 1.82 MiB/s, <span class="hljs-keyword">done</span>.<br>Total 39 (delta 5), reused 0 (delta 0), pack-reused 0<br>remote: Resolving deltas: 100% (5/5), <span class="hljs-keyword">done</span>.<br>To github.com:liyuelian/liyuelian.github.io.git<br> * [new branch]      HEAD -&gt; master<br>branch <span class="hljs-string">&#x27;master&#x27;</span> <span class="hljs-built_in">set</span> up to track <span class="hljs-string">&#x27;git@github.com:liyuelian/liyuelian.github.io.git/master&#x27;</span>.<br>INFO  Deploy <span class="hljs-keyword">done</span>: git<br></code></pre></td></tr></table></figure><blockquote><p>这里没有设置ssh免密登录的要输入github账号密码</p></blockquote><p>5.在github仓库刷新，可以看到所有hexo文件已经上传到仓库中。</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112013058368.png" alt="image-20230112013058368" style="zoom:67%;" /><p>6.在地址栏中访问<code>&lt;你的github用户名&gt;.github.io</code>，即可看到个人博客网站。</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112013505644.png" alt="image-20230112013505644" style="zoom:67%;" /><h2 id="4-如何发布新文章"><a href="#4-如何发布新文章" class="headerlink" title="4.如何发布新文章"></a>4.如何发布新文章</h2><blockquote><p>参考：<a href="https://cloud.tencent.com/developer/article/1662733">Hexo博客教程（二）| 如何写作新文章并发布</a></p></blockquote><p>1.首先使用命令<code>hexo new &lt;title&gt;</code>创建新文章，然后到hexo目录&#x2F;source&#x2F;_posts下去编写文章。</p><p>使用该命令创建的md文件头会有一个前置信息Front-matter，用于给hexo渲染md文档。</p><table><thead><tr><th align="left">配置项</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">title</td><td align="left">文章标题</td></tr><tr><td align="left">date</td><td align="left">文章创建日期</td></tr><tr><td align="left">comments</td><td align="left">是否启动文章评论功能</td></tr><tr><td align="left">tags</td><td align="left">文章标签</td></tr><tr><td align="left">categories</td><td align="left">文章分类</td></tr><tr><td align="left">keywords</td><td align="left">文章关键字</td></tr></tbody></table><p>2.使用命令<code>hexo clean</code>，清除掉旧的数据</p><blockquote><p>这个命令会清除掉之前生成的网页，即站点根目录下的<code>public</code>文件夹。</p></blockquote><p>3.使用命令<code>hexo g</code></p><blockquote><p>这个命令会将<code>source</code>文件夹下所有的md文件进行渲染，生成HTML页面，存放在<code>public</code>文件夹下。</p></blockquote><p>特别提醒！ 每次修改文章后，都要执行这两条命令，清除掉旧的数据，然后重新生成页面。</p><p>4.使用命令<code>hexo d</code>，将文件上传到你的远程仓库中即可。</p><blockquote><p>可以先使用hexo s，先在本地预览一下</p></blockquote><h2 id="5-如何更换博客主题"><a href="#5-如何更换博客主题" class="headerlink" title="5.如何更换博客主题"></a>5.如何更换博客主题</h2><blockquote><p>以yilia主题为例：<a href="https://github.com/litten/hexo-theme-yilia">litten&#x2F;hexo-theme-yilia: A simple and elegant theme for hexo. (github.com)</a></p></blockquote><p>1.在你的hexo目录下运行：<code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">D:\blog&gt;git <span class="hljs-built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia<br>Cloning into <span class="hljs-string">&#x27;themes/yilia&#x27;</span>...<br>remote: Enumerating objects: 2037, <span class="hljs-keyword">done</span>.<br>remote: Counting objects: 100% (1/1), <span class="hljs-keyword">done</span>.<br>remote: Total 2037 (delta 0), reused 0 (delta 0), pack-reused 2036<br>Receiving objects: 100% (2037/2037), 10.53 MiB | 398.00 KiB/s, <span class="hljs-keyword">done</span>.<br><br>Resolving deltas: 100% (1079/1079), <span class="hljs-keyword">done</span>.<br></code></pre></td></tr></table></figure><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112020544576.png" alt="image-20230112020544576" style="zoom:67%;" /><p>2.在_config.yml文件中修改主题，保存。</p><blockquote><p>注意冒号后面有空格</p></blockquote><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112020815301.png" alt="image-20230112020815301" style="zoom:67%;" /><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112020902973.png" alt="image-20230112020902973" style="zoom:67%;" /><p>3.在hexo目录下使用<code>hexo clean</code>，然后使用<code>hexo g</code>重新生成public文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">D:\blog&gt;hexo clean<br>INFO  Validating config<br>INFO  Deleted database.<br>INFO  Deleted public folder.<br><br>D:\blog&gt;hexo g<br>INFO  Validating config<br>INFO  Start processing<br>INFO  Files loaded <span class="hljs-keyword">in</span> 285 ms<br>...<br>INFO  20 files generated <span class="hljs-keyword">in</span> 64 ms<br></code></pre></td></tr></table></figure><p>4.使用<code>hexo s</code>在本地启动，预览一下</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112021746933.png" alt="image-20230112021746933" style="zoom:67%;" /><p>5.觉得没问题了，就在hexo目录下使用<code>hexo d</code>，将新的博客文件发布到你的远程仓库中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">D:\blog&gt;hexo d<br>INFO  Validating config<br>INFO  Deploying: git<br>...<br>INFO  Deploy <span class="hljs-keyword">done</span>: git<br></code></pre></td></tr></table></figure><p>然后在你的&lt;github个人用户名&gt;.github.io上就可以看到新的博客主题了</p><blockquote><p>有时候会延迟一会才能更新</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HelloWorld!</title>
    <link href="/2023/01/12/22-29-15/"/>
    <url>/2023/01/12/22-29-15/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>主题 3 编辑器(Vim)</title>
    <link href="/2023/01/12/00-15-22/"/>
    <url>/2023/01/12/00-15-22/</url>
    
    <content type="html"><![CDATA[<h1 id="主题-3-编辑器-Vim"><a href="#主题-3-编辑器-Vim" class="headerlink" title="主题 3 编辑器(Vim)"></a>主题 3 编辑器(Vim)</h1><p><a href="https://missing-semester-cn.github.io/2020/editors/">编辑器 (Vim) · the missing semester of your cs education (missing-semester-cn.github.io)</a></p><p>代码编辑器和和其他的编辑器（比如用来写文章的编辑器）有一些不同。</p><p>这是因为写程序和写文章不同。当你写程序时，会花大量时间来阅读你写的东西，或者来移动光标，做一些小小的修改；而不是像写文章的时候，从上到下一气呵成。因此，对于不同的用途，我们会使用不同的编辑器，这是很合理的。</p><h2 id="1-该学哪个编辑器"><a href="#1-该学哪个编辑器" class="headerlink" title="1.该学哪个编辑器?"></a>1.该学哪个编辑器?</h2><p><a href="https://insights.stackoverflow.com/survey/2019/#development-environments-and-tools">Stack Overflow 的调查</a>显示，VS Code是目前最流行的代码编辑器。而 <a href="https://www.vim.org/">Vim</a> 则是最流行的基于命令行的编辑器。就算最终你没有打算长期使用Vim，我们仍然认为学习Vim背后的思想很有价值。</p><p>另外，许多工具也觉得vim哲学很棒，从而提供了Vim模式。例如当前最热门的VS Code，支持Vim键位绑定，该插件已经被下载了数百万次。</p><h2 id="2-Vim的哲学"><a href="#2-Vim的哲学" class="headerlink" title="2.Vim的哲学"></a>2.Vim的哲学</h2><p>Vim是一个基于模式（Modal）的编辑器，这意味着Vim有多个模式。</p><blockquote><p>Modal这个词源于Mode</p></blockquote><p>多模式的思想源于，当你在写程序的时候会经常做不同的事情。</p><p>在编程的时候，你会把大量时间花在阅读&#x2F;编辑而不是在写代码上。所以，Vim 是一个<strong>多模态</strong>编辑器：它对于插入文字和操纵文字有不同的模式。Vim 是可编程的（可以使用 Vimscript 或者像 Python 一样的其他程序语言），Vim 的接口本身也是一个程序语言：键入操作（以及其助记名） 是命令，这些命令也是可组合的。Vim 避免了使用鼠标，因为那样太慢了；Vim 甚至避免用上下左右键因为那样需要太多的手指移动。</p><p>这样的设计哲学使得 Vim 成为了一个能跟上你思维速度的编辑器。</p><h2 id="3-编辑模式"><a href="#3-编辑模式" class="headerlink" title="3.编辑模式"></a>3.编辑模式</h2><ul><li><p><strong>正常模式</strong>：Normal，在文件中四处移动光标进行修改</p></li><li><p><strong>插入模式</strong>：Insert，插入文本</p></li><li><p><strong>替换模式</strong>：replace，替换文本</p></li><li><p><strong>可视化模式</strong>（一般，行，块）：Visual，Visual Line，Visual Block，选中文本块</p></li><li><p><strong>命令行模式</strong>：Command Line，用于执行命令</p></li><li><p>Normal-正常模式 &amp; Insert-插入模式</p></li></ul><p>当你开始使用Vim时，它会在<code>Normal</code>模式下启动。在这个模式下，各种键位组合拥有在这个模式下的特定意义。其中就有一些按键组合来切换到其他的模式。而切换后这些键位组合和意义也相应改变。</p><p>你的大部分时间都会在<code>Insert</code>和<code>Normal</code>模式下，在Normal模式下按下<code>i</code>键就可以进入Insert模式。而在Insert模式下按下<code>Esc</code>就可以回到Normal模式。</p><blockquote><p>这里注意一下我们表示按键的方式，这个表示方式将会用于笔记以及Vim给你的提示中：当仅仅是代表<code>i</code>键这样一个按键本身时，那么就会直接写<code>i</code>。但是对于如Ctrl+v这种按键组合，就有可能以这么几种形式来体现：</p><p>第一种是一个脱字符号后跟着控制用字符：<code>^v</code>（这里控制用字符指v，也就是组合键中的另一个键），另一种写法可能是你最熟悉的：<code>Ctrl-v</code>，而有的地方我们可能会写成：<code>&lt;c-v&gt;</code></p></blockquote><p>Vim有好几种模式，而Normal模式是用来移动光标、阅读东西，以及在文件间切换的。而Insert模式是用来输入的，因此在Insert模式下，你的按键大多会直接进入buffer（缓冲区），而在Normal模式下则不然，它们不会进入buffer，而是用来进行了一些浏览和编辑操作。</p><blockquote><p><a href="https://joshldavis.com/2014/04/05/vim-tab-madness-buffers-vs-tabs/">Vim Tab Madness. Buffers vs Tabs</a><a href="https://blog.csdn.net/jy692405180/article/details/79775125">如何理解并正确使用 Vim 中的 Buffer ,  Window 和 Tab</a>  </p></blockquote><ul><li>replace-替换模式</li></ul><p>不像插入模式那样会把字符往后移，替换模式会直接覆盖掉文本。</p><ul><li>可视化模式（一般，行，块）</li></ul><p>可视化模式有Visual 模式，Visual Line模式，以及一个Visual Block模式。</p><hr><ul><li>各种模式的切换</li></ul><p>你可以按下 <code>&lt;ESC&gt;</code>（退出键）从任何其他模式返回正常模式。在正常模式，键入 <code>i</code> 进入插入 模式，<code>R</code> 进入替换模式，<code>v</code> 进入可视（一般）模式，<code>shift+V</code> 进入可视（行）模式，<code>&lt;C-v&gt;</code> （Ctrl-V, 有时也写作 <code>^V</code>）进入可视（块）模式，<code>:</code> 进入命令模式。</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230106005400023.png" alt="image-20230106005400023" style="zoom:60%;" /><ul><li>映射Esc键</li></ul><p>从非Normal模式切换到Normal模式下都是按<code>Esc</code>键，因此使用Vim时要频繁按<code>Esc</code>键。但这个键在键盘的角落里，按起来很不方便，所以很多人会将键盘上某个键映射成Esc。通常这个键是<code>Caps Lock</code>，因为它在键盘的中间一行上。</p><h2 id="4-基本操作"><a href="#4-基本操作" class="headerlink" title="4.基本操作"></a>4.基本操作</h2><ul><li>如何打开Vim程序</li></ul><p>Vim是一个基于命令行的编辑器，我们要打开Vim，只需要在命令行中键入<code>vim</code>。vim也可以接收参数，当我们想用它直接编辑特定的文件时，可以在vim 后面加上文件的路径+文件名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos vim]$ <span class="hljs-built_in">ls</span><br>poem.md<br>[lighthouse@VM-8-17-centos vim]$ vim poem.md <br></code></pre></td></tr></table></figure><h3 id="4-1插入文本"><a href="#4-1插入文本" class="headerlink" title="4.1插入文本"></a>4.1插入文本</h3><h3 id="4-2缓存，标签页，窗口"><a href="#4-2缓存，标签页，窗口" class="headerlink" title="4.2缓存，标签页，窗口"></a>4.2缓存，标签页，窗口</h3><h3 id="4-3命令行"><a href="#4-3命令行" class="headerlink" title="4.3命令行"></a>4.3命令行</h3><h2 id="5-Vim的接口其实是一种编程语言"><a href="#5-Vim的接口其实是一种编程语言" class="headerlink" title="5.Vim的接口其实是一种编程语言"></a>5.Vim的接口其实是一种编程语言</h2><h3 id="5-1移动"><a href="#5-1移动" class="headerlink" title="5.1移动"></a>5.1移动</h3><h3 id="5-2选择"><a href="#5-2选择" class="headerlink" title="5.2选择"></a>5.2选择</h3><h3 id="5-3编辑"><a href="#5-3编辑" class="headerlink" title="5.3编辑"></a>5.3编辑</h3><h3 id="5-4计数"><a href="#5-4计数" class="headerlink" title="5.4计数"></a>5.4计数</h3><h3 id="5-5修饰语"><a href="#5-5修饰语" class="headerlink" title="5.5修饰语"></a>5.5修饰语</h3><h2 id="6-演示"><a href="#6-演示" class="headerlink" title="6.演示"></a>6.演示</h2><h2 id="7-自定义Vim"><a href="#7-自定义Vim" class="headerlink" title="7.自定义Vim"></a>7.自定义Vim</h2><h2 id="8-扩展Vim"><a href="#8-扩展Vim" class="headerlink" title="8.扩展Vim"></a>8.扩展Vim</h2><h2 id="9-其他程序的Vim模式"><a href="#9-其他程序的Vim模式" class="headerlink" title="9.其他程序的Vim模式"></a>9.其他程序的Vim模式</h2><h2 id="10-Vim-进阶"><a href="#10-Vim-进阶" class="headerlink" title="10.Vim 进阶"></a>10.Vim 进阶</h2><h2 id="11-拓展资料"><a href="#11-拓展资料" class="headerlink" title="11.拓展资料"></a>11.拓展资料</h2><h2 id="12-课后练习"><a href="#12-课后练习" class="headerlink" title="12.课后练习"></a>12.课后练习</h2>]]></content>
    
    
    <categories>
      
      <category>the missing semester of cs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主题 1 The Shell</title>
    <link href="/2023/01/12/00-15-22/"/>
    <url>/2023/01/12/00-15-22/</url>
    
    <content type="html"><![CDATA[<h1 id="主题-1-The-Shell"><a href="#主题-1-The-Shell" class="headerlink" title="主题 1 The Shell"></a>主题 1 The Shell</h1><p><a href="https://missing-semester-cn.github.io/2020/course-shell/">课程概览与 shell · the missing semester of your cs education (missing-semester-cn.github.io)</a></p><h2 id="Shell是什么？"><a href="#Shell是什么？" class="headerlink" title="Shell是什么？"></a>Shell是什么？</h2><p>一旦你想脱离可视化界面让你做的，然后做点别的事情，那么Shell将是你和计算机交互的最主要的方式之一。</p><p>可视化界面受限于，它只能做被设计出来的操作——比如你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。这就是这门课介绍命令行工具和基于文本的工具的理由，shell则是你去做这些操作的地方。</p><p>在Windows和Linux可以找到成堆的终端（Terminal），这些是能显示Shell的文本窗口。其中普遍的是bash，或者叫Bourne Again Shell。由于bash的普遍性，这门课中将使用bash。</p><h2 id="使用Shell"><a href="#使用Shell" class="headerlink" title="使用Shell"></a>使用Shell</h2><p>终端（Terminal）是你电脑上和shell交互的主要文本界面。</p><p>当你打开一个终端，你通常会在终端中看到这样的一行，称为命令行提示符（Shell Prompt）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos ~]<span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><p>它告诉你，你的主机名是<code>VM-8-17-centos</code>，你的用户名是<code>root</code>，还有你当前所在的路径为<code>~</code>（path）。</p><p>可以在终端上执行命令，通常是带着参数（argument）执行程序。参数一般是一些紧随程序名后面的，用空格分开的东西。</p><ul><li>date</li></ul><p>date输入当前日期和时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos ~]<span class="hljs-comment"># date</span><br>Sat Dec 17 01:04:35 CST 2022<br></code></pre></td></tr></table></figure><ul><li>echo</li></ul><p>echo打印出你传给它的参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos ~]<span class="hljs-comment"># echo hello</span><br>hello<br></code></pre></td></tr></table></figure><ul><li>参数以空格分隔</li></ul><p>如上所说，参数是被空格分隔的，如果传递一个多单词的参数，就必须用引号括起来，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos ~]<span class="hljs-comment"># echo &quot;Hello Wrold&quot;</span><br>Hello Wrold<br></code></pre></td></tr></table></figure><p>这样echo程序会收到一个字符串参数<code>Hello World</code>，中间还有一个空格。此外使用单引号也是可以的。</p><blockquote><p>单双引号的区别将在bash scripting 再说</p></blockquote><p>此外也可以使用转义符将空格转义，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos ~]<span class="hljs-comment"># echo Hello\ World</span><br>Hello World<br></code></pre></td></tr></table></figure><blockquote><p>关于如何给参数，变量转义，解析和加括号将在之后涉及</p></blockquote><p>我们在创建目录或文件时，如果某个参数是带空格的，也需要使用引号转义或者用转义符将空格转义，否者shell将会将该参数识别成两个参数。</p><p>如下shell将<code>my photo</code>识别成两个参数，创建了两个目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos ~]<span class="hljs-comment"># mkdir my photo</span><br>[root@VM-8-17-centos ~]<span class="hljs-comment"># ls</span><br>my  photo<br></code></pre></td></tr></table></figure><p>正确的做法为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos ~]<span class="hljs-comment"># mkdir &quot;my photo&quot;</span><br>[root@VM-8-17-centos ~]<span class="hljs-comment"># ll</span><br>total 4<br>drwxr-xr-x 2 root root 4096 Dec 17 01:23 <span class="hljs-string">&#x27;my photo&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="在Shell中导航"><a href="#在Shell中导航" class="headerlink" title="在Shell中导航"></a>在Shell中导航</h2><ul><li>环境变量</li></ul><p>你可能会好奇，当输入date或者echo等命令时，Shell怎么知道这些程序要做什么。</p><p>你的机器可能内嵌了终端程序，或者某些浏览器。同样的，电脑也内嵌了很多围绕终端工作的程序，这些程序位于你的文件系统（File System），Shell有办法在系统中搜索某个程序，然后执行。</p><p>当然，Shell不会在所有文件中进行搜索，那样效率太低了。</p><p>Shell借助一个叫做 <strong>环境变量（Environment Variable）</strong> 的东西来完成搜索。</p><blockquote><p>环境变量就类似编程语言中的变量，Shell或者说bash本身就是一种程序设计语言。你输入的提示符（Prompt）不仅能带参运行程序，你也可以写入while循环，for循环，条件语句等，甚至可以定义函数，甚至变量。关于Shell Scripting的下一讲会有涉及</p></blockquote><p>环境变量是Shell本就设定好的，无论何时打开shell都无需重新设置。一堆东西都会预先设置好，比如哪里是home目录，你的用户名是什么等。</p><ul><li>PATH变量</li></ul><p>如下，当我们执行<code>echo $PATH</code>时，将会输出一些电脑上的目录，这些目录就是Shell寻找程序时所查找的目录。这些目录以冒号分隔。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos ~]<span class="hljs-comment"># echo $PATH</span><br>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin<br></code></pre></td></tr></table></figure><p>当你输入一个程序名称时，电脑会在这个列表中的每个目录里，查找名字与你所输入的指令相同的一个程序或者文件。如果在这些目录中可以找到待运行的程序，程序可以正常运行，否则失败。</p><ul><li>which</li></ul><p>如果我们想要知道电脑具体运行了哪一个目录里的程序，可以使用which指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos ~]<span class="hljs-comment"># which echo</span><br>/usr/bin/echo<br>[root@VM-8-17-centos ~]<span class="hljs-comment"># which date</span><br>/usr/bin/date<br></code></pre></td></tr></table></figure><ul><li>路径</li></ul><p>路径是用来描述你的计算机里文件位置的东西。</p><p>在Linux或者Mac Os上，路径被一连串的斜杠分隔，可以看到上面echo指令的路径起点在根目录<code>/</code>（&#x2F; 即整个文件系统的最顶层）</p><blockquote><p>在Windows里，路径以反斜杠\ 而非斜杠&#x2F;分隔。</p></blockquote><p>在Linux或Mac Os上，所有东西都在一个叫根（root）的空间的下面的某处。因此所有以斜杠开头&#x2F;的路径都是<strong>绝对路径</strong>。</p><p>而在Windows下，每一个分区都有一个根，类似于C:\或者D:\，所以Windows里每一个驱动器(硬盘)下都有独立的一套文件系统的层次结构。</p><blockquote><p>绝对路径：是可以绝对准确地确定一个文件的位置的路径</p><p>相对路径：是相对于你当前所在位置的路径</p></blockquote><ul><li>pwd</li></ul><p>打印工作目录（print working directory）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos ~]<span class="hljs-comment"># pwd</span><br>/root<br></code></pre></td></tr></table></figure><p>你可以改变当前工作目录，所有的相对路径都是相对于当前工作目录的</p><ul><li>cd</li></ul><p>change directory 改变当前工作目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos ~]<span class="hljs-comment"># cd /home</span><br>[root@VM-8-17-centos home]<span class="hljs-comment"># pwd</span><br>/home<br></code></pre></td></tr></table></figure><blockquote><p>shell提示只会给路径的最后一段名称，当然也可以通过设置是它总能显示当前的完整路径</p></blockquote><ul><li>特殊的目录 <code>. </code>和<code> ..</code></li></ul><p><code>.</code> 表示当前目录，<code>..</code>表示上一级（父）目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos lighthouse]<span class="hljs-comment"># pwd</span><br>/home/lighthouse<br>[root@VM-8-17-centos lighthouse]<span class="hljs-comment"># cd ../../..</span><br>[root@VM-8-17-centos /]<span class="hljs-comment"># pwd</span><br>/<br></code></pre></td></tr></table></figure><blockquote><p>使用相对or绝对路径取决于哪个方便，但是如果有时候你需要运行某个程序或者写一个程序，它调用了类似echo或者date这样的程序，你希望它在哪个地方都能跑起来，要么你就只给出这个要被运行的程序的名字(让shell用path去找出它们在哪里)，要么就需要给出绝对路径</p><p>一般来说程序默认在当前目录运行</p></blockquote><ul><li>ls</li></ul><p>输入本级目录下的所有文件信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos /]<span class="hljs-comment"># ls</span><br>bin  boot  data  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<br></code></pre></td></tr></table></figure><p>如果给定路径参数，则会输出给定路径目录下的文件信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos /]<span class="hljs-comment"># ls home/lighthouse/</span><br>dirdemo  hello2.txt  hello.txt<br></code></pre></td></tr></table></figure><ul><li>特殊符号<code>-</code>和<code>~</code></li></ul><p><code>~</code>表示<strong>当前</strong>用户的home目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos /]<span class="hljs-comment"># cd ~</span><br>[root@VM-8-17-centos ~]<span class="hljs-comment"># pwd</span><br>/root<br></code></pre></td></tr></table></figure><p>在cd命令中，<code>-</code>参数表示之前所处的工作目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos /]<span class="hljs-comment"># cd -</span><br>/home<br>[root@VM-8-17-centos home]<span class="hljs-comment"># cd -</span><br>/<br></code></pre></td></tr></table></figure><ul><li>–help</li></ul><p>大多数命令都有一个 –help选项，可以帮助你了解命令的用法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos /]<span class="hljs-comment"># ls --help</span><br>Usage: <span class="hljs-built_in">ls</span> [OPTION]... [FILE]...<br>List information about the FILEs (the current directory by default).<br>Sort entries alphabetically <span class="hljs-keyword">if</span> none of -cftuvSUX nor --<span class="hljs-built_in">sort</span> is specified.<br><br>Mandatory arguments to long options are mandatory <span class="hljs-keyword">for</span> short options too.<br>  -a, --all                  <span class="hljs-keyword">do</span> not ignore entries starting with .<br>  -A, --almost-all           <span class="hljs-keyword">do</span> not list implied . and ..<br>      --author               with -l, <span class="hljs-built_in">print</span> the author of each file<br>  -b, --escape               <span class="hljs-built_in">print</span> C-style escapes <span class="hljs-keyword">for</span> nongraphic characters<br>      --block-size=SIZE      with -l, scale sizes by SIZE when printing them;<br>                               e.g., <span class="hljs-string">&#x27;--block-size=M&#x27;</span>; see SIZE format below<br>  -B, --ignore-backups       <span class="hljs-keyword">do</span> not list implied entries ending with ~<br>……<br>……<br></code></pre></td></tr></table></figure><p>比如usage这行信息，[ ]表示这部分内容可填可不填，…表示可以填写多个option或flag</p><blockquote><p>option是有多个参数字符可以选择，flag是只有一个参数字符选择</p></blockquote><ul><li>权限</li></ul><p>使用ls -l 命令可以以长列表格式输出当前目录下的文件信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos lighthouse]<span class="hljs-comment"># ls -l</span><br>total 12<br>drwxrwxr-x 2 lighthouse lighthouse 4096 Dec 13 00:33 dirdemo<br>-rw-r--r-- 1 root       root          6 Dec 15 19:56 hello2.txt<br>-rw-rw-r-- 1 lighthouse lighthouse   52 Dec 15 19:59 hello.txt<br></code></pre></td></tr></table></figure><p>首先前面带着d的这行条目，代表这是一个目录，例如上面的dirdemo就是一个目录，hello2.txt和hello.txt则是文件。</p><p>d后面的字符<code>rwxrwxr-x</code>代表文件被授予的权限。</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222225758192.png" alt="image-20221222225758192" style="zoom:67%;" /><p>阅读这一串字符的方法如下：9个字符，每三个一组，分为三组。</p><p>第一组：代表权限被授予给了文件的所有者</p><p>第二组：代表给拥有这些文件的用户组的权限</p><p>第三组：代表给非所有者的其他人的权限</p><p>其中 <code>-</code> 表示该用户不具备相应的权限。</p><p>同时可以发现所有字符都是有rwx组成的，r（read）表示读取权限，w（write）表示写入权限，x（execute）表示执行权限。这三者的权限使用数字表示：4表示r，2表示w，1表示x。</p><p>权限对于文件和目录有不同的解释：</p><p>对文件而言，如果你有读取权限，可以读取文件的内容。文件的写权限就是</p><p>目录的读取权限可以允许你<strong>看</strong>这个文件夹中有哪些东西（列出这个目录的内容）；目录的写入权限是你能否<strong>重命名、新建或者删除</strong>里面的文件；注意如果你有目录里的文件的写入权限，却没有目录的写入权限，那你就不能删除这个文件（即使你清空了这个文件也不能删除它，因为这要目录的写入权限）；最后是目录的执行权限，通常来讲就是搜索权限。这意味着你能不能<strong>进入</strong>这个目录。</p><blockquote><p>为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限(即目录的执行权限)</p></blockquote><ul><li>mv</li></ul><p>它接受两个路径作为参数，第一个是原有的路径，第二个是新的路径。这意味着mv既可以让你重命名一个文件，又可以让你移动一个文件。</p><ul><li>cp</li></ul><p>copy复制，该命令可以让你复制文件，用法很类似。它也接受两个路径作为参数，复制源路径和目标路径，这些路径要是完整路径（意为着你需要明确指定文件路径，这个命令没有搜索功能）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos lighthouse]<span class="hljs-comment"># cp hello.txt ../food.txt</span><br>[root@VM-8-17-centos lighthouse]<span class="hljs-comment"># cd ..</span><br>[root@VM-8-17-centos home]<span class="hljs-comment"># ls</span><br>food.txt  lighthouse<br></code></pre></td></tr></table></figure><ul><li>rm</li></ul><p>移除（删除一个文件），你可以传递一个路径作为参数。</p><p>需要注意默认的移除是非递归的，也就是说你不能rm移除一个目录（因为目录中可能会有文件），你可以传递一个执行递归移除的-r 标识，它就会递归删除目录下的所有内容</p><ul><li>rmdir</li></ul><p>移除目录，同样也是非递归的，这意味着你不能使用该命令删除一个非空目录</p><ul><li>mkdir</li></ul><p>创建一个新目录</p><ul><li>man</li></ul><p>manual pages(手册&#x2F;说明书)，这个程序接受其他程序的名字作为一个参数，然后显示它的说明书。</p><p>和<code>程序名 --help</code>命令相似。</p><ul><li>快捷键Ctrl+L</li></ul><p>清空终端，让光标回到顶部（和clear命令相似）</p><h2 id="在程序间创建连接"><a href="#在程序间创建连接" class="headerlink" title="在程序间创建连接"></a>在程序间创建连接</h2><ul><li>流（Stream）</li></ul><p>程序有两个主要的流（stream），默认下程序会有一个输入流（input stream）和一个输出流（output stream）</p><ol><li><p>默认输入流里的内容来自你的键盘，基本上输入流是终端，无论你向终端输入什么，最后都会传到程序里。</p></li><li><p>默认的输出流（即当程序想要输出一些内容时），默认也是终端</p><blockquote><p>这也是为什么当你在终端中打入<code>echo hello</code>时，hello会直接显示在你的终端里</p></blockquote></li></ol><p>Shell提供了重定向这些流的方法，把输入和输出都改到程序员指明的地方。最直接的方式就是使用大于小于号(即所谓的尖角括号)。</p><ol><li>小于号表示重定向这个程序的输入流</li><li>大于号表示重定向程序的输出流</li></ol><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos lighthouse]<span class="hljs-comment"># echo hello &gt; hello.txt</span><br>[root@VM-8-17-centos lighthouse]<span class="hljs-comment"># cat hello.txt </span><br>hello<br></code></pre></td></tr></table></figure><p>将echo程序输出的内容hello，输入到hello.txt文件中</p><p>cat的作用是打印出一个文件的内容，cat同样支持流的重定向。</p><p>在这个例子中，Shell就会打开hello.txt，取出它的内容，设置成cat的输入，cat就会把这些内容打印到它的输出流，这里没有重定向，所以cat的输出流还是终端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos lighthouse]<span class="hljs-comment"># cat &lt; hello.txt</span><br>hello<br></code></pre></td></tr></table></figure><p>也可以同时使用两种重定向，如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos lighthouse]<span class="hljs-comment"># cat &lt; hello.txt &gt; hello2.txt</span><br>[root@VM-8-17-centos lighthouse]<span class="hljs-comment"># cat hello2.txt </span><br>hello<br></code></pre></td></tr></table></figure><p>用hello.txt的内容作为cat的输入流，然后把cat输出的所欲内容存到hello2.txt中</p><ul><li>双大于号</li></ul><p>作用是追加（append）而不是覆写（overwrite）</p><blockquote><p>追加指向文件尾继续添加内容，覆写是清空文件再写入内容</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos lighthouse]<span class="hljs-comment"># cat &lt; hello.txt &gt; hello2.txt</span><br>[root@VM-8-17-centos lighthouse]<span class="hljs-comment"># cat hello2.txt </span><br>hello<br>[root@VM-8-17-centos lighthouse]<span class="hljs-comment"># cat &lt; hello.txt &gt;&gt; hello2.txt</span><br>[root@VM-8-17-centos lighthouse]<span class="hljs-comment"># cat hello2.txt </span><br>hello<br>hello<br></code></pre></td></tr></table></figure><ul><li>管道符</li></ul><p>pipe，管道符就是一个竖线<code>|</code>。管道的意思是，取左侧程序的输出，称为右侧程序的输入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos /]<span class="hljs-comment"># ls -l | tail -n3</span><br>drwxrwxrwt.  10 root root  4096 Dec 22 22:03 tmp<br>drwxr-xr-x.  12 root root  4096 Dec 31  2021 usr<br>drwxr-xr-x.  20 root root  4096 Dec 31  2021 var<br></code></pre></td></tr></table></figure><p>ls的输出作为tail的输入，tail的输出则会输到终端（因为你没有重定向tail的输出）</p><blockquote><p>tail 打印它输入的最后n行</p></blockquote><p>当然也可以重定向tail的输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos /]<span class="hljs-comment"># ls -l | tail -n3 &gt; ls.txt</span><br>[root@VM-8-17-centos /]<span class="hljs-comment"># cat ls.txt</span><br>drwxrwxrwt.  10 root root  4096 Dec 22 22:03 tmp<br>drwxr-xr-x.  12 root root  4096 Dec 31  2021 usr<br>drwxr-xr-x.  20 root root  4096 Dec 31  2021 var<br></code></pre></td></tr></table></figure><p>使用管道可以构建一些复杂的命令：</p><p>我们可以做一些操作例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos /]<span class="hljs-comment"># curl --head --silent baidu.com</span><br>HTTP/1.1 200 OK<br>Date: Thu, 22 Dec 2022 16:17:30 GMT<br>Server: Apache<br>Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT<br>ETag: <span class="hljs-string">&quot;51-47cf7e6ee8400&quot;</span><br>Accept-Ranges: bytes<br>Content-Length: 81<br>Cache-Control: max-age=86400<br>Expires: Fri, 23 Dec 2022 16:17:30 GMT<br>Connection: Keep-Alive<br>Content-Type: text/html<br></code></pre></td></tr></table></figure><p>这会给你访问baidu.com的时候所有的HTTP Headers</p><p>你可以使用管道将这些输出接到grep -i content-length</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos /]<span class="hljs-comment"># curl --head --silent baidu.com | grep -i content-length</span><br>Content-Length: 81<br></code></pre></td></tr></table></figure><blockquote><p>grep 命令支持在输入流里搜索给定的关键字</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-17-centos /]<span class="hljs-comment"># curl --head --silent baidu.com | grep -i content-length | cut --delimiter=&#x27; &#x27; -f2</span><br>81<br></code></pre></td></tr></table></figure><blockquote><p>cut 命令可以接收一个分隔符delimiter，将输入流以分隔符的形式输出，-f设置输出第几个字段</p></blockquote><p>可以发现通过将命令链接起来，你可以做很多文本操作的特技</p><p>并且pipe不止用于文本数据，还可以拿来处理比如图片。当你有一个程序可以接收并处理二进制图片，然后输出一个二进制图片的时候，可以像这样把它连进去，你甚至可以这样处理视频。</p><h2 id="一个功能全面又强大的工具"><a href="#一个功能全面又强大的工具" class="headerlink" title="一个功能全面又强大的工具"></a>一个功能全面又强大的工具</h2><ul><li>root用户</li></ul><p>在linux和Mac OS中，root用户类似于Windows的管理员（Administrator），有值为0的用户ID。</p><p>root用户允许在系统上做<strong>任意行为</strong>。就算一个文件中任何人都不可读的或者任何人都不可写的，root却可以访问这个文件并且读写。多数情况下，应该使用一个普通用户来操作电脑，因为root具有风险，比如在root下运行了一个错误的程序，可能会毁掉你的整个电脑。</p><ul><li>sudo</li></ul><p>但是如果在普通用户下需要使用root权限操作时，可以使用sudo命令，这可以让你使用超级用户权限运行程序。</p><p>sudo的通常用法是，<code>sudo 需要调用的命令</code></p><p>应用场景：</p><p>在你的电脑中有很多特别的文件系统，例如sysfs。我们进入到在&#x2F;sys目录，这个文件系统不是真实存在的文件，相反，这是一堆内核参数。内核（kernel）基本上就是你电脑（操作系统）的核心。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos sys]$ <span class="hljs-built_in">ls</span><br>block  bus  class  dev  devices  firmware  fs  hypervisor  kernel  module  power<br></code></pre></td></tr></table></figure><p>通过这些像是文件系统的东西，可以访问到内核的参数。</p><p>由于这些内核参数是以文件形式展露的，我们可以使用先前的所有工具去操作它们。例如：</p><p>你可以在&#x2F;sys&#x2F;class&#x2F;backlight&#x2F;intel_backlight&#x2F;下的brightness操作背光亮度</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221223021905164.png" alt="image-20221223021905164" style="zoom:67%;" /><p>但是如果直接操作，会显示拒绝访问，因为内核的东西基本上都要root权限。</p><p>但是如果运行命令<code>sudo echo 500 &gt; brightness</code>，依然显示没有权限</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221223022224630.png" alt="image-20221223022224630" style="zoom: 67%;" /><p>因为输入输出的重定向是程序不知道的，管道和重定向都是Shell设好的，现在的情况是，我告诉Shell去运行sudo，并且包括参数echo 500 ，然后发送输出到brightness这个文件。也就是说，sudo的root权限只给了前面的echo命令。Shell打开brightness的时候，用的不是sudo，因此显示没有权限。</p><p>因此，现在的解决方法是：</p><p>方法一：切换到root终端，<code>sudo su</code></p><blockquote><p>su命令能让你以超级用户登录shell</p></blockquote><p>使用超级用户登录后，可以看到提示符从<code>$</code>变成了<code>#</code>。然后运行<code>echo 500 &gt; brightness</code>,屏幕的亮度变暗了，并且没有出现权限不足提示。因为现在Shell以root身份运行，root用户允许打开该内核文件。</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221223023516151.png" alt="image-20221223023516151" style="zoom:67%;" /><p>方法二：使用管道和重定向</p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221223024934470.png" alt="image-20221223024934470" style="zoom:67%;" /><p>Shell去运行<code>echo 1060</code>，会输出1060，然后告诉Shell去运行<code>sudo tee brightness</code>命令，然后把echo的输出送入tee的输入，然后tee打开brightness文件（tee程序以root权限运行），并将tee的输入流写入到brightness文件和标准输出流（这里是终端）</p><blockquote><p>tee命令取它的输入，然后写入到一个文件，并且写入到标准输出流</p><p>tee - read from standard input and write to standard output and files</p></blockquote><p>使用方法二可以毋需登录到root用户。</p><p>可以在其他需要root权限的地方法使用这种方法：</p><p>例如我现在想让键盘上的滚动锁定灯亮起来，该内核文件在&#x2F;sys&#x2F;class&#x2F;leds&#x2F;input1::scrolllock&#x2F;brightness</p><p>使用同样的方法，将参数由0变为1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos input1::scrolllock]$ <span class="hljs-built_in">ls</span><br>brightness  device  max_brightness  power  subsystem  trigger  uevent<br>[lighthouse@VM-8-17-centos input1::scrolllock]$ <span class="hljs-built_in">cat</span> brightness <br>0<br>[lighthouse@VM-8-17-centos input1::scrolllock]$ <span class="hljs-built_in">echo</span> 1 | <span class="hljs-built_in">tee</span> brightness <br><span class="hljs-built_in">tee</span>: brightness: Permission denied<br>1<br>[lighthouse@VM-8-17-centos input1::scrolllock]$ <span class="hljs-built_in">echo</span> 1 |sudo <span class="hljs-built_in">tee</span> brightness <br>1<br></code></pre></td></tr></table></figure><p>现在键盘上的滚动锁定灯已经亮起来了</p><ul><li>打开文件</li></ul><p>xdg-open命令，这个指令可能只在linux上运行，在Mac Os上可能叫做open</p><p>你给出一个文件名，然后xdg-open就会使用合适的程序打开它</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li><p>本课程需要使用类Unix shell，例如 Bash 或 ZSH。使用<code>echo $SHELL</code>命令可以查看您的 shell 是否满足要求。如果打印结果为<code>/bin/bash</code>或<code>/usr/bin/zsh</code>则是可以的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tmp]$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$SHELL</span><br>/bin/bash<br></code></pre></td></tr></table></figure></li><li><p>在 <code>/tmp</code> 下新建一个名为 <code>missing</code> 的文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tmp]$ <span class="hljs-built_in">mkdir</span> missing<br></code></pre></td></tr></table></figure></li><li><p>用 <code>man</code> 查看程序 <code>touch</code> 的使用手册。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tmp]$ man <span class="hljs-built_in">touch</span><br></code></pre></td></tr></table></figure></li><li><p>用 <code>touch</code> 在 <code>missing</code> 文件夹中新建一个叫 <code>semester</code> 的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tmp]$ <span class="hljs-built_in">touch</span> ./missing/semester<br></code></pre></td></tr></table></figure></li><li><p>将以下内容一行一行地写入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>curl --<span class="hljs-built_in">head</span> --silent https://missing.csail.mit.edu<br></code></pre></td></tr></table></figure><p>第一行可能有点棘手， <code>#</code> 在Bash中表示注释，而 <code>!</code> 即使被双引号（<code>&quot;</code>）包裹也具有特殊的含义。 单引号（<code>&#39;</code>）则不一样，此处利用这一点解决输入问题。更多信息请参考 <a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">Bash quoting 手册</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos missing]$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;#!/bin/sh&#x27;</span> &gt; semester <br>[lighthouse@VM-8-17-centos missing]$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;curl --head --silent https://missing.csail.mit.edu&quot;</span> &gt;&gt; semester<br>[lighthouse@VM-8-17-centos missing]$ <span class="hljs-built_in">cat</span> semester <br><span class="hljs-comment">#!/bin/sh</span><br>curl --<span class="hljs-built_in">head</span> --silent https://missing.csail.mit.edu<br></code></pre></td></tr></table></figure></li><li><p>尝试执行这个文件。例如，将该脚本的路径（<code>./semester</code>）输入到您的shell中并回车。如果程序无法执行，请使用 <code>ls</code> 命令来获取信息并理解其不能执行的原因。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos missing]$ ./semester<br>-bash: ./semester: Permission denied<br>[lighthouse@VM-8-17-centos missing]$ <span class="hljs-built_in">ls</span> -l<br>total 4<br>-rw-rw-r-- 1 lighthouse lighthouse 60 Dec 30 23:44 semester<br></code></pre></td></tr></table></figure><p>原因是没有执行x权限</p></li><li><p>查看 <code>chmod</code> 的手册(例如，使用 <code>man chmod</code> 命令)</p><p>略</p></li><li><p>使用 <code>chmod</code> 命令改变权限，使 <code>./semester</code> 能够成功执行，不要使用 <code>sh semester</code> 来执行该程序。您的 shell 是如何知晓这个文件需要使用 <code>sh</code> 来解析呢？更多信息请参考：<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos missing]$ <span class="hljs-built_in">chmod</span> 764 semester<br>[lighthouse@VM-8-17-centos missing]$ ./semester<br>HTTP/1.1 200 OK<br>Connection: keep-alive<br>Content-Length: 7991<br>Server: GitHub.com<br>Content-Type: text/html; charset=utf-8<br>Last-Modified: Mon, 05 Dec 2022 15:59:23 GMT<br>Access-Control-Allow-Origin: *<br>ETag: <span class="hljs-string">&quot;638e155b-1f37&quot;</span><br>expires: Tue, 27 Dec 2022 02:31:08 GMT<br>Cache-Control: max-age=600<br>x-proxy-cache: MISS<br>X-GitHub-Request-Id: 5400:19D5:CB919:12261D:63AA5694<br>Accept-Ranges: bytes<br>Date: Fri, 30 Dec 2022 15:59:50 GMT<br>Via: 1.1 varnish<br>Age: 0<br>X-Served-By: cache-nrt-rjtf7700066-NRT<br>X-Cache: HIT<br>X-Cache-Hits: 1<br>X-Timer: S1672415990.322601,VS0,VE211<br>Vary: Accept-Encoding<br>X-Fastly-Request-ID: b5ca5ecd45fb43becb00f6f5b089c1d56b46a765<br><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>|</code> 和 <code>&gt;</code> ，将 <code>semester</code> 文件输出的最后更改日期信息，写入主目录下的 <code>last-modified.txt</code> 的文件中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos missing]$ ./semester | grep Last &gt; ~/last-modified.txt<br>[lighthouse@VM-8-17-centos missing]$ <span class="hljs-built_in">cat</span> ~/last-modified.txt<br>Last-Modified: Mon, 05 Dec 2022 15:59:23 GMT<br></code></pre></td></tr></table></figure></li><li><p>写一段命令来从 <code>/sys</code> 中获取笔记本的电量信息，或者台式机 CPU 的温度。注意：macOS 并没有 sysfs，所以 Mac 用户可以跳过这一题。</p><p>略</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>the missing semester of cs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主题 2 Shell工具和脚本</title>
    <link href="/2023/01/12/00-15-22/"/>
    <url>/2023/01/12/00-15-22/</url>
    
    <content type="html"><![CDATA[<h1 id="主题-2-Shell工具和脚本"><a href="#主题-2-Shell工具和脚本" class="headerlink" title="主题 2 Shell工具和脚本"></a>主题 2 Shell工具和脚本</h1><p><a href="https://missing-semester-cn.github.io/2020/shell-tools/">Shell 工具和脚本 · the missing semester of your cs education (missing-semester-cn.github.io)</a></p><h2 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h2><p>shell 脚本是一种更加复杂度的工具。</p><ul><li>定义变量</li></ul><p>在bash中为变量赋值的语法是<code>foo=bar</code>，意为定义变量foo，foo的值为bar。访问变量使用$变量名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ foo=bar<br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$foo</span>&quot;</span><br>bar<br></code></pre></td></tr></table></figure><p>需要注意的是，Shell中使用空格作为分隔参数的保留字符。</p><p>如果将上诉赋值语句写为<code>foo = bar</code>，将不起作用。事实上，这样写并没有将bar赋给foo，而是用<code>=</code>和<code>bar</code>作为参数调用<code>foo</code>程序。因为这样Shell会认为你正在执行一个名为<code>foo</code>的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ foo = bar<br>-bash: foo: <span class="hljs-built_in">command</span> not found<br></code></pre></td></tr></table></figure><p>你需要特别注意这类问题，比如如果有带空格的文件名，你需要使用引号将其括起来。</p><ul><li>在bash中处理字符串</li></ul><p>有两种定义字符串的方法，可以使用双引号定义字符串，也可以使用单引号定义字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello&quot;</span><br>Hello<br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Hello&#x27;</span><br>Hello<br></code></pre></td></tr></table></figure><p>Bash中的字符串通过<code>&#39;</code> 和 <code>&quot;</code>分隔符来定义，但是它们的含义并不相同。</p><p>以<code>&#39;</code>定义的字符串为原义字符串，其中的变量不会被转义，而 <code>&quot;</code>定义的字符串会将变量值进行替换。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Value is <span class="hljs-variable">$foo</span>&quot;</span><br>Value is bar<br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Value is $foo&#x27;</span><br>Value is <span class="hljs-variable">$foo</span><br></code></pre></td></tr></table></figure><ul><li>定义函数</li></ul><p>和其他大多数的编程语言一样，<code>bash</code>也支持<code>if</code>, <code>case</code>, <code>while</code> 和 <code>for</code> 这些控制流关键字。同样地， <code>bash</code> 也支持函数，它可以接受参数并基于参数进行操作。</p><p>下面这个函数是一个例子，它会创建一个文件夹并使用<code>cd</code>进入该文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">cat</span> mcd.sh<br><span class="hljs-function"><span class="hljs-title">mcd</span></span>()&#123;<br><span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里 <code>$1</code> 是脚本的第一个参数的意思</p></blockquote><p><code>source 脚本名</code>，这将会在Shell中加载脚本并运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">source</span> mcd.sh<br>[lighthouse@VM-8-17-centos tools]$ mcd <span class="hljs-built_in">test</span><br>[lighthouse@VM-8-17-centos <span class="hljs-built_in">test</span>]$ <br></code></pre></td></tr></table></figure><p>如上，在执行了<code>source mcd.sh</code>之后，看似无事发生，但实际上Shel中已经定义了mcd函数。我们给mcd传递一个参数test，这个参数被用于作为创建的目录名（即$1），然后Shell自动切换到了test目录里。整个过程就是，我们创建了文件夹并进入其中。</p><ul><li>保留字</li></ul><p>在bash中，许多$开头的东西一般都是被保留的（指留作特定用途）</p><p> <code>$1</code> 是脚本的第一个参数的意思。与其他脚本语言不同的是，bash使用了很多特殊的变量来表示参数、错误代码和相关变量。下面列举其中一些变量，更完整的列表可以参考 <a href="https://www.tldp.org/LDP/abs/html/special-chars.html">这里</a>。</p><table><thead><tr><th>形式</th><th>释义</th></tr></thead><tbody><tr><td>$0</td><td>脚本名</td></tr><tr><td>$1~$9</td><td>脚本的参数， $1 是第一个参数，依此类推</td></tr><tr><td>$@</td><td>所有参数</td></tr><tr><td>$#</td><td>参数个数</td></tr><tr><td>$?</td><td>前一个命令的返回值</td></tr><tr><td>$$</td><td>当前脚本的进程识别码</td></tr><tr><td>!!</td><td>完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</td></tr><tr><td>$_</td><td>上一条命令的最后一个参数，如果你正在使用的是交互式 shell，你可以通过按下 <code>Esc</code> 之后键入 <code>.</code> 来获取这个值。</td></tr></tbody></table><p>有一些保留字可以直接在Shell中使用，例如<code>$?</code>可以获取上一条命令的错误代码(返回值)，再比如<code>$_</code>会返回上一条命令的最后一个参数。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">mkdir</span> <span class="hljs-built_in">test</span><br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">cd</span> <span class="hljs-variable">$_</span><br>[lighthouse@VM-8-17-centos <span class="hljs-built_in">test</span>]$ <br></code></pre></td></tr></table></figure><p>如上，我们无需在写一次<code>test</code>，使用<code>$_</code>访问该参数，它就会被替换成test，现在我们进入到test目录中了。</p><p>这样的例子有很多，再例如<code>!!</code>，它返回完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">mkdir</span> /mnt/new<br><span class="hljs-built_in">mkdir</span>: cannot create directory ‘/mnt/new’: Permission denied<br>[lighthouse@VM-8-17-centos tools]$ sudo !!<br>sudo <span class="hljs-built_in">mkdir</span> /mnt/new<br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">rmdir</span> /mnt/new<br><span class="hljs-built_in">rmdir</span>: failed to remove <span class="hljs-string">&#x27;/mnt/new&#x27;</span>: Permission denied<br>[lighthouse@VM-8-17-centos tools]$ sudo !!<br>sudo <span class="hljs-built_in">rmdir</span> /mnt/new<br>[lighthouse@VM-8-17-centos tools]$ <br></code></pre></td></tr></table></figure><ul><li>标准错误流</li></ul><p>如果你的程序出错了，你想输出错误但不想污染标准输出，那么你可以写进这个流。</p><ul><li>错误代码</li></ul><p>还有一种叫做错误代码<code>$?</code>（error code）的东西，是一种告诉你整个运行过程结果如何的方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello&quot;</span><br>Hello<br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">echo</span> $?<br>0<br></code></pre></td></tr></table></figure><p>这里显示<code>echo &quot;Hello&quot; </code>运行的错误代码为0，0是因为一切正常，没有出现问题。</p><p>这种退出码和如C语言里代表的意思一样。</p><p>0代表一切正常，没有出现错误。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ grep foobar mcd.sh<br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">echo</span> $?<br>1<br></code></pre></td></tr></table></figure><p>如上，我们尝试着在mcd.sh脚本中查找<code>foobar</code>字符串，而它不存在，所以grep什么都没输出。但是通过反馈一个1的错误代码，它让我们知道这件事没有成功。</p><p>此外，true的错误代码始终是0；false的错误代码则是1。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-literal">true</span><br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">echo</span> $?<br>0<br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-literal">false</span><br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">echo</span> $?<br>1<br></code></pre></td></tr></table></figure><ul><li>逻辑运算符</li></ul><p>下面bash要做的是执行第一个命令，如果第一个命令失败，再去执行第二个（短路运算法则）。因为它尝试做一个逻辑或，如果第一个命令没有0错误码，就会去执行第二个命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-literal">false</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Oops fail&quot;</span><br>Oops fail<br></code></pre></td></tr></table></figure><p>相似地，如果我们把false换成true，那么将不会执行第二个命令，因为第一个命令已经返回一个0错误码了，第二个命令将会被短路。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-literal">true</span> || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Oops fail&quot;</span><br>[lighthouse@VM-8-17-centos tools]$ <br></code></pre></td></tr></table></figure><p>相似的，我们使用与运算符<code>&amp;&amp;</code>，它仅当第一个命令执行无错误时，才会执行第二个部分。如果第一个命令失败，那么第二个命令就不会被执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Things went well&quot;</span><br>Things went well<br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This will not print&quot;</span><br>[lighthouse@VM-8-17-centos tools]$ <br></code></pre></td></tr></table></figure><p>使用<code>;</code>号连接的代码，无论你执行什么，都可以通过。在同一行使用分号来连接命令，如下，它始终会被打印出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-literal">false</span> ; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This will always print&quot;</span><br>This will always <span class="hljs-built_in">print</span><br></code></pre></td></tr></table></figure><ul><li>把命令的输出存到变量里</li></ul><p>这里我们获取pwd命令的输出，它会打印出我们当前的工作路径，然后把其存入foo变量中。然后我们询问变量foo的值，我们就可以看到这个字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ foo=$(<span class="hljs-built_in">pwd</span>)<br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$foo</span><br>/home/lighthouse/missing-semester/tools<br></code></pre></td></tr></table></figure><p>更广泛地来说，我们可以通过一个叫做命令替换的东西，把它放进任意字符串中。并且因为我们使用的不是单引号，所以这串东西会被展开。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;We are in <span class="hljs-subst">$(pwd)</span>&quot;</span><br>We are <span class="hljs-keyword">in</span> /home/lighthouse/missing-semester/tools<br></code></pre></td></tr></table></figure><ul><li>过程替换</li></ul><p>另一个比较好用知名度更低的东西叫做过程替换。和之前的命令替换是类似的，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">cat</span> &lt;(<span class="hljs-built_in">ls</span>) &lt;(<span class="hljs-built_in">ls</span> ..)<br>mcd.sh<br><span class="hljs-built_in">test</span><br>tools<br></code></pre></td></tr></table></figure><p>如上，<code>&lt;(ls) &lt;(ls ..)</code>的作用是，<code>()</code>内部的命令会被执行，其输出将被存储到一个临时文件内，然后把文件的标识符handle交给最左边的命令。</p><p>因此，这里我们在ls这个目录，把输出放到临时文件内，再对父目录如法炮制，然后把两个文件连接。</p><p>这种写法非常方便，因为有些命令会从某个文件的内容，而不是从标准输入里，获得输入参数</p><p>综合案例：</p><p>现在来看一个里面包含这些内容的简单示例脚本：</p><p>example.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>  <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Start program at <span class="hljs-subst">$(date)</span>&quot;</span> <span class="hljs-comment"># Date will be substituted</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Running program <span class="hljs-variable">$0</span> with <span class="hljs-variable">$#</span> arguments with pid $$&quot;</span><br><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>;<span class="hljs-keyword">do</span><br>        grep foobar <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null<br>        <span class="hljs-comment"># When pattern is not found,grep has exit status</span><br>        <span class="hljs-comment"># We redirect STDOUT and STDERR to a null register ..</span><br>        <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;$?&quot;</span> -ne 0 ]]; <span class="hljs-keyword">then</span><br>                <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;File <span class="hljs-variable">$file</span> does not have any foobar, adding one&quot;</span><br>                <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# foobar&quot;</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span><br>        <span class="hljs-keyword">fi</span>      <br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>第三行：有一个<code>$(date)</code>的参数，date打印出当前的时间。</p><p>第五行：<code>$0</code>代表着当前运行的脚本的名称，<code>$#</code>代表给定的参数个数，<code>$$</code>是这个命令的进程ID，一般缩写为PID。</p><p>第七行：<code>$@</code>可以展开成所有参数，比如有三个参数，你可以键入<code>$1 $2 $3</code>，如果你不知道有多少个参数，也可以直接键入<code>$@</code>。这里我们通过这种方式将所有参数放在这里，然后这些参数被传给for循环，for循环会创建一个<code>file</code>变量，依次地用这些参数赋值给<code>file</code>变量。</p><p>第八行：我们运行grep命令，它会在一堆文件里搜索一个子串。这里我们在文件里搜索字符串foobar，文件变量<code>file</code>将会展开为赋给它的值。</p><p>之前说过，如果我们在意程序的输出的话，我们可以把它重定向到某处（比如到一个文件里面保存下来，或者连接组合）。但有时候情况恰恰相反，例如有时候我们只想知道某个脚本的错误代码是什么，例如这里想知道grep能不能成功查找。我们并不在意程序的运行结果，因此我们甚至能直接扔掉整个输出，包括标准输出和标准错误流。这里我们做的就是把两个输出重定向到<code>/dev/null</code>，&#x2F;dev&#x2F;null是UNIX系统的一种特殊设备，输入到它的内容会被丢弃（就是说你可以随意乱写乱画，然后所有的内容都会被丢掉）。</p><p>这里的<code>&gt;</code>代表重定向输出流，<code>2&gt;</code>代表重定向标准错误流（因为这两个流是分立的，所以你要告诉bash去操作哪一个）。</p><p>所以这里我们执行命令，去检查文件有没有foobar字符串，如果有的话，返回一个0错误代码，如果没有返回一个非0错误代码。</p><p>第十一行：我们获取前一个命令的错误代码（<code>$?</code>），然后是一个比较运算符<code>-ne</code>（代表不等于Non Equal）</p><blockquote><p>其他编程序语言中有像&#x3D;和≠，bash里有很多预设的比较运算(可以使用命令<code>man test</code>查看)，这主要是为了你用Shell的时候，有很多东西要去测试。比如我们现在正在对比两个数，看它们是否相同。</p></blockquote><p>如果文件中没有foobar，前一个命令将会返回一个非零错误代码。</p><p>第十二行：我们将会如果前一个命令返回一个非0错误代码，我们将会输出一句话<code>File xxx does not have any foobar, adding one</code></p><p>第十三行：使用<code>&gt;&gt;</code>往对应文件中追加一行注释<code># foobar</code></p><p>现在我们来运行这个脚本，当前目录下有一些文件，我们将这些文件作为参数传给example.sh，检查是否有foobar。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">ls</span><br>example.sh  hello.txt  mcd.sh<br>[lighthouse@VM-8-17-centos tools]$ ./example.sh hello.txt mcd.sh<br>Start program at Sun Dec 25 23:06:13 CST 2022<br>Running program ./example.sh with 2 arguments with pid 2570038<br>File hello.txt does not have any foobar, adding one<br>File mcd.sh does not have any foobar, adding one<br></code></pre></td></tr></table></figure><p>我们在文件hello.txt和mcd.sh中没有找到foobar字符串，因此脚本分别给这两个文件添加了一个<code># foobar</code> 注释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">cat</span> hello.txt<br>hello,this is a txt file<br><span class="hljs-comment"># foobar</span><br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">cat</span> mcd.sh <br><span class="hljs-function"><span class="hljs-title">mcd</span></span>()&#123;<br><span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>&#125;<br><span class="hljs-comment"># foobar</span><br></code></pre></td></tr></table></figure><ul><li>通配符</li></ul><p>如果我们不想一个一个查找文件，可以使用通配符来进行匹配。</p><p>比如这里<code>*</code>匹配任意字符，这里将会显示出所有含有任意字符，并以<code>.sh</code>结尾的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">ls</span><br>example.sh  hello.txt  image.png  mcd.sh  project1  project2  <span class="hljs-built_in">test</span><br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">ls</span> *.sh<br>example.sh  mcd.sh<br></code></pre></td></tr></table></figure><p>现在如果我只想找有一个而不是两个特定字符的项，可以使用<code>?</code>，<code>?</code>匹配一个字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">ls</span><br>example.sh  hello.txt  image.png  mcd.sh  project1  project2  project42  <span class="hljs-built_in">test</span><br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">ls</span> project?<br>project1:<br>src<br><br>project2:<br>src<br></code></pre></td></tr></table></figure><p>现在我们得到了匹配的目录project1和project2</p><blockquote><p>src是匹配的目录下的子项</p></blockquote><p>总而言之，通配符非常强大，你也可以组合它们。</p><p>一个常用模式是花括号<code>&#123;&#125;</code>。</p><p>比如目录下有一个image.png图片，我们想转变该图像的格式，一般的做法是<code>convert image.png image.jpg</code>，但是你也可以键入<code>convert image.&#123;png,jpg&#125;</code>，它会展开成上面的那行。</p><p>又如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">touch</span> foo&#123;,1,2,10&#125;<br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">ls</span><br>example.sh  foo  foo1  foo10  foo2  hello.txt  mcd.sh project1  project2 <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>如上所述，我们可以touch一串foo，所有的foo都会被展开。</p><p>你也可以进行多层操作，建立笛卡尔系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">cat</span> &lt;(<span class="hljs-built_in">ls</span> project?/src/test)<br>project1/src/test:<br><br>project2/src/test:<br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">touch</span> project&#123;1,2&#125;/src/test/test&#123;1,2,3&#125;.py<br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">cat</span> &lt;(<span class="hljs-built_in">ls</span> project?/src/test)<br>project1/src/test:<br>test1.py<br>test2.py<br>test3.py<br><br>project2/src/test:<br>test1.py<br>test2.py<br>test3.py<br></code></pre></td></tr></table></figure><p>如上，我们在创建文件的路径上有两组花括号，这会用两组展开式形成笛卡尔积，意味着展开后所有的路径有2*3组。因此当我们运行命令<code>touch project&#123;1,2&#125;/src/test/test&#123;1,2,3&#125;.py</code>时，实际上分别在<code>./project1/src/test/</code>目录下和<code>./project2/src/test/</code>目录下创建了<code>test1.py</code>，<code>test2.py</code>，<code>test3.py</code>文件。</p><p>你也可以将<code>*</code>通配符和<code>&#123;&#125;</code>通配符结合，甚至用一些范围表示，如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">mkdir</span> foo bar<br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">touch</span> &#123;foo,bar&#125;/&#123;a..d&#125;<br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">cat</span> &lt;(<span class="hljs-built_in">ls</span> &#123;foo,bar&#125;/)<br>bar/:<br>a<br>b<br>c<br>d<br><br>foo/:<br>a<br>b<br>c<br>d<br></code></pre></td></tr></table></figure><p>如上，这将会从foo&#x2F;a一直到展开到foo&#x2F;d，而bar目录下同理。</p><ul><li>diff</li></ul><p>diff 命令用于比较文件的差异。diff 以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则 diff 会比较目录中相同文件名的文件，但不会比较其中子目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">touch</span> foo/x bar/y<br>[lighthouse@VM-8-17-centos tools]$ diff &lt;(<span class="hljs-built_in">ls</span> foo) &lt;(<span class="hljs-built_in">ls</span> bar)<br>5c5<br>&lt; x<br>---<br>&gt; y<br></code></pre></td></tr></table></figure><p>如上，x只在第一个文件夹里，而y只在第二个文件夹内。</p><ul><li>其他Shell脚本</li></ul><p>目前为止我们只看了bash脚本，如果你喜欢其他脚本（bash对一些工作可能并不是最好的选择），你可以用很多语言写和Shell工具交互的脚本。注意，脚本并不一定只有用 bash 写才能在终端里调用。比如说，这是一段 Python 脚本，作用是将输入的参数倒序输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/local/bin/python</span><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(sys.argv[<span class="hljs-number">1</span>:]):<br>    <span class="hljs-built_in">print</span>(arg)<br></code></pre></td></tr></table></figure><p>如上，python默认不会尝试和Shell交互，所以我们需要导入一些库<code>import sys</code>。第一行叫做shebang，Shell通过它了解怎么运行这个程序。</p><blockquote><p>shebang这个单词源于这行以<code>#!</code>开头，<code>#</code>是sharp，<code>!</code>是bang</p></blockquote><p>你可以随时键入类似<code>python script.py a b c</code>的命令来运行这个python脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[lighthouse@VM-8-17-centos tools]$ python script.py a b c<br>c<br>b<br>a<br></code></pre></td></tr></table></figure><p>但是如果想让它从Shell就能执行呢？这就需要用到shebang行。Shell用首行识别到需要用Python解释器运行这个程序，并且第一行给出了python解释器所在的路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ ./script.py a b c<br>c<br>b<br>a<br></code></pre></td></tr></table></figure><p>需要注意的是不同的设备很可能会把python放在不同的地方，最好不要假设文件放在固定的位置，其他的东西要是如此。</p><p> <code>shebang</code> 行中使用 <a href="https://man7.org/linux/man-pages/man1/env.1.html"><code>env</code></a> 命令，会根据给出的参数（这里是python），<code>env</code> 会利用之前的<code>PATH</code> 环境变量来进行定位，在此路径中找python二进制文件，然后用该文件去解释这个脚本。这会有更好的可移植性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(sys.argv[<span class="hljs-number">1</span>:]):<br>    <span class="hljs-built_in">print</span>(arg)<br></code></pre></td></tr></table></figure><ul><li>shellcheck</li></ul><p>编写bash脚本有时候会很别扭和反直觉。例如 <a href="https://github.com/koalaman/shellcheck">shellcheck</a> 这样的工具可以帮助你定位sh&#x2F;bash脚本中的错误。</p><blockquote><p><a href="https://github.com/koalaman/shellcheck/tree/v0.7.1#installing">koalaman&#x2F;shellcheck at v0.7.1 (github.com)</a></p></blockquote><p>shellcheck可以给出warning和语法错误提示，还能指出哪些地方你没正确引用等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ shellcheck mcd.sh<br><br>In mcd.sh line 1:<br><span class="hljs-function"><span class="hljs-title">mcd</span></span>()&#123;<br>^-- SC2148: Tips depend on target shell and yours is unknown. Add a shebang.<br><br></code></pre></td></tr></table></figure><ul><li>Shell函数和脚本的区别</li></ul><p>shell函数和脚本有如下一些不同点：</p><ol><li>函数只能与shell使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 <code>shebang</code> 是很重要的。</li><li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li><li>函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 <a href="https://man7.org/linux/man-pages/man1/export.1p.html"><code>export</code></a> 将环境变量导出，并将值传递给环境变量。</li><li>与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell脚本中往往也会包含它们自己的函数定义。</li></ol><h2 id="Shell工具"><a href="#Shell工具" class="headerlink" title="Shell工具"></a>Shell工具</h2><h3 id="查看命令如何使用"><a href="#查看命令如何使用" class="headerlink" title="查看命令如何使用"></a>查看命令如何使用</h3><ul><li>man命令</li></ul><p>给出一个命令，应该怎样了解如何使用这个命令行并找出它的不同的选项呢？最常用的方法是为对应的命令行添加<code>-h</code> 或 <code>--help</code> 标记。另外一个更详细的方法则是使用<code>man</code> 命令。<code>man</code>命令是手册（manual）的缩写，它提供了命令的用户手册。</p><p>事实上，目前我们给出的所有命令的说明链接，都是网页版的Linux命令手册，即使是安装的第三方命令。当然前提是开发者编写了手册并将其包含在了安装包中。在交互式的、基于字符处理的终端窗口中，一般也可以通过 <code>:help</code> 命令或键入 <code>?</code> 来获取帮助。</p><ul><li>tldr (too long don’t read)</li></ul><p>有时候手册内容太过详实，让我们难以在其中查找哪些最常用的标记和语法。<a href="https://tldr.sh/">TLDR pages</a>是一个很不错的替代品，它提供了一些案例，可以帮助你快速找到正确的选项。</p><blockquote><p>下载tldr：<code>npm install -g tldr</code></p><p>使用npm命令之前要先下载 <code>yum -y install npm</code></p></blockquote><h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><p>你当然可以使用ls，但是如果你想查找一个已经知道名字的文件或者目录，我们可以有更好的做法</p><ul><li>find</li></ul><blockquote><p><a href="https://blog.csdn.net/gexiaobaohelloworld/article/details/8206889">linux-find</a></p></blockquote><p>find大概是每个UNIX系统都有的工具，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ find . -name src -<span class="hljs-built_in">type</span> d<br>./project1/src<br>./project2/src<br></code></pre></td></tr></table></figure><p>这里意为，在当前文件夹<code>.</code>调用find，查找名为<code>src</code> 并且类型为目录的东西。键入以上命令，它就可以在当前目录递归查看所有符合规则的文件或者文件夹（find默认递归指定目录）。</p><p>find还有许多有用的flag，比如你甚至可以查询指定格式的文件路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ find . -path <span class="hljs-string">&#x27;**/test/*.py&#x27;</span> -<span class="hljs-built_in">type</span> f<br>./project1/src/test/test2.py<br>./project1/src/test/test1.py<br>./project1/src/test/test3.py<br>./project2/src/test/test2.py<br>./project2/src/test/test1.py<br>./project2/src/test/test3.py<br></code></pre></td></tr></table></figure><p>这里<code>**</code>是指可以匹配零或者多个目录名，然后在此路径下找到拓展名为<code>.py</code>的文件，并要求它们在一个test文件夹内，同时检查它是否为F类型（f代表文件file）</p><p>运用不用的flag，可以进行非路径和非文件名的筛选：</p><p>比如可以查找被修改过的文件，这里<code>-mtime</code>代表修改时间，<code>.</code>当前目录下，最近<code>1</code>天被修改过的东西都会被列出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ find . -mtime -1<br>.<br>./project1<br>./project1/src<br>./project1/src/test<br>./project1/src/test/test2.py<br>./project1/src/test/test1.py<br>./project1/src/test/test3.py<br>./project2<br>./project2/src<br>./project2/src/test<br>./project2/src/test/test2.py<br>./project2/src/test/test1.py<br>./project2/src/test/test3.py<br>./test<br>./mcd.sh<br></code></pre></td></tr></table></figure><p>你甚至可以使用其他条件，比如大小，所有者，权限等等。</p><p>强大的是，find不仅可以查找东西，找到之后还可以做别的：例如</p><p>我们可以在当前目录下查找所有扩展名为<code>.tmp</code>的文件，然后要求find对于所有这些文件，执行<code>rm</code>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ find . -name <span class="hljs-string">&quot;*.tmp&quot;</span><br>./project1/src/test/test3.tmp<br>./project1/src/test/test1.tmp<br>./project1/src/test/test2.tmp<br>./project2/src/test/test3.tmp<br>./project2/src/test/test1.tmp<br>./project2/src/test/test2.tmp<br>[lighthouse@VM-8-17-centos tools]$ find . -name <span class="hljs-string">&quot;*.tmp&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">rm</span> &#123;&#125; \;<br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">echo</span> $?<br>0<br>[lighthouse@VM-8-17-centos tools]$ find . -name <span class="hljs-string">&quot;*.tmp&quot;</span><br>[lighthouse@VM-8-17-centos tools]$ <br></code></pre></td></tr></table></figure><p>如上，执行<code>find . -name &quot;*.tmp&quot; -exec rm &#123;&#125; \;</code>后，对应的tmp文件都被删除了。</p><ul><li>fd</li></ul><p><a href="https://github.com/sharkdp/fd"><code>fd</code></a> 是一个更简单、更快速、更友好的程序，它可以用来作为<code>find</code>的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。以模式<code>PATTERN</code> 搜索的语法是 <code>fd PATTERN</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ fd <span class="hljs-string">&quot;.*py&quot;</span><br>project1/src/test/test1.py<br>project1/src/test/test2.py<br>project1/src/test/test3.py<br>project2/src/test/test1.py<br>project2/src/test/test2.py<br>project2/src/test/test3.py<br></code></pre></td></tr></table></figure><ul><li>locate</li></ul><p>大多数人都认为 <code>find</code> 和 <code>fd</code> 已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p><p>这就要靠 <a href="https://man7.org/linux/man-pages/man1/locate.1.html"><code>locate</code></a> 了。 <code>locate</code> 使用一个由 <a href="https://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a>负责更新的数据库，在大多数系统中 <code>updatedb</code> 都会通过 <a href="https://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a> 每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code> 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code>则只能通过文件名。 <a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">这里</a>有一个更详细的对比。</p><h3 id="查找代码"><a href="#查找代码" class="headerlink" title="查找代码"></a>查找代码</h3><p>查找文件是很有用的技能，但是很多时候你的目标其实是查看文件的内容。常见的场景是查找具有匹配某种模式的全部文件，并找它们的位置。</p><ul><li>grep</li></ul><p>grep是用于对输入文本进行匹配的通用工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ grep foobar mcd.sh <br><span class="hljs-comment"># foobar</span><br></code></pre></td></tr></table></figure><p>使用-R可以递归地搜索</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ grep -R foobar .<br>./example.sh:        grep foobar <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null<br>./example.sh:                <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;File <span class="hljs-variable">$file</span> does not have any foobar, adding one&quot;</span><br>./example.sh:                <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# foobar&quot;</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span><br>./hello.txt:<span class="hljs-comment"># foobar</span><br>./mcd.sh:<span class="hljs-comment"># foobar</span><br></code></pre></td></tr></table></figure><p><code>grep</code> 有很多选项，这也使它成为一个非常全能的工具。 <code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。但是也有很多办法可以对 <code>grep -R</code> 进行改进，例如使其忽略<code>.git</code> 文件夹，使用多CPU等等。</p><ul><li>rg（ripgrep）</li></ul><p>此外还出现了很多grep的替代品，包括 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a>。它们都特别好用，但是功能也都差不多，比较常用的是 ripgrep (<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。</p><blockquote><p><a href="https://outmanzzq.github.io/2019/11/13/ripgrep/">rg安装</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ rg <span class="hljs-string">&quot;foobar&quot;</span> -t sh ~/<br>/home/lighthouse/missing/tools/mcd.sh<br>5:<span class="hljs-comment"># foobar</span><br><br>/home/lighthouse/missing/tools/example.sh<br>8:        grep foobar <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null<br>12:                <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;File <span class="hljs-variable">$file</span> does not have any foobar, adding one&quot;</span><br>13:                <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# foobar&quot;</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span><br></code></pre></td></tr></table></figure><p>如上，该命令在<code>~/</code>目录下搜索类型(-t即type)为sh，并且文件内有“foobar”子串的文件。</p><p>rg不仅能找到对应文件，还能精确到匹配的行，比起使用grep，它还增加了代码彩色显示和文件处理啥的，也有Unicode支持，并且运行很快。</p><p>rg有许多有用的flag，比如说你想要点上下文(匹配内容的附近内容)，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ rg <span class="hljs-string">&quot;foobar&quot;</span> -t sh -C 5 ~/<br>/home/lighthouse/missing/tools/mcd.sh<br>1-<span class="hljs-function"><span class="hljs-title">mcd</span></span>()&#123;<br>2-<span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>3-<span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>4-&#125;<br>5:<span class="hljs-comment"># foobar</span><br><br>/home/lighthouse/missing/tools/example.sh<br>3-<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Start program at <span class="hljs-subst">$(date)</span>&quot;</span> <span class="hljs-comment"># Date will be substituted</span><br>4-<br>5-<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Running program <span class="hljs-variable">$0</span> with <span class="hljs-variable">$#</span> arguments with pid $$&quot;</span><br>6-<br>7-<span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>;<span class="hljs-keyword">do</span><br>8:        grep foobar <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null<br>9-        <span class="hljs-comment"># When pattern is not found,grep has exit status</span><br>10-        <span class="hljs-comment"># We redirect STDOUT and STDERR to a null register ..</span><br>11-        <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;$?&quot;</span> -ne 0 ]]; <span class="hljs-keyword">then</span><br>12:                <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;File <span class="hljs-variable">$file</span> does not have any foobar, adding one&quot;</span><br>13:                <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# foobar&quot;</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span><br>14-        <span class="hljs-keyword">fi</span>      <br>15-<span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>如上，我们加上<code>-C [num]</code>（C意为context），不仅能够搜索到匹配内容，还能对每一个匹配的内容显示其前后[num]行的内容。这样你就可以知道匹配内容大概在什么位置，它周围都是什么内容。这个功能在查找在哪调用了什么函数 上十分有用。</p><p>我们也可以使用一个更高级的用法：</p><p><code>-u</code>意为不忽略隐藏文件，<code>--files-without-match</code>是打印出所有不匹配这个pattern的内容，<code>&#39;#!&#39;</code>的意思是匹配有<code>#!</code>的内容。也就是说，我们在搜索没有shebang的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ rg -u --files-without-match <span class="hljs-string">&#x27;#!&#x27;</span> -t sh<br>mcd.sh<br></code></pre></td></tr></table></figure><p>此外rg还有些好用的flag，比如<code>--stats</code>这个flag，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ rg <span class="hljs-string">&quot;foobar&quot;</span> -t sh -C 5 --stats ~/<br>/home/lighthouse/missing/tools/mcd.sh<br>1-<span class="hljs-function"><span class="hljs-title">mcd</span></span>()&#123;<br>2-<span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>3-<span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>4-&#125;<br>5:<span class="hljs-comment"># foobar</span><br><br>/home/lighthouse/missing/tools/example.sh<br>3-<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Start program at <span class="hljs-subst">$(date)</span>&quot;</span> <span class="hljs-comment"># Date will be substituted</span><br>4-<br>5-<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Running program <span class="hljs-variable">$0</span> with <span class="hljs-variable">$#</span> arguments with pid $$&quot;</span><br>6-<br>7-<span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>;<span class="hljs-keyword">do</span><br>8:        grep foobar <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null<br>9-        <span class="hljs-comment"># When pattern is not found,grep has exit status</span><br>10-        <span class="hljs-comment"># We redirect STDOUT and STDERR to a null register ..</span><br>11-        <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;$?&quot;</span> -ne 0 ]]; <span class="hljs-keyword">then</span><br>12:                <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;File <span class="hljs-variable">$file</span> does not have any foobar, adding one&quot;</span><br>13:                <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# foobar&quot;</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span><br>14-        <span class="hljs-keyword">fi</span>      <br>15-<span class="hljs-keyword">done</span><br><br>4 matches<br>4 matched lines<br>2 files contained matches<br>5 files searched<br>643 bytes printed<br>978 bytes searched<br>0.000054 seconds spent searching<br>0.002657 seconds<br></code></pre></td></tr></table></figure><p>如上，它除了搜索结果之外，还可以输出一些信息。比如成功匹配了多少行，查找了多少行和多少文件，打印了多少byte等。</p><ul><li>ack</li></ul><p><a href="https://beyondgrep.com/">ack</a>也是grep的一个替代工具，还有<a href="https://github.com/ggreer/the_silver_searcher">ag</a> 。当然这些工具都是可以替换的，只要会使用即可。</p><h3 id="查找shell命令"><a href="#查找shell命令" class="headerlink" title="查找shell命令"></a>查找shell命令</h3><ul><li>向上箭头</li></ul><p>首先，按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。</p><p>向上箭头并不是很有效率，所以bash有一些更加简单的方法。</p><ul><li>history</li></ul><p>它会打印出你的命令历史记录，当然一般来讲这会输出非常多的记录，你可以使用管道和grep来筛选。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">history</span> | grep <span class="hljs-built_in">echo</span><br>   74  2022-12-29 01:16:27 <span class="hljs-built_in">echo</span> $?<br>  112  2022-12-29 01:45:37 <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# foobar&quot;</span> &gt;&gt; mdc.sh<br>  115  2022-12-29 01:46:01 <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;# foobar&quot;</span> &gt;&gt; mcd.sh<br>  126  2022-12-29 01:50:42 <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello,i am a txt file&quot;</span> &gt; hello.txt<br>  197  2022-12-30 01:06:13 <span class="hljs-built_in">history</span> | grep <span class="hljs-built_in">echo</span><br></code></pre></td></tr></table></figure><ul><li>Ctrl+R</li></ul><p>基本上，所有Shell都会默认把Ctrl+R这个组合键设成（按执行时间）倒叙搜索（backward search）</p><p>我们打开（按ctrl+r）倒叙搜索，然后输入<code>echo</code>，就会找到与之匹配的命令，如果我们接着按ctrl+r，就会倒着往前搜索匹配的命令，也可以重新执行命令。</p><ul><li>fzf</li></ul><p><code>Ctrl+R</code> 可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a> 使用。<code>fzf</code> 是一个通用对模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出</p><ul><li>基于历史的自动补全</li></ul><p>另外一个和历史命令相关的技巧我喜欢称之为<strong>基于历史的自动补全</strong>。 这一特性最初是由 <a href="https://fishshell.com/">fish</a> shell 创建的，它可以根据你最近使用过的开头相同的命令，动态地对当前对shell命令进行补全。这一功能在 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh</a> 中也可以使用，它可以极大的提高用户体验。</p><blockquote><p>你可以修改 shell history 的行为，例如，如果在命令的开头加上一个空格，它就不会被加进shell记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。 为此你需要在<code>.bashrc</code>中添加<code>HISTCONTROL=ignorespace</code>或者向<code>.zshrc</code> 添加 <code>setopt HIST_IGNORE_SPACE</code>。 如果你不小心忘了在前面加空格，可以通过编辑。<code>bash_history</code>或 <code>.zhistory</code> 来手动地从历史记录中移除那一项。</p></blockquote><h3 id="文件夹导航"><a href="#文件夹导航" class="headerlink" title="文件夹导航"></a>文件夹导航</h3><p>你可以使用<code>ls -R</code>递归地列出某目录下所有的文件和目录，但是这样列出的东西比较难理解。</p><ul><li>tree</li></ul><p>有一个叫<code>tree</code>的工具可以以比较友好的格式打印出目录的结构。</p><blockquote><p>centos安装：sudo yum -y install tree</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ tree /home<br>/home<br>`-- lighthouse<br>    `-- missing<br>        `-- tools<br>            |-- example.sh<br>            |-- hello.txt<br>            |-- mcd.sh<br>            |-- project1<br>            |   `-- src<br>            |       `-- <span class="hljs-built_in">test</span><br>            |           |-- test1.py<br>            |           |-- test2.py<br>            |           `-- test3.py<br>            |-- project2<br>            |   `-- src<br>            |       `-- <span class="hljs-built_in">test</span><br>            |           |-- test1.py<br>            |           |-- test2.py<br>            |           `-- test3.py<br>            `-- <span class="hljs-built_in">test</span><br><br>10 directories, 9 files<br></code></pre></td></tr></table></figure><ul><li>broot</li></ul><p>broot也是做差不多的事情，但是比起列出所有文件，它会提示[还有更多文件，未列出]。你可以输入字符，broot可以模糊匹配符合条件的文件，并进行动态显示。这样你就可以快速的选择和定位。</p><ul><li>nnn</li></ul><p>nnn 默认列出运行 nnn 的当前目录的文件和文件夹。 文件夹列在顶部，而文件列在底部。而且是一个交互性的窗口，你可以通过向左箭头返回上一级目录，通过向右箭头到达子目录。按q即可退出窗口。</p><blockquote><p>centos 安装 nnn ：sudo yum install nnn</p></blockquote><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221230014444510.png" alt="image-20221230014444510" style="zoom:60%;" /><ul><li>ranger</li></ul><p>ranger 是一个基于文本的由 Python 编写的文件管理器。不同层级的目录分别在一个面板的三列中进行展示. 可以通过快捷键, 书签, 鼠标以及历史命令在它们之间移动. 当选中文件或目录时, 会自动显示文件或目录的内容。</p><hr><p>由于本课程的目的是尽可能对你的日常习惯进行优化。因此，我们可以使用<a href="https://github.com/clvv/fasd">fasd</a>和 <a href="https://github.com/wting/autojump">autojump</a> 这两个工具来查找最常用或最近使用的文件和目录。</p><p>Fasd 基于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm">frecency </a>对文件和文件排序，也就是说它会同时针对频率（frequency）和时效（recency）进行排序。默认情况下，<code>fasd</code>使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如， 如果您经常访问<code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于 autojump，则使用<code>j cool</code>代替即可。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li><p>阅读 <a href="https://man7.org/linux/man-pages/man1/ls.1.html"><code>man ls</code></a> ，然后使用<code>ls</code> 命令进行如下操作：</p><ul><li>所有文件（包括隐藏文件）</li><li>文件打印以人类可以理解的格式输出 (例如，使用454M 而不是 454279954)</li><li>文件以最近访问顺序排序</li><li>以彩色文本显示输出结果</li></ul><p>典型输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">-rw-r--r--   1 user group 1.1M Jan 14 09:53 baz<br>drwxr-xr-x   5 user group  160 Jan 14 09:53 .<br>-rw-r--r--   1 user group  514 Jan 14 06:42 bar<br>-rw-r--r--   1 user group 106M Jan 13 12:12 foo<br>drwx------+ 47 user group 1.5K Jan 12 18:08 ..<br></code></pre></td></tr></table></figure><hr><p>练习：</p><p>(1) 显示包括隐藏文件</p><blockquote><p>-a, –all<br>             do not ignore entries starting with .</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">ls</span> -a<br>.  ..  example.sh  hello.txt  mcd.sh  project1  project2  <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>(2) 文件以人类可以理解的格式输出</p><blockquote><p>-h, –human-readable<br>              with -l, print sizes in human readable format (e.g., 1K 234M 2G)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">ls</span> -hl<br>total 24K<br>-rwxrwxr-- 1 lighthouse lighthouse  494 Dec 29 01:49 example.sh<br>-rw-rw-r-- 1 lighthouse lighthouse   31 Dec 29 01:55 hello.txt<br>-rw-rwxr-- 1 lighthouse lighthouse   42 Dec 29 01:46 mcd.sh<br>drwxrwxr-x 3 lighthouse lighthouse 4.0K Dec 29 00:47 project1<br>drwxrwxr-x 3 lighthouse lighthouse 4.0K Dec 29 00:47 project2<br>drwxrwxr-x 2 lighthouse lighthouse 4.0K Dec 29 00:55 <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>(3) 文件以最近访问顺序排序</p><blockquote><p>-t     sort by modification time, newest first</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">ls</span> -lt<br>total 24<br>-rw-rw-r-- 1 lighthouse lighthouse   31 Dec 29 01:55 hello.txt<br>-rwxrwxr-- 1 lighthouse lighthouse  494 Dec 29 01:49 example.sh<br>-rw-rwxr-- 1 lighthouse lighthouse   42 Dec 29 01:46 mcd.sh<br>drwxrwxr-x 2 lighthouse lighthouse 4096 Dec 29 00:55 <span class="hljs-built_in">test</span><br>drwxrwxr-x 3 lighthouse lighthouse 4096 Dec 29 00:47 project1<br>drwxrwxr-x 3 lighthouse lighthouse 4096 Dec 29 00:47 project2<br></code></pre></td></tr></table></figure><p>(4) 以彩色文本显示输出结果</p><blockquote><p>–color[&#x3D;WHEN]<br>             colorize the output; WHEN can be ‘never’, ‘auto’, or ‘always’ (the default); more info below</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">ls</span> --color=auto<br>example.sh  hello.txt  mcd.sh  project1  project2  <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>综合：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">ls</span> -laht --color=auto<br>total 32K<br>drwxrwxr-x 5 lighthouse lighthouse 4.0K Dec 30 01:14 .<br>-rw-rw-r-- 1 lighthouse lighthouse   31 Dec 29 01:55 hello.txt<br>-rwxrwxr-- 1 lighthouse lighthouse  494 Dec 29 01:49 example.sh<br>-rw-rwxr-- 1 lighthouse lighthouse   42 Dec 29 01:46 mcd.sh<br>drwxrwxr-x 2 lighthouse lighthouse 4.0K Dec 29 00:55 <span class="hljs-built_in">test</span><br>drwxrwxr-x 3 lighthouse lighthouse 4.0K Dec 29 00:47 project1<br>drwxrwxr-x 3 lighthouse lighthouse 4.0K Dec 29 00:47 project2<br>drwxrwxr-x 3 lighthouse lighthouse 4.0K Dec 29 00:46 ..<br></code></pre></td></tr></table></figure></li><li><p>编写两个bash函数 <code>marco</code> 和 <code>polo</code> 执行下面的操作。 每当你执行 <code>marco</code> 时，当前的工作目录应当以某种形式保存，当执行 <code>polo</code> 时，无论现在处在什么目录下，都应当 <code>cd</code> 回到当时执行 <code>marco</code> 的目录。 为了方便debug，你可以把代码写在单独的文件 <code>marco.sh</code> 中，并通过 <code>source marco.sh</code>命令，（重新）加载函数。</p><p>练习：</p><p>marco.sh:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-function"><span class="hljs-title">marco</span></span>()&#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(pwd)</span>&quot;</span> &gt; ~/pwd.txt<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">polo</span></span>()&#123;<br>jump=$(<span class="hljs-built_in">cat</span> ~/pwd.txt)<br><span class="hljs-comment"># 使用$(命令)的方式可以赋给变量</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$jump</span>&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;You had alread jump to --&gt;<span class="hljs-variable">$jump</span>&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">source</span> marco.sh<br>[lighthouse@VM-8-17-centos tools]$ marco<br>[lighthouse@VM-8-17-centos tools]$ <span class="hljs-built_in">cd</span> /<br>[lighthouse@VM-8-17-centos /]$ polo<br>You had alread jump to --&gt;/home/lighthouse/missing/tools<br>[lighthouse@VM-8-17-centos tools]$ <br></code></pre></td></tr></table></figure></li><li><p>假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段bash脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/usr/bin/env bash</span><br>   <br>n=$(( RANDOM % <span class="hljs-number">100</span> ))<br>   <br><span class="hljs-keyword">if</span> [[ n -eq 42 ]]; <span class="hljs-keyword">then</span><br>   <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Something went wrong&quot;</span><br>   &gt;&amp;2 <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;The error was using magic numbers&quot;</span><br>   <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br>   <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Everything went according to plan&quot;</span><br></code></pre></td></tr></table></figure><p>练习：</p><p>上述脚本的意思是，取一个随机数（RANDOM变量用于生成0~32767之前的任意随机数），随机数模100。如果结果等于42，就输出两句话，然后返回1退出码；否则就输出”Everything went according to plan“</p><blockquote><p>这里的<code>&gt;&amp;2</code>的意思是  将标准输出1和标准错误输出2 都重定向到终端中（标准输出或标准错误输出的目的地默认都为终端）</p><p><a href="https://www.cnblogs.com/itsharehome/p/8503206.html">Linux shell标准输入，标准输出，错误输出</a></p></blockquote><p>run.sh（buggy.sh为题目的脚本名）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">count=1<br>   <br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">do</span><br>    ./buggy.sh 1&gt;&gt; out.log 2&gt;&amp;1 <span class="hljs-comment">#把stout和sterr一起重定向到out.log文件中(追加)</span><br>    <span class="hljs-keyword">if</span> [[ $? -ne 0 ]]; <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;运行错误，记录在out.log中&quot;</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;共运行 <span class="hljs-variable">$count</span> 次&quot;</span><br>        <span class="hljs-built_in">break</span><br>    <span class="hljs-keyword">fi</span><br>    ((count++))<br>   <br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos tools]$ ./run.sh <br>运行错误，记录在out.log中<br>共运行 82 次<br>[lighthouse@VM-8-17-centos tools]$ ./run.sh <br>运行错误，记录在out.log中<br>共运行 42 次<br></code></pre></td></tr></table></figure></li><li><p>本节课我们讲解的 <code>find</code> 命令中的 <code>-exec</code> 参数非常强大，它可以对我们查找的文件进行操作。但是，如果我们要对所有文件进行操作呢？例如创建一个zip压缩文件？我们已经知道，命令行可以从参数或标准输入接受输入。在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如<code>tar</code> 则需要从参数接受输入。这里我们可以使用<a href="https://man7.org/linux/man-pages/man1/xargs.1.html"><code>xargs</code></a> 命令，它可以使用标准输入中的内容作为参数。 例如 <code>ls | xargs rm</code> 会删除当前目录中的所有文件。</p><p>您的任务是编写一个命令，它可以递归地查找文件夹中所有的HTML文件，并将它们压缩成zip文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行（提示：查看 <code>xargs</code>的参数<code>-d</code>，译注：MacOS 上的 <code>xargs</code>没有<code>-d</code>，<a href="https://github.com/missing-semester/missing-semester/issues/93">查看这个issue</a>）</p><p>如果您使用的是 MacOS，请注意默认的 BSD <code>find</code> 与 <a href="https://en.wikipedia.org/wiki/List_of_GNU_Core_Utilities_commands">GNU coreutils</a> 中的是不一样的。你可以为<code>find</code>添加<code>-print0</code>选项，并为<code>xargs</code>添加<code>-0</code>选项。作为 Mac 用户，您需要注意 mac 系统自带的命令行工具和 GNU 中对应的工具是有区别的；如果你想使用 GNU 版本的工具，也可以使用 <a href="https://formulae.brew.sh/formula/coreutils">brew 来安装</a>。</p><p>练习：</p><p>事先在当前文件夹下创建了一些html文件（包括带有空格的he llo.html）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos question4]$ tree <br>.<br>|-- he\ llo.html<br>|-- index.html<br>|-- project1<br>|   |-- <span class="hljs-built_in">test</span><br>|   |-- test1.html<br>|   |-- test2.html<br>|   `-- test3.html<br>|-- project2<br>|   |-- <span class="hljs-built_in">test</span><br>|   |-- test1.html<br>|   |-- test2.html<br>|   `-- test3.html<br>|-- test1.html<br>|-- test2.html<br>|-- test3.html<br>|-- test4.html<br>|-- test5.html<br>|-- test6.html<br>|-- test7.html<br>|-- test8.html<br>`-- test9.html<br><br>4 directories, 17 files<br></code></pre></td></tr></table></figure><p>使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos question4]$ find .  -name <span class="hljs-string">&quot;*.html&quot;</span> | xargs -d <span class="hljs-string">&#x27;\n&#x27;</span> tar -cf html.zip<br></code></pre></td></tr></table></figure><p>查看压缩包内容：</p><p>可以看到包括有空格文件名的html在内全部压缩成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos question4]$ tar -tf html.zip <br>./project1/test3.html<br>./project1/test2.html<br>./project1/test1.html<br>./test6.html<br>./test3.html<br>./test8.html<br>./test4.html<br>./test9.html<br>./project2/test3.html<br>./project2/test2.html<br>./project2/test1.html<br>./test5.html<br>./he llo.html<br>./test2.html<br>./index.html<br>./test1.html<br>./test7.html<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://zhuanlan.zhihu.com/p/141500550">xargs使用教程 </a>    <a href="https://zhuanlan.zhihu.com/p/91593509">Linux下查看压缩文件内容的 10 种方法</a></p><p>使用 <code>tar -tf</code> 命令可以在不提取 <code>tar</code> 文件的情况下查看压缩包内容。</p></blockquote></li><li><p>（进阶）编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[lighthouse@VM-8-17-centos question4]$ find . -<span class="hljs-built_in">type</span> f -mmin -120 | xargs -d <span class="hljs-string">&#x27;\n&#x27;</span>  <span class="hljs-built_in">ls</span> -tl | <span class="hljs-built_in">head</span> -3<br>-rw-rw-r-- 1 lighthouse lighthouse 10240 Jan  3 22:01 ./html.zip<br>-rw-rw-r-- 1 lighthouse lighthouse     0 Jan  3 21:36 ./he llo.html<br>-rw-rw-r-- 1 lighthouse lighthouse     0 Jan  3 21:15 ./project1/test1.html<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>the missing semester of cs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
