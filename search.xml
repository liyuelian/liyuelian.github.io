<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>主题 1 The Shell</title>
    <url>/2023/01/12/00-15-22/</url>
    <content><![CDATA[<h1 id="主题-1-The-Shell"><a href="#主题-1-The-Shell" class="headerlink" title="主题 1 The Shell"></a>主题 1 The Shell</h1><p><a href="https://missing-semester-cn.github.io/2020/course-shell/">课程概览与 shell · the missing semester of your cs education (missing-semester-cn.github.io)</a></p>
<h2 id="Shell是什么？"><a href="#Shell是什么？" class="headerlink" title="Shell是什么？"></a>Shell是什么？</h2><p>一旦你想脱离可视化界面让你做的，然后做点别的事情，那么Shell将是你和计算机交互的最主要的方式之一。</p>
<p>可视化界面受限于，它只能做被设计出来的操作——比如你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。这就是这门课介绍命令行工具和基于文本的工具的理由，shell则是你去做这些操作的地方。</p>
<p>在Windows和Linux可以找到成堆的终端（Terminal），这些是能显示Shell的文本窗口。其中普遍的是bash，或者叫Bourne Again Shell。由于bash的普遍性，这门课中将使用bash。</p>
<span id="more"></span>

<h2 id="使用Shell"><a href="#使用Shell" class="headerlink" title="使用Shell"></a>使用Shell</h2><p>终端（Terminal）是你电脑上和shell交互的主要文本界面。</p>
<p>当你打开一个终端，你通常会在终端中看到这样的一行，称为命令行提示符（Shell Prompt）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<p>它告诉你，你的主机名是<code>VM-8-17-centos</code>，你的用户名是<code>root</code>，还有你当前所在的路径为<code>~</code>（path）。</p>
<p>可以在终端上执行命令，通常是带着参数（argument）执行程序。参数一般是一些紧随程序名后面的，用空格分开的东西。</p>
<ul>
<li>date</li>
</ul>
<p>date输入当前日期和时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># date</span></span><br><span class="line">Sat Dec 17 01:04:35 CST 2022</span><br></pre></td></tr></table></figure>

<ul>
<li>echo</li>
</ul>
<p>echo打印出你传给它的参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># echo hello</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<ul>
<li>参数以空格分隔</li>
</ul>
<p>如上所说，参数是被空格分隔的，如果传递一个多单词的参数，就必须用引号括起来，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># echo &quot;Hello Wrold&quot;</span></span><br><span class="line">Hello Wrold</span><br></pre></td></tr></table></figure>

<p>这样echo程序会收到一个字符串参数<code>Hello World</code>，中间还有一个空格。此外使用单引号也是可以的。</p>
<blockquote>
<p>单双引号的区别将在bash scripting 再说</p>
</blockquote>
<p>此外也可以使用转义符将空格转义，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># echo Hello\ World</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于如何给参数，变量转义，解析和加括号将在之后涉及</p>
</blockquote>
<p>我们在创建目录或文件时，如果某个参数是带空格的，也需要使用引号转义或者用转义符将空格转义，否者shell将会将该参数识别成两个参数。</p>
<p>如下shell将<code>my photo</code>识别成两个参数，创建了两个目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># mkdir my photo</span></span><br><span class="line">[root@VM-8-17-centos ~]<span class="comment"># ls</span></span><br><span class="line">my  photo</span><br></pre></td></tr></table></figure>

<p>正确的做法为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># mkdir &quot;my photo&quot;</span></span><br><span class="line">[root@VM-8-17-centos ~]<span class="comment"># ll</span></span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x 2 root root 4096 Dec 17 01:23 <span class="string">&#x27;my photo&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="在Shell中导航"><a href="#在Shell中导航" class="headerlink" title="在Shell中导航"></a>在Shell中导航</h2><ul>
<li>环境变量</li>
</ul>
<p>你可能会好奇，当输入date或者echo等命令时，Shell怎么知道这些程序要做什么。</p>
<p>你的机器可能内嵌了终端程序，或者某些浏览器。同样的，电脑也内嵌了很多围绕终端工作的程序，这些程序位于你的文件系统（File System），Shell有办法在系统中搜索某个程序，然后执行。</p>
<p>当然，Shell不会在所有文件中进行搜索，那样效率太低了。</p>
<p>Shell借助一个叫做 <strong>环境变量（Environment Variable）</strong> 的东西来完成搜索。</p>
<blockquote>
<p>环境变量就类似编程语言中的变量，Shell或者说bash本身就是一种程序设计语言。你输入的提示符（Prompt）不仅能带参运行程序，你也可以写入while循环，for循环，条件语句等，甚至可以定义函数，甚至变量。关于Shell Scripting的下一讲会有涉及</p>
</blockquote>
<p>环境变量是Shell本就设定好的，无论何时打开shell都无需重新设置。一堆东西都会预先设置好，比如哪里是home目录，你的用户名是什么等。</p>
<ul>
<li>PATH变量</li>
</ul>
<p>如下，当我们执行<code>echo $PATH</code>时，将会输出一些电脑上的目录，这些目录就是Shell寻找程序时所查找的目录。这些目录以冒号分隔。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># echo $PATH</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure>

<p>当你输入一个程序名称时，电脑会在这个列表中的每个目录里，查找名字与你所输入的指令相同的一个程序或者文件。如果在这些目录中可以找到待运行的程序，程序可以正常运行，否则失败。</p>
<ul>
<li>which</li>
</ul>
<p>如果我们想要知道电脑具体运行了哪一个目录里的程序，可以使用which指令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># which echo</span></span><br><span class="line">/usr/bin/echo</span><br><span class="line">[root@VM-8-17-centos ~]<span class="comment"># which date</span></span><br><span class="line">/usr/bin/date</span><br></pre></td></tr></table></figure>

<ul>
<li>路径</li>
</ul>
<p>路径是用来描述你的计算机里文件位置的东西。</p>
<p>在Linux或者Mac Os上，路径被一连串的斜杠分隔，可以看到上面echo指令的路径起点在根目录<code>/</code>（&#x2F; 即整个文件系统的最顶层）</p>
<blockquote>
<p>在Windows里，路径以反斜杠\ 而非斜杠&#x2F;分隔。</p>
</blockquote>
<p>在Linux或Mac Os上，所有东西都在一个叫根（root）的空间的下面的某处。因此所有以斜杠开头&#x2F;的路径都是<strong>绝对路径</strong>。</p>
<p>而在Windows下，每一个分区都有一个根，类似于C:\或者D:\，所以Windows里每一个驱动器(硬盘)下都有独立的一套文件系统的层次结构。</p>
<blockquote>
<p>绝对路径：是可以绝对准确地确定一个文件的位置的路径</p>
<p>相对路径：是相对于你当前所在位置的路径</p>
</blockquote>
<ul>
<li>pwd</li>
</ul>
<p>打印工作目录（print working directory）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br></pre></td></tr></table></figure>

<p>你可以改变当前工作目录，所有的相对路径都是相对于当前工作目录的</p>
<ul>
<li>cd</li>
</ul>
<p>change directory 改变当前工作目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># cd /home</span></span><br><span class="line">[root@VM-8-17-centos home]<span class="comment"># pwd</span></span><br><span class="line">/home</span><br></pre></td></tr></table></figure>

<blockquote>
<p>shell提示只会给路径的最后一段名称，当然也可以通过设置是它总能显示当前的完整路径</p>
</blockquote>
<ul>
<li>特殊的目录 <code>. </code>和<code> ..</code></li>
</ul>
<p><code>.</code> 表示当前目录，<code>..</code>表示上一级（父）目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># pwd</span></span><br><span class="line">/home/lighthouse</span><br><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cd ../../..</span></span><br><span class="line">[root@VM-8-17-centos /]<span class="comment"># pwd</span></span><br><span class="line">/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用相对or绝对路径取决于哪个方便，但是如果有时候你需要运行某个程序或者写一个程序，它调用了类似echo或者date这样的程序，你希望它在哪个地方都能跑起来，要么你就只给出这个要被运行的程序的名字(让shell用path去找出它们在哪里)，要么就需要给出绝对路径</p>
<p>一般来说程序默认在当前目录运行</p>
</blockquote>
<ul>
<li>ls</li>
</ul>
<p>输入本级目录下的所有文件信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># ls</span></span><br><span class="line">bin  boot  data  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>

<p>如果给定路径参数，则会输出给定路径目录下的文件信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># ls home/lighthouse/</span></span><br><span class="line">dirdemo  hello2.txt  hello.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>特殊符号<code>-</code>和<code>~</code></li>
</ul>
<p><code>~</code>表示<strong>当前</strong>用户的home目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># cd ~</span></span><br><span class="line">[root@VM-8-17-centos ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br></pre></td></tr></table></figure>

<p>在cd命令中，<code>-</code>参数表示之前所处的工作目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># cd -</span></span><br><span class="line">/home</span><br><span class="line">[root@VM-8-17-centos home]<span class="comment"># cd -</span></span><br><span class="line">/</span><br></pre></td></tr></table></figure>

<ul>
<li>–help</li>
</ul>
<p>大多数命令都有一个 –help选项，可以帮助你了解命令的用法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># ls --help</span></span><br><span class="line">Usage: <span class="built_in">ls</span> [OPTION]... [FILE]...</span><br><span class="line">List information about the FILEs (the current directory by default).</span><br><span class="line">Sort entries alphabetically <span class="keyword">if</span> none of -cftuvSUX nor --<span class="built_in">sort</span> is specified.</span><br><span class="line"></span><br><span class="line">Mandatory arguments to long options are mandatory <span class="keyword">for</span> short options too.</span><br><span class="line">  -a, --all                  <span class="keyword">do</span> not ignore entries starting with .</span><br><span class="line">  -A, --almost-all           <span class="keyword">do</span> not list implied . and ..</span><br><span class="line">      --author               with -l, <span class="built_in">print</span> the author of each file</span><br><span class="line">  -b, --escape               <span class="built_in">print</span> C-style escapes <span class="keyword">for</span> nongraphic characters</span><br><span class="line">      --block-size=SIZE      with -l, scale sizes by SIZE when printing them;</span><br><span class="line">                               e.g., <span class="string">&#x27;--block-size=M&#x27;</span>; see SIZE format below</span><br><span class="line">  -B, --ignore-backups       <span class="keyword">do</span> not list implied entries ending with ~</span><br><span class="line">……</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>比如usage这行信息，[ ]表示这部分内容可填可不填，…表示可以填写多个option或flag</p>
<blockquote>
<p>option是有多个参数字符可以选择，flag是只有一个参数字符选择</p>
</blockquote>
<ul>
<li>权限</li>
</ul>
<p>使用ls -l 命令可以以长列表格式输出当前目录下的文件信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># ls -l</span></span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x 2 lighthouse lighthouse 4096 Dec 13 00:33 dirdemo</span><br><span class="line">-rw-r--r-- 1 root       root          6 Dec 15 19:56 hello2.txt</span><br><span class="line">-rw-rw-r-- 1 lighthouse lighthouse   52 Dec 15 19:59 hello.txt</span><br></pre></td></tr></table></figure>

<p>首先前面带着d的这行条目，代表这是一个目录，例如上面的dirdemo就是一个目录，hello2.txt和hello.txt则是文件。</p>
<p>d后面的字符<code>rwxrwxr-x</code>代表文件被授予的权限。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222225758192.png" alt="image-20221222225758192" style="zoom:67%;" />

<p>阅读这一串字符的方法如下：9个字符，每三个一组，分为三组。</p>
<p>第一组：代表权限被授予给了文件的所有者</p>
<p>第二组：代表给拥有这些文件的用户组的权限</p>
<p>第三组：代表给非所有者的其他人的权限</p>
<p>其中 <code>-</code> 表示该用户不具备相应的权限。</p>
<p>同时可以发现所有字符都是有rwx组成的，r（read）表示读取权限，w（write）表示写入权限，x（execute）表示执行权限。这三者的权限使用数字表示：4表示r，2表示w，1表示x。</p>
<p>权限对于文件和目录有不同的解释：</p>
<p>对文件而言，如果你有读取权限，可以读取文件的内容。文件的写权限就是</p>
<p>目录的读取权限可以允许你<strong>看</strong>这个文件夹中有哪些东西（列出这个目录的内容）；目录的写入权限是你能否<strong>重命名、新建或者删除</strong>里面的文件；注意如果你有目录里的文件的写入权限，却没有目录的写入权限，那你就不能删除这个文件（即使你清空了这个文件也不能删除它，因为这要目录的写入权限）；最后是目录的执行权限，通常来讲就是搜索权限。这意味着你能不能<strong>进入</strong>这个目录。</p>
<blockquote>
<p>为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限(即目录的执行权限)</p>
</blockquote>
<ul>
<li>mv</li>
</ul>
<p>它接受两个路径作为参数，第一个是原有的路径，第二个是新的路径。这意味着mv既可以让你重命名一个文件，又可以让你移动一个文件。</p>
<ul>
<li>cp</li>
</ul>
<p>copy复制，该命令可以让你复制文件，用法很类似。它也接受两个路径作为参数，复制源路径和目标路径，这些路径要是完整路径（意为着你需要明确指定文件路径，这个命令没有搜索功能）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cp hello.txt ../food.txt</span></span><br><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cd ..</span></span><br><span class="line">[root@VM-8-17-centos home]<span class="comment"># ls</span></span><br><span class="line">food.txt  lighthouse</span><br></pre></td></tr></table></figure>

<ul>
<li>rm</li>
</ul>
<p>移除（删除一个文件），你可以传递一个路径作为参数。</p>
<p>需要注意默认的移除是非递归的，也就是说你不能rm移除一个目录（因为目录中可能会有文件），你可以传递一个执行递归移除的-r 标识，它就会递归删除目录下的所有内容</p>
<ul>
<li>rmdir</li>
</ul>
<p>移除目录，同样也是非递归的，这意味着你不能使用该命令删除一个非空目录</p>
<ul>
<li>mkdir</li>
</ul>
<p>创建一个新目录</p>
<ul>
<li>man</li>
</ul>
<p>manual pages(手册&#x2F;说明书)，这个程序接受其他程序的名字作为一个参数，然后显示它的说明书。</p>
<p>和<code>程序名 --help</code>命令相似。</p>
<ul>
<li>快捷键Ctrl+L</li>
</ul>
<p>清空终端，让光标回到顶部（和clear命令相似）</p>
<h2 id="在程序间创建连接"><a href="#在程序间创建连接" class="headerlink" title="在程序间创建连接"></a>在程序间创建连接</h2><ul>
<li>流（Stream）</li>
</ul>
<p>程序有两个主要的流（stream），默认下程序会有一个输入流（input stream）和一个输出流（output stream）</p>
<ol>
<li><p>默认输入流里的内容来自你的键盘，基本上输入流是终端，无论你向终端输入什么，最后都会传到程序里。</p>
</li>
<li><p>默认的输出流（即当程序想要输出一些内容时），默认也是终端</p>
<blockquote>
<p>这也是为什么当你在终端中打入<code>echo hello</code>时，hello会直接显示在你的终端里</p>
</blockquote>
</li>
</ol>
<p>Shell提供了重定向这些流的方法，把输入和输出都改到程序员指明的地方。最直接的方式就是使用大于小于号(即所谓的尖角括号)。</p>
<ol>
<li>小于号表示重定向这个程序的输入流</li>
<li>大于号表示重定向程序的输出流</li>
</ol>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># echo hello &gt; hello.txt</span></span><br><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cat hello.txt </span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>将echo程序输出的内容hello，输入到hello.txt文件中</p>
<p>cat的作用是打印出一个文件的内容，cat同样支持流的重定向。</p>
<p>在这个例子中，Shell就会打开hello.txt，取出它的内容，设置成cat的输入，cat就会把这些内容打印到它的输出流，这里没有重定向，所以cat的输出流还是终端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cat &lt; hello.txt</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>也可以同时使用两种重定向，如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cat &lt; hello.txt &gt; hello2.txt</span></span><br><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cat hello2.txt </span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>用hello.txt的内容作为cat的输入流，然后把cat输出的所欲内容存到hello2.txt中</p>
<ul>
<li>双大于号</li>
</ul>
<p>作用是追加（append）而不是覆写（overwrite）</p>
<blockquote>
<p>追加指向文件尾继续添加内容，覆写是清空文件再写入内容</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cat &lt; hello.txt &gt; hello2.txt</span></span><br><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cat hello2.txt </span></span><br><span class="line">hello</span><br><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cat &lt; hello.txt &gt;&gt; hello2.txt</span></span><br><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cat hello2.txt </span></span><br><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<ul>
<li>管道符</li>
</ul>
<p>pipe，管道符就是一个竖线<code>|</code>。管道的意思是，取左侧程序的输出，称为右侧程序的输入。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># ls -l | tail -n3</span></span><br><span class="line">drwxrwxrwt.  10 root root  4096 Dec 22 22:03 tmp</span><br><span class="line">drwxr-xr-x.  12 root root  4096 Dec 31  2021 usr</span><br><span class="line">drwxr-xr-x.  20 root root  4096 Dec 31  2021 var</span><br></pre></td></tr></table></figure>

<p>ls的输出作为tail的输入，tail的输出则会输到终端（因为你没有重定向tail的输出）</p>
<blockquote>
<p>tail 打印它输入的最后n行</p>
</blockquote>
<p>当然也可以重定向tail的输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># ls -l | tail -n3 &gt; ls.txt</span></span><br><span class="line">[root@VM-8-17-centos /]<span class="comment"># cat ls.txt</span></span><br><span class="line">drwxrwxrwt.  10 root root  4096 Dec 22 22:03 tmp</span><br><span class="line">drwxr-xr-x.  12 root root  4096 Dec 31  2021 usr</span><br><span class="line">drwxr-xr-x.  20 root root  4096 Dec 31  2021 var</span><br></pre></td></tr></table></figure>

<p>使用管道可以构建一些复杂的命令：</p>
<p>我们可以做一些操作例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># curl --head --silent baidu.com</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu, 22 Dec 2022 16:17:30 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT</span><br><span class="line">ETag: <span class="string">&quot;51-47cf7e6ee8400&quot;</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 81</span><br><span class="line">Cache-Control: max-age=86400</span><br><span class="line">Expires: Fri, 23 Dec 2022 16:17:30 GMT</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure>

<p>这会给你访问baidu.com的时候所有的HTTP Headers</p>
<p>你可以使用管道将这些输出接到grep -i content-length</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># curl --head --silent baidu.com | grep -i content-length</span></span><br><span class="line">Content-Length: 81</span><br></pre></td></tr></table></figure>

<blockquote>
<p>grep 命令支持在输入流里搜索给定的关键字</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># curl --head --silent baidu.com | grep -i content-length | cut --delimiter=&#x27; &#x27; -f2</span></span><br><span class="line">81</span><br></pre></td></tr></table></figure>

<blockquote>
<p>cut 命令可以接收一个分隔符delimiter，将输入流以分隔符的形式输出，-f设置输出第几个字段</p>
</blockquote>
<p>可以发现通过将命令链接起来，你可以做很多文本操作的特技</p>
<p>并且pipe不止用于文本数据，还可以拿来处理比如图片。当你有一个程序可以接收并处理二进制图片，然后输出一个二进制图片的时候，可以像这样把它连进去，你甚至可以这样处理视频。</p>
<h2 id="一个功能全面又强大的工具"><a href="#一个功能全面又强大的工具" class="headerlink" title="一个功能全面又强大的工具"></a>一个功能全面又强大的工具</h2><ul>
<li>root用户</li>
</ul>
<p>在linux和Mac OS中，root用户类似于Windows的管理员（Administrator），有值为0的用户ID。</p>
<p>root用户允许在系统上做<strong>任意行为</strong>。就算一个文件中任何人都不可读的或者任何人都不可写的，root却可以访问这个文件并且读写。多数情况下，应该使用一个普通用户来操作电脑，因为root具有风险，比如在root下运行了一个错误的程序，可能会毁掉你的整个电脑。</p>
<ul>
<li>sudo</li>
</ul>
<p>但是如果在普通用户下需要使用root权限操作时，可以使用sudo命令，这可以让你使用超级用户权限运行程序。</p>
<p>sudo的通常用法是，<code>sudo 需要调用的命令</code></p>
<p>应用场景：</p>
<p>在你的电脑中有很多特别的文件系统，例如sysfs。我们进入到在&#x2F;sys目录，这个文件系统不是真实存在的文件，相反，这是一堆内核参数。内核（kernel）基本上就是你电脑（操作系统）的核心。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos sys]$ <span class="built_in">ls</span></span><br><span class="line">block  bus  class  dev  devices  firmware  fs  hypervisor  kernel  module  power</span><br></pre></td></tr></table></figure>

<p>通过这些像是文件系统的东西，可以访问到内核的参数。</p>
<p>由于这些内核参数是以文件形式展露的，我们可以使用先前的所有工具去操作它们。例如：</p>
<p>你可以在&#x2F;sys&#x2F;class&#x2F;backlight&#x2F;intel_backlight&#x2F;下的brightness操作背光亮度</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221223021905164.png" alt="image-20221223021905164" style="zoom:67%;" />

<p>但是如果直接操作，会显示拒绝访问，因为内核的东西基本上都要root权限。</p>
<p>但是如果运行命令<code>sudo echo 500 &gt; brightness</code>，依然显示没有权限</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221223022224630.png" alt="image-20221223022224630" style="zoom: 67%;" />

<p>因为输入输出的重定向是程序不知道的，管道和重定向都是Shell设好的，现在的情况是，我告诉Shell去运行sudo，并且包括参数echo 500 ，然后发送输出到brightness这个文件。也就是说，sudo的root权限只给了前面的echo命令。Shell打开brightness的时候，用的不是sudo，因此显示没有权限。</p>
<p>因此，现在的解决方法是：</p>
<p>方法一：切换到root终端，<code>sudo su</code></p>
<blockquote>
<p>su命令能让你以超级用户登录shell</p>
</blockquote>
<p>使用超级用户登录后，可以看到提示符从<code>$</code>变成了<code>#</code>。然后运行<code>echo 500 &gt; brightness</code>,屏幕的亮度变暗了，并且没有出现权限不足提示。因为现在Shell以root身份运行，root用户允许打开该内核文件。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221223023516151.png" alt="image-20221223023516151" style="zoom:67%;" />

<p>方法二：使用管道和重定向</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221223024934470.png" alt="image-20221223024934470" style="zoom:67%;" />

<p>Shell去运行<code>echo 1060</code>，会输出1060，然后告诉Shell去运行<code>sudo tee brightness</code>命令，然后把echo的输出送入tee的输入，然后tee打开brightness文件（tee程序以root权限运行），并将tee的输入流写入到brightness文件和标准输出流（这里是终端）</p>
<blockquote>
<p>tee命令取它的输入，然后写入到一个文件，并且写入到标准输出流</p>
<p>tee - read from standard input and write to standard output and files</p>
</blockquote>
<p>使用方法二可以毋需登录到root用户。</p>
<p>可以在其他需要root权限的地方法使用这种方法：</p>
<p>例如我现在想让键盘上的滚动锁定灯亮起来，该内核文件在&#x2F;sys&#x2F;class&#x2F;leds&#x2F;input1::scrolllock&#x2F;brightness</p>
<p>使用同样的方法，将参数由0变为1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos input1::scrolllock]$ <span class="built_in">ls</span></span><br><span class="line">brightness  device  max_brightness  power  subsystem  trigger  uevent</span><br><span class="line">[lighthouse@VM-8-17-centos input1::scrolllock]$ <span class="built_in">cat</span> brightness </span><br><span class="line">0</span><br><span class="line">[lighthouse@VM-8-17-centos input1::scrolllock]$ <span class="built_in">echo</span> 1 | <span class="built_in">tee</span> brightness </span><br><span class="line"><span class="built_in">tee</span>: brightness: Permission denied</span><br><span class="line">1</span><br><span class="line">[lighthouse@VM-8-17-centos input1::scrolllock]$ <span class="built_in">echo</span> 1 |sudo <span class="built_in">tee</span> brightness </span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>现在键盘上的滚动锁定灯已经亮起来了</p>
<ul>
<li>打开文件</li>
</ul>
<p>xdg-open命令，这个指令可能只在linux上运行，在Mac Os上可能叫做open</p>
<p>你给出一个文件名，然后xdg-open就会使用合适的程序打开它</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>本课程需要使用类Unix shell，例如 Bash 或 ZSH。使用<code>echo $SHELL</code>命令可以查看您的 shell 是否满足要求。如果打印结果为<code>/bin/bash</code>或<code>/usr/bin/zsh</code>则是可以的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tmp]$ <span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>/tmp</code> 下新建一个名为 <code>missing</code> 的文件夹。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tmp]$ <span class="built_in">mkdir</span> missing</span><br></pre></td></tr></table></figure>
</li>
<li><p>用 <code>man</code> 查看程序 <code>touch</code> 的使用手册。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tmp]$ man <span class="built_in">touch</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用 <code>touch</code> 在 <code>missing</code> 文件夹中新建一个叫 <code>semester</code> 的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tmp]$ <span class="built_in">touch</span> ./missing/semester</span><br></pre></td></tr></table></figure>
</li>
<li><p>将以下内容一行一行地写入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">curl --head --silent https://missing.csail.mit.edu</span><br></pre></td></tr></table></figure>

<p>第一行可能有点棘手， <code>#</code> 在Bash中表示注释，而 <code>!</code> 即使被双引号（<code>&quot;</code>）包裹也具有特殊的含义。 单引号（<code>&#39;</code>）则不一样，此处利用这一点解决输入问题。更多信息请参考 <a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">Bash quoting 手册</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos missing]$ <span class="built_in">echo</span> <span class="string">&#x27;#!/bin/sh&#x27;</span> &gt; semester </span><br><span class="line">[lighthouse@VM-8-17-centos missing]$ <span class="built_in">echo</span> <span class="string">&quot;curl --head --silent https://missing.csail.mit.edu&quot;</span> &gt;&gt; semester</span><br><span class="line">[lighthouse@VM-8-17-centos missing]$ <span class="built_in">cat</span> semester </span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">curl --<span class="built_in">head</span> --silent https://missing.csail.mit.edu</span><br></pre></td></tr></table></figure>
</li>
<li><p>尝试执行这个文件。例如，将该脚本的路径（<code>./semester</code>）输入到您的shell中并回车。如果程序无法执行，请使用 <code>ls</code> 命令来获取信息并理解其不能执行的原因。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos missing]$ ./semester</span><br><span class="line">-bash: ./semester: Permission denied</span><br><span class="line">[lighthouse@VM-8-17-centos missing]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r-- 1 lighthouse lighthouse 60 Dec 30 23:44 semester</span><br></pre></td></tr></table></figure>

<p>原因是没有执行x权限</p>
</li>
<li><p>查看 <code>chmod</code> 的手册(例如，使用 <code>man chmod</code> 命令)</p>
<p>略</p>
</li>
<li><p>使用 <code>chmod</code> 命令改变权限，使 <code>./semester</code> 能够成功执行，不要使用 <code>sh semester</code> 来执行该程序。您的 shell 是如何知晓这个文件需要使用 <code>sh</code> 来解析呢？更多信息请参考：<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos missing]$ <span class="built_in">chmod</span> 764 semester</span><br><span class="line">[lighthouse@VM-8-17-centos missing]$ ./semester</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 7991</span><br><span class="line">Server: GitHub.com</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Last-Modified: Mon, 05 Dec 2022 15:59:23 GMT</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">ETag: <span class="string">&quot;638e155b-1f37&quot;</span></span><br><span class="line">expires: Tue, 27 Dec 2022 02:31:08 GMT</span><br><span class="line">Cache-Control: max-age=600</span><br><span class="line">x-proxy-cache: MISS</span><br><span class="line">X-GitHub-Request-Id: 5400:19D5:CB919:12261D:63AA5694</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Date: Fri, 30 Dec 2022 15:59:50 GMT</span><br><span class="line">Via: 1.1 varnish</span><br><span class="line">Age: 0</span><br><span class="line">X-Served-By: cache-nrt-rjtf7700066-NRT</span><br><span class="line">X-Cache: HIT</span><br><span class="line">X-Cache-Hits: 1</span><br><span class="line">X-Timer: S1672415990.322601,VS0,VE211</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Fastly-Request-ID: b5ca5ecd45fb43becb00f6f5b089c1d56b46a765</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>|</code> 和 <code>&gt;</code> ，将 <code>semester</code> 文件输出的最后更改日期信息，写入主目录下的 <code>last-modified.txt</code> 的文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos missing]$ ./semester | grep Last &gt; ~/last-modified.txt</span><br><span class="line">[lighthouse@VM-8-17-centos missing]$ <span class="built_in">cat</span> ~/last-modified.txt</span><br><span class="line">Last-Modified: Mon, 05 Dec 2022 15:59:23 GMT</span><br></pre></td></tr></table></figure>
</li>
<li><p>写一段命令来从 <code>/sys</code> 中获取笔记本的电量信息，或者台式机 CPU 的温度。注意：macOS 并没有 sysfs，所以 Mac 用户可以跳过这一题。</p>
<p>略</p>
</li>
</ol>
]]></content>
      <categories>
        <category>the missing semester of cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>HelloWorld!</title>
    <url>/2023/01/12/22-29-15/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>主题 3 编辑器(Vim)</title>
    <url>/2023/01/12/00-15-22/</url>
    <content><![CDATA[<h1 id="主题-3-编辑器-Vim"><a href="#主题-3-编辑器-Vim" class="headerlink" title="主题 3 编辑器(Vim)"></a>主题 3 编辑器(Vim)</h1><p><a href="https://missing-semester-cn.github.io/2020/editors/">编辑器 (Vim) · the missing semester of your cs education (missing-semester-cn.github.io)</a></p>
<p>代码编辑器和和其他的编辑器（比如用来写文章的编辑器）有一些不同。</p>
<p>这是因为写程序和写文章不同。当你写程序时，会花大量时间来阅读你写的东西，或者来移动光标，做一些小小的修改；而不是像写文章的时候，从上到下一气呵成。因此，对于不同的用途，我们会使用不同的编辑器，这是很合理的。</p>
<h2 id="1-该学哪个编辑器"><a href="#1-该学哪个编辑器" class="headerlink" title="1.该学哪个编辑器?"></a>1.该学哪个编辑器?</h2><span id="more"></span>

<p><a href="https://insights.stackoverflow.com/survey/2019/#development-environments-and-tools">Stack Overflow 的调查</a>显示，VS Code是目前最流行的代码编辑器。而 <a href="https://www.vim.org/">Vim</a> 则是最流行的基于命令行的编辑器。就算最终你没有打算长期使用Vim，我们仍然认为学习Vim背后的思想很有价值。</p>
<p>另外，许多工具也觉得vim哲学很棒，从而提供了Vim模式。例如当前最热门的VS Code，支持Vim键位绑定，该插件已经被下载了数百万次。</p>
<h2 id="2-Vim的哲学"><a href="#2-Vim的哲学" class="headerlink" title="2.Vim的哲学"></a>2.Vim的哲学</h2><p>Vim是一个基于模式（Modal）的编辑器，这意味着Vim有多个模式。</p>
<blockquote>
<p>Modal这个词源于Mode</p>
</blockquote>
<p>多模式的思想源于，当你在写程序的时候会经常做不同的事情。</p>
<p>在编程的时候，你会把大量时间花在阅读&#x2F;编辑而不是在写代码上。所以，Vim 是一个<strong>多模态</strong>编辑器：它对于插入文字和操纵文字有不同的模式。Vim 是可编程的（可以使用 Vimscript 或者像 Python 一样的其他程序语言），Vim 的接口本身也是一个程序语言：键入操作（以及其助记名） 是命令，这些命令也是可组合的。Vim 避免了使用鼠标，因为那样太慢了；Vim 甚至避免用上下左右键因为那样需要太多的手指移动。</p>
<p>这样的设计哲学使得 Vim 成为了一个能跟上你思维速度的编辑器。</p>
<h2 id="3-编辑模式"><a href="#3-编辑模式" class="headerlink" title="3.编辑模式"></a>3.编辑模式</h2><ul>
<li><p><strong>正常模式</strong>：Normal，在文件中四处移动光标进行修改</p>
</li>
<li><p><strong>插入模式</strong>：Insert，插入文本</p>
</li>
<li><p><strong>替换模式</strong>：replace，替换文本</p>
</li>
<li><p><strong>可视化模式</strong>（一般，行，块）：Visual，Visual Line，Visual Block，选中文本块</p>
</li>
<li><p><strong>命令行模式</strong>：Command Line，用于执行命令</p>
</li>
<li><p>Normal-正常模式 &amp; Insert-插入模式</p>
</li>
</ul>
<p>当你开始使用Vim时，它会在<code>Normal</code>模式下启动。在这个模式下，各种键位组合拥有在这个模式下的特定意义。其中就有一些按键组合来切换到其他的模式。而切换后这些键位组合和意义也相应改变。</p>
<p>你的大部分时间都会在<code>Insert</code>和<code>Normal</code>模式下，在Normal模式下按下<code>i</code>键就可以进入Insert模式。而在Insert模式下按下<code>Esc</code>就可以回到Normal模式。</p>
<blockquote>
<p>这里注意一下我们表示按键的方式，这个表示方式将会用于笔记以及Vim给你的提示中：当仅仅是代表<code>i</code>键这样一个按键本身时，那么就会直接写<code>i</code>。但是对于如Ctrl+v这种按键组合，就有可能以这么几种形式来体现：</p>
<p>第一种是一个脱字符号后跟着控制用字符：<code>^v</code>（这里控制用字符指v，也就是组合键中的另一个键），另一种写法可能是你最熟悉的：<code>Ctrl-v</code>，而有的地方我们可能会写成：<code>&lt;c-v&gt;</code></p>
</blockquote>
<p>Vim有好几种模式，而Normal模式是用来移动光标、阅读东西，以及在文件间切换的。而Insert模式是用来输入的，因此在Insert模式下，你的按键大多会直接进入buffer（缓冲区），而在Normal模式下则不然，它们不会进入buffer，而是用来进行了一些浏览和编辑操作。</p>
<blockquote>
<p><a href="https://joshldavis.com/2014/04/05/vim-tab-madness-buffers-vs-tabs/">Vim Tab Madness. Buffers vs Tabs</a>	<a href="https://blog.csdn.net/jy692405180/article/details/79775125">如何理解并正确使用 Vim 中的 Buffer ,  Window 和 Tab</a>  </p>
</blockquote>
<ul>
<li>replace-替换模式</li>
</ul>
<p>不像插入模式那样会把字符往后移，替换模式会直接覆盖掉文本。</p>
<ul>
<li>可视化模式（一般，行，块）</li>
</ul>
<p>可视化模式有Visual 模式，Visual Line模式，以及一个Visual Block模式。</p>
<hr>
<ul>
<li>各种模式的切换</li>
</ul>
<p>你可以按下 <code>&lt;ESC&gt;</code>（退出键）从任何其他模式返回正常模式。在正常模式，键入 <code>i</code> 进入插入 模式，<code>R</code> 进入替换模式，<code>v</code> 进入可视（一般）模式，<code>shift+V</code> 进入可视（行）模式，<code>&lt;C-v&gt;</code> （Ctrl-V, 有时也写作 <code>^V</code>）进入可视（块）模式，<code>:</code> 进入命令模式。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230106005400023.png" alt="image-20230106005400023" style="zoom:60%;" />

<ul>
<li>映射Esc键</li>
</ul>
<p>从非Normal模式切换到Normal模式下都是按<code>Esc</code>键，因此使用Vim时要频繁按<code>Esc</code>键。但这个键在键盘的角落里，按起来很不方便，所以很多人会将键盘上某个键映射成Esc。通常这个键是<code>Caps Lock</code>，因为它在键盘的中间一行上。</p>
<h2 id="4-基本操作"><a href="#4-基本操作" class="headerlink" title="4.基本操作"></a>4.基本操作</h2><ul>
<li>如何打开Vim程序</li>
</ul>
<p>Vim是一个基于命令行的编辑器，我们要打开Vim，只需要在命令行中键入<code>vim</code>。vim也可以接收参数，当我们想用它直接编辑特定的文件时，可以在vim 后面加上文件的路径+文件名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos vim]$ <span class="built_in">ls</span></span><br><span class="line">poem.md</span><br><span class="line">[lighthouse@VM-8-17-centos vim]$ vim poem.md </span><br></pre></td></tr></table></figure>

<h3 id="4-1插入文本"><a href="#4-1插入文本" class="headerlink" title="4.1插入文本"></a>4.1插入文本</h3><h3 id="4-2缓存，标签页，窗口"><a href="#4-2缓存，标签页，窗口" class="headerlink" title="4.2缓存，标签页，窗口"></a>4.2缓存，标签页，窗口</h3><h3 id="4-3命令行"><a href="#4-3命令行" class="headerlink" title="4.3命令行"></a>4.3命令行</h3><h2 id="5-Vim的接口其实是一种编程语言"><a href="#5-Vim的接口其实是一种编程语言" class="headerlink" title="5.Vim的接口其实是一种编程语言"></a>5.Vim的接口其实是一种编程语言</h2><h3 id="5-1移动"><a href="#5-1移动" class="headerlink" title="5.1移动"></a>5.1移动</h3><h3 id="5-2选择"><a href="#5-2选择" class="headerlink" title="5.2选择"></a>5.2选择</h3><h3 id="5-3编辑"><a href="#5-3编辑" class="headerlink" title="5.3编辑"></a>5.3编辑</h3><h3 id="5-4计数"><a href="#5-4计数" class="headerlink" title="5.4计数"></a>5.4计数</h3><h3 id="5-5修饰语"><a href="#5-5修饰语" class="headerlink" title="5.5修饰语"></a>5.5修饰语</h3><h2 id="6-演示"><a href="#6-演示" class="headerlink" title="6.演示"></a>6.演示</h2><h2 id="7-自定义Vim"><a href="#7-自定义Vim" class="headerlink" title="7.自定义Vim"></a>7.自定义Vim</h2><h2 id="8-扩展Vim"><a href="#8-扩展Vim" class="headerlink" title="8.扩展Vim"></a>8.扩展Vim</h2><h2 id="9-其他程序的Vim模式"><a href="#9-其他程序的Vim模式" class="headerlink" title="9.其他程序的Vim模式"></a>9.其他程序的Vim模式</h2><h2 id="10-Vim-进阶"><a href="#10-Vim-进阶" class="headerlink" title="10.Vim 进阶"></a>10.Vim 进阶</h2><h2 id="11-拓展资料"><a href="#11-拓展资料" class="headerlink" title="11.拓展资料"></a>11.拓展资料</h2><h2 id="12-课后练习"><a href="#12-课后练习" class="headerlink" title="12.课后练习"></a>12.课后练习</h2>]]></content>
      <categories>
        <category>the missing semester of cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客搭建记录</title>
    <url>/2023/01/12/22-36-04/</url>
    <content><![CDATA[<h1 id="Hexo博客搭建记录"><a href="#Hexo博客搭建记录" class="headerlink" title="Hexo博客搭建记录"></a>Hexo博客搭建记录</h1><blockquote>
<p>参考视频：<a href="https://www.bilibili.com/video/av44544186/?vd_source=7e137c3a1559f85aacb1f151bb0a830d">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程</a></p>
<p>以下命令操作建议使用管理员权限完成</p>
</blockquote>
<h2 id="1-nodejs-amp-hexo-安装"><a href="#1-nodejs-amp-hexo-安装" class="headerlink" title="1. nodejs &amp; hexo 安装"></a>1. nodejs &amp; hexo 安装</h2><p>1.首先下载node.js，并安装（安装node时，会自动安装npm），安装完毕后在控制台输入<code>node -v</code>，如果显示版本则说明安装成功。</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\&gt;node -v</span><br><span class="line">v16.18.1</span><br><span class="line"></span><br><span class="line">D:\&gt;npm -v</span><br><span class="line">8.19.2</span><br></pre></td></tr></table></figure>

<p>2.安装cnpm，命令为<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
<p>（因为这里我已经下过了，所以显示可能不准确）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">npm WARN deprecated @npmcli/move-file@2.0.1: This functionality has been moved to @npmcli/fs</span><br><span class="line"></span><br><span class="line">added 4 packages, removed 6 packages, and changed 415 packages <span class="keyword">in</span> 1m</span><br><span class="line"></span><br><span class="line">11 packages are looking <span class="keyword">for</span> funding</span><br><span class="line">  run `npm fund` <span class="keyword">for</span> details</span><br></pre></td></tr></table></figure>

<p>输入<code>cnpm -v</code>，如果出现下面的字样说明安装cnpm成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\&gt;cnpm -v</span><br><span class="line">cnpm@9.0.1 (D:\apps\nodejs16.18.1\node_global\node_modules\cnpm\lib\parse_argv.js)</span><br><span class="line">npm@8.19.3 (D:\apps\nodejs16.18.1\node_global\node_modules\cnpm\node_modules\npm\index.js)</span><br><span class="line">node@16.18.1 (D:\apps\nodejs16.18.1\node.exe)</span><br><span class="line">npminstall@7.3.1 (D:\apps\nodejs16.18.1\node_global\node_modules\cnpm\node_modules\npminstall\lib\index.js)</span><br><span class="line">prefix=D:\apps\nodejs16.18.1\node_global</span><br><span class="line">win32 x64 10.0.19044</span><br><span class="line">registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>

<p>3.使用cnpm安装hexo，命令<code>cnpm install -g hexo-cli</code>，安装完毕后使用命令<code>hexo -v</code>，如果出现以下字样说明安装hexo成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\&gt;hexo -v</span><br><span class="line">hexo-cli: 4.3.0</span><br><span class="line">os: win32 10.0.19044</span><br><span class="line">node: 16.18.1</span><br><span class="line">v8: 9.4.146.26-node.22</span><br><span class="line">uv: 1.43.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.9</span><br><span class="line">ares: 1.18.1</span><br><span class="line">modules: 93</span><br><span class="line">nghttp2: 1.47.0</span><br><span class="line">napi: 8</span><br><span class="line">llhttp: 6.0.10</span><br><span class="line">openssl: 1.1.1q+quic</span><br><span class="line">cldr: 41.0</span><br><span class="line">icu: 71.1</span><br><span class="line">tz: 2022b</span><br><span class="line">unicode: 14.0</span><br><span class="line">ngtcp2: 0.8.1</span><br><span class="line">nghttp3: 0.7.0</span><br></pre></td></tr></table></figure>

<h2 id="2-使用hexo搭建博客"><a href="#2-使用hexo搭建博客" class="headerlink" title="2.使用hexo搭建博客"></a>2.使用hexo搭建博客</h2><p>1.首先使用命令<code>hexo init &lt;yourBlogName&gt;</code>：创建你的站点目录，并使用hexo初始化该文件夹</p>
<blockquote>
<p>如果在搭建博客的过程中有问题，只要把文件夹删掉重来即可</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\&gt;hexo init blog</span><br><span class="line">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class="line">INFO  Install dependencies</span><br><span class="line">INFO  Start blogging with Hexo!</span><br></pre></td></tr></table></figure>

<p>初始化成功后，站点目录下生成的文件：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112003332202.png" alt="image-20230112003332202" style="zoom:67%;" />

<p>2.使用命令<code>hexo s</code>，启动博客（注意要之前的目录下运行），博客在本地的4000端口启动，访问<a href="http://localhost:4000/">http://localhost:4000/</a> 即可以看到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\blog&gt;hexo s</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112004204737.png" alt="image-20230112004204737" style="zoom:50%;" />

<p>3.使用命令<code>hexo n &quot;文章名&quot;</code>，创建博客文章。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\blog&gt;hexo n <span class="string">&quot;我的第一篇博客文章&quot;</span></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Created: D:\blog\<span class="built_in">source</span>\_posts\我的第一篇博客文章.md</span><br></pre></td></tr></table></figure>

<p>进入对应的目录下，可以看到已经成功生成文件，然后就可以在文件中写博客了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\blog&gt;<span class="built_in">cd</span> D:\blog\<span class="built_in">source</span>\_posts\</span><br><span class="line">D:\blog\<span class="built_in">source</span>\_posts&gt;<span class="built_in">dir</span></span><br><span class="line"> 驱动器 D 中的卷是 Data</span><br><span class="line"> 卷的序列号是 8A15-B825</span><br><span class="line"></span><br><span class="line"> D:\blog\<span class="built_in">source</span>\_posts 的目录</span><br><span class="line"></span><br><span class="line">2023/01/12  00:48    &lt;DIR&gt;          .</span><br><span class="line">2023/01/12  00:48    &lt;DIR&gt;          ..</span><br><span class="line">2023/01/12  00:08               876 hello-world.md</span><br><span class="line">2023/01/12  00:48                75 我的第一篇博客文章.md</span><br><span class="line">               2 个文件            951 字节</span><br><span class="line">               2 个目录 1,724,429,172,736 可用字节</span><br></pre></td></tr></table></figure>

<p>4.返回博客目录，使用命令<code>hexo clean</code>清理一下缓存文件，使用命令<code>hexo g</code>在hexo站点根目录下生成public文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\blog\<span class="built_in">source</span>\_posts&gt;<span class="built_in">cd</span> ../..</span><br><span class="line"></span><br><span class="line">D:\blog&gt;hexo clean</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Deleted database.</span><br><span class="line"></span><br><span class="line">D:\blog&gt;hexo g</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded <span class="keyword">in</span> 157 ms</span><br><span class="line">INFO  Generated: archives/index.html</span><br><span class="line">INFO  Generated: index.html</span><br><span class="line">INFO  Generated: tags/杂记/index.html</span><br><span class="line">INFO  Generated: archives/2023/01/index.html</span><br><span class="line">INFO  Generated: js/jquery-3.4.1.min.js</span><br><span class="line">INFO  Generated: fancybox/jquery.fancybox.min.css</span><br><span class="line">INFO  Generated: css/fonts/fontawesome-webfont.woff</span><br><span class="line">INFO  Generated: fancybox/jquery.fancybox.min.js</span><br><span class="line">INFO  Generated: archives/2023/index.html</span><br><span class="line">INFO  Generated: js/script.js</span><br><span class="line">INFO  Generated: css/style.css</span><br><span class="line">INFO  Generated: css/fonts/fontawesome-webfont.ttf</span><br><span class="line">INFO  Generated: css/images/banner.jpg</span><br><span class="line">INFO  Generated: css/fonts/fontawesome-webfont.eot</span><br><span class="line">INFO  Generated: css/fonts/FontAwesome.otf</span><br><span class="line">INFO  Generated: css/fonts/fontawesome-webfont.woff2</span><br><span class="line">INFO  Generated: 2023/01/12/hello-world/index.html</span><br><span class="line">INFO  Generated: 2023/01/12/我的第一篇博客文章/index.html</span><br><span class="line">INFO  Generated: css/fonts/fontawesome-webfont.svg</span><br><span class="line">INFO  19 files generated <span class="keyword">in</span> 360 ms</span><br><span class="line"></span><br><span class="line">D:\blog&gt;</span><br></pre></td></tr></table></figure>

<p>5.然后重新启动服务，浏览器访问端口，成功生成新的文章。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112010050731.png" alt="image-20230112010050731" style="zoom:67%;" />

<h2 id="3-将博客部署到github"><a href="#3-将博客部署到github" class="headerlink" title="3.将博客部署到github"></a>3.将博客部署到github</h2><p>1.登录github，创建新仓库，仓库名必须如下：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112010910756.png" alt="image-20230112010910756" style="zoom:67%;" />

<p>其他选项默认，然后点击创建仓库。</p>
<p>2.使用命令<code>npm install hexo-deployer-git --save</code>，安装git。</p>
<p>注意设置用户名和邮件：(随意)</p>
<p><code>git config --global user.name &lt;你的用户名&gt;</code><br><code>git config --global user.email &lt;你的邮箱&gt;</code></p>
<p>3.在hexo博客目录下的 _config.yml 文件，最后几行改为如下形式，然后保存。</p>
<blockquote>
<p>注意：每个冒号后面要加空格</p>
</blockquote>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112012113713.png" alt="image-20230112012113713" style="zoom:67%;" />

<p>4.使用命令<code>hexo d</code>，将博客部署到github中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\blog&gt;hexo d</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Setting up Git deployment...</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> D:/blog/.deploy_git/.git/</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Enumerating objects: 39, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (39/39), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (29/29), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (39/39), 886.59 KiB | 1.82 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 39 (delta 5), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">To github.com:liyuelian/liyuelian.github.io.git</span><br><span class="line"> * [new branch]      HEAD -&gt; master</span><br><span class="line">branch <span class="string">&#x27;master&#x27;</span> <span class="built_in">set</span> up to track <span class="string">&#x27;git@github.com:liyuelian/liyuelian.github.io.git/master&#x27;</span>.</span><br><span class="line">INFO  Deploy <span class="keyword">done</span>: git</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里没有设置ssh免密登录的要输入github账号密码</p>
</blockquote>
<p>5.在github仓库刷新，可以看到所有hexo文件已经上传到仓库中。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112013058368.png" alt="image-20230112013058368" style="zoom:67%;" />

<p>6.在地址栏中访问<code>&lt;你的github用户名&gt;.github.io</code>，即可看到个人博客网站。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112013505644.png" alt="image-20230112013505644" style="zoom:67%;" />

<h2 id="4-如何发布新文章"><a href="#4-如何发布新文章" class="headerlink" title="4.如何发布新文章"></a>4.如何发布新文章</h2><blockquote>
<p>参考：<a href="https://cloud.tencent.com/developer/article/1662733">Hexo博客教程（二）| 如何写作新文章并发布</a></p>
</blockquote>
<p>1.首先使用命令<code>hexo new &lt;title&gt;</code>创建新文章，然后到hexo目录&#x2F;source&#x2F;_posts下去编写文章。</p>
<p>使用该命令创建的md文件头会有一个前置信息Front-matter，用于给hexo渲染md文档。</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">title</td>
<td align="left">文章标题</td>
</tr>
<tr>
<td align="left">date</td>
<td align="left">文章创建日期</td>
</tr>
<tr>
<td align="left">comments</td>
<td align="left">是否启动文章评论功能</td>
</tr>
<tr>
<td align="left">tags</td>
<td align="left">文章标签</td>
</tr>
<tr>
<td align="left">categories</td>
<td align="left">文章分类</td>
</tr>
<tr>
<td align="left">keywords</td>
<td align="left">文章关键字</td>
</tr>
</tbody></table>
<p>2.使用命令<code>hexo clean</code>，清除掉旧的数据</p>
<blockquote>
<p>这个命令会清除掉之前生成的网页，即站点根目录下的<code>public</code>文件夹。</p>
</blockquote>
<p>3.使用命令<code>hexo g</code></p>
<blockquote>
<p>这个命令会将<code>source</code>文件夹下所有的md文件进行渲染，生成HTML页面，存放在<code>public</code>文件夹下。</p>
</blockquote>
<p>特别提醒！ 每次修改文章后，都要执行这两条命令，清除掉旧的数据，然后重新生成页面。</p>
<p>4.使用命令<code>hexo d</code>，将文件上传到你的远程仓库中即可。</p>
<blockquote>
<p>可以先使用hexo s，先在本地预览一下</p>
</blockquote>
<h2 id="5-如何更换博客主题"><a href="#5-如何更换博客主题" class="headerlink" title="5.如何更换博客主题"></a>5.如何更换博客主题</h2><blockquote>
<p>以yilia主题为例：<a href="https://github.com/litten/hexo-theme-yilia">litten&#x2F;hexo-theme-yilia: A simple and elegant theme for hexo. (github.com)</a></p>
</blockquote>
<p>1.在你的hexo目录下运行：<code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\blog&gt;git <span class="built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br><span class="line">Cloning into <span class="string">&#x27;themes/yilia&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 2037, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (1/1), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 2037 (delta 0), reused 0 (delta 0), pack-reused 2036</span><br><span class="line">Receiving objects: 100% (2037/2037), 10.53 MiB | 398.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line">Resolving deltas: 100% (1079/1079), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112020544576.png" alt="image-20230112020544576" style="zoom:67%;" />

<p>2.在_config.yml文件中修改主题，保存。</p>
<blockquote>
<p>注意冒号后面有空格</p>
</blockquote>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112020815301.png" alt="image-20230112020815301" style="zoom:67%;" />

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112020902973.png" alt="image-20230112020902973" style="zoom:67%;" />

<p>3.在hexo目录下使用<code>hexo clean</code>，然后使用<code>hexo g</code>重新生成public文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\blog&gt;hexo clean</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Deleted database.</span><br><span class="line">INFO  Deleted public folder.</span><br><span class="line"></span><br><span class="line">D:\blog&gt;hexo g</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded <span class="keyword">in</span> 285 ms</span><br><span class="line">...</span><br><span class="line">INFO  20 files generated <span class="keyword">in</span> 64 ms</span><br></pre></td></tr></table></figure>

<p>4.使用<code>hexo s</code>在本地启动，预览一下</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112021746933.png" alt="image-20230112021746933" style="zoom:67%;" />

<p>5.觉得没问题了，就在hexo目录下使用<code>hexo d</code>，将新的博客文件发布到你的远程仓库中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\blog&gt;hexo d</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Deploying: git</span><br><span class="line">...</span><br><span class="line">INFO  Deploy <span class="keyword">done</span>: git</span><br></pre></td></tr></table></figure>

<p>然后在你的&lt;github个人用户名&gt;.github.io上就可以看到新的博客主题了</p>
<blockquote>
<p>有时候会延迟一会才能更新</p>
</blockquote>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>主题 2 Shell工具和脚本</title>
    <url>/2023/01/12/00-15-22/</url>
    <content><![CDATA[<h1 id="主题-2-Shell工具和脚本"><a href="#主题-2-Shell工具和脚本" class="headerlink" title="主题 2 Shell工具和脚本"></a>主题 2 Shell工具和脚本</h1><p><a href="https://missing-semester-cn.github.io/2020/shell-tools/">Shell 工具和脚本 · the missing semester of your cs education (missing-semester-cn.github.io)</a></p>
<h2 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h2><p>shell 脚本是一种更加复杂度的工具。</p>
<ul>
<li>定义变量</li>
</ul>
<p>在bash中为变量赋值的语法是<code>foo=bar</code>，意为定义变量foo，foo的值为bar。访问变量使用$变量名</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ foo=bar</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$foo</span>&quot;</span></span><br><span class="line">bar</span><br></pre></td></tr></table></figure>

<p>需要注意的是，Shell中使用空格作为分隔参数的保留字符。</p>
<p>如果将上诉赋值语句写为<code>foo = bar</code>，将不起作用。事实上，这样写并没有将bar赋给foo，而是用<code>=</code>和<code>bar</code>作为参数调用<code>foo</code>程序。因为这样Shell会认为你正在执行一个名为<code>foo</code>的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ foo = bar</span><br><span class="line">-bash: foo: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>

<p>你需要特别注意这类问题，比如如果有带空格的文件名，你需要使用引号将其括起来。</p>
<ul>
<li>在bash中处理字符串</li>
</ul>
<p>有两种定义字符串的方法，可以使用双引号定义字符串，也可以使用单引号定义字符串。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line">Hello</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>

<p>Bash中的字符串通过<code>&#39;</code> 和 <code>&quot;</code>分隔符来定义，但是它们的含义并不相同。</p>
<p>以<code>&#39;</code>定义的字符串为原义字符串，其中的变量不会被转义，而 <code>&quot;</code>定义的字符串会将变量值进行替换。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> <span class="string">&quot;Value is <span class="variable">$foo</span>&quot;</span></span><br><span class="line">Value is bar</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> <span class="string">&#x27;Value is $foo&#x27;</span></span><br><span class="line">Value is <span class="variable">$foo</span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义函数</li>
</ul>
<p>和其他大多数的编程语言一样，<code>bash</code>也支持<code>if</code>, <code>case</code>, <code>while</code> 和 <code>for</code> 这些控制流关键字。同样地， <code>bash</code> 也支持函数，它可以接受参数并基于参数进行操作。</p>
<p>下面这个函数是一个例子，它会创建一个文件夹并使用<code>cd</code>进入该文件夹。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">cat</span> mcd.sh</span><br><span class="line"><span class="function"><span class="title">mcd</span></span>()&#123;</span><br><span class="line">	<span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">	<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里 <code>$1</code> 是脚本的第一个参数的意思</p>
</blockquote>
<p><code>source 脚本名</code>，这将会在Shell中加载脚本并运行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">source</span> mcd.sh</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ mcd <span class="built_in">test</span></span><br><span class="line">[lighthouse@VM-8-17-centos <span class="built_in">test</span>]$ </span><br></pre></td></tr></table></figure>

<p>如上，在执行了<code>source mcd.sh</code>之后，看似无事发生，但实际上Shel中已经定义了mcd函数。我们给mcd传递一个参数test，这个参数被用于作为创建的目录名（即$1），然后Shell自动切换到了test目录里。整个过程就是，我们创建了文件夹并进入其中。</p>
<ul>
<li>保留字</li>
</ul>
<p>在bash中，许多$开头的东西一般都是被保留的（指留作特定用途）</p>
<p> <code>$1</code> 是脚本的第一个参数的意思。与其他脚本语言不同的是，bash使用了很多特殊的变量来表示参数、错误代码和相关变量。下面列举其中一些变量，更完整的列表可以参考 <a href="https://www.tldp.org/LDP/abs/html/special-chars.html">这里</a>。</p>
<table>
<thead>
<tr>
<th>形式</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td>$0</td>
<td>脚本名</td>
</tr>
<tr>
<td>$1~$9</td>
<td>脚本的参数， $1 是第一个参数，依此类推</td>
</tr>
<tr>
<td>$@</td>
<td>所有参数</td>
</tr>
<tr>
<td>$#</td>
<td>参数个数</td>
</tr>
<tr>
<td>$?</td>
<td>前一个命令的返回值</td>
</tr>
<tr>
<td>$$</td>
<td>当前脚本的进程识别码</td>
</tr>
<tr>
<td>!!</td>
<td>完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</td>
</tr>
<tr>
<td>$_</td>
<td>上一条命令的最后一个参数，如果你正在使用的是交互式 shell，你可以通过按下 <code>Esc</code> 之后键入 <code>.</code> 来获取这个值。</td>
</tr>
</tbody></table>
<p>有一些保留字可以直接在Shell中使用，例如<code>$?</code>可以获取上一条命令的错误代码(返回值)，再比如<code>$_</code>会返回上一条命令的最后一个参数。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">mkdir</span> <span class="built_in">test</span></span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">cd</span> <span class="variable">$_</span></span><br><span class="line">[lighthouse@VM-8-17-centos <span class="built_in">test</span>]$ </span><br></pre></td></tr></table></figure>

<p>如上，我们无需在写一次<code>test</code>，使用<code>$_</code>访问该参数，它就会被替换成test，现在我们进入到test目录中了。</p>
<p>这样的例子有很多，再例如<code>!!</code>，它返回完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">mkdir</span> /mnt/new</span><br><span class="line"><span class="built_in">mkdir</span>: cannot create directory ‘/mnt/new’: Permission denied</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ sudo !!</span><br><span class="line">sudo <span class="built_in">mkdir</span> /mnt/new</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">rmdir</span> /mnt/new</span><br><span class="line"><span class="built_in">rmdir</span>: failed to remove <span class="string">&#x27;/mnt/new&#x27;</span>: Permission denied</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ sudo !!</span><br><span class="line">sudo <span class="built_in">rmdir</span> /mnt/new</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ </span><br></pre></td></tr></table></figure>

<ul>
<li>标准错误流</li>
</ul>
<p>如果你的程序出错了，你想输出错误但不想污染标准输出，那么你可以写进这个流。</p>
<ul>
<li>错误代码</li>
</ul>
<p>还有一种叫做错误代码<code>$?</code>（error code）的东西，是一种告诉你整个运行过程结果如何的方式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line">Hello</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>这里显示<code>echo &quot;Hello&quot; </code>运行的错误代码为0，0是因为一切正常，没有出现问题。</p>
<p>这种退出码和如C语言里代表的意思一样。</p>
<p>0代表一切正常，没有出现错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ grep foobar mcd.sh</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>如上，我们尝试着在mcd.sh脚本中查找<code>foobar</code>字符串，而它不存在，所以grep什么都没输出。但是通过反馈一个1的错误代码，它让我们知道这件事没有成功。</p>
<p>此外，true的错误代码始终是0；false的错误代码则是1。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="literal">true</span></span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="literal">false</span></span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<ul>
<li>逻辑运算符</li>
</ul>
<p>下面bash要做的是执行第一个命令，如果第一个命令失败，再去执行第二个（短路运算法则）。因为它尝试做一个逻辑或，如果第一个命令没有0错误码，就会去执行第二个命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="literal">false</span> || <span class="built_in">echo</span> <span class="string">&quot;Oops fail&quot;</span></span><br><span class="line">Oops fail</span><br></pre></td></tr></table></figure>

<p>相似地，如果我们把false换成true，那么将不会执行第二个命令，因为第一个命令已经返回一个0错误码了，第二个命令将会被短路。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="literal">true</span> || <span class="built_in">echo</span> <span class="string">&quot;Oops fail&quot;</span></span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ </span><br></pre></td></tr></table></figure>

<p>相似的，我们使用与运算符<code>&amp;&amp;</code>，它仅当第一个命令执行无错误时，才会执行第二个部分。如果第一个命令失败，那么第二个命令就不会被执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="literal">true</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Things went well&quot;</span></span><br><span class="line">Things went well</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="literal">false</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;This will not print&quot;</span></span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ </span><br></pre></td></tr></table></figure>

<p>使用<code>;</code>号连接的代码，无论你执行什么，都可以通过。在同一行使用分号来连接命令，如下，它始终会被打印出来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="literal">false</span> ; <span class="built_in">echo</span> <span class="string">&quot;This will always print&quot;</span></span><br><span class="line">This will always <span class="built_in">print</span></span><br></pre></td></tr></table></figure>

<ul>
<li>把命令的输出存到变量里</li>
</ul>
<p>这里我们获取pwd命令的输出，它会打印出我们当前的工作路径，然后把其存入foo变量中。然后我们询问变量foo的值，我们就可以看到这个字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ foo=$(<span class="built_in">pwd</span>)</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">/home/lighthouse/missing-semester/tools</span><br></pre></td></tr></table></figure>

<p>更广泛地来说，我们可以通过一个叫做命令替换的东西，把它放进任意字符串中。并且因为我们使用的不是单引号，所以这串东西会被展开。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> <span class="string">&quot;We are in <span class="subst">$(pwd)</span>&quot;</span></span><br><span class="line">We are <span class="keyword">in</span> /home/lighthouse/missing-semester/tools</span><br></pre></td></tr></table></figure>

<ul>
<li>过程替换</li>
</ul>
<p>另一个比较好用知名度更低的东西叫做过程替换。和之前的命令替换是类似的，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">cat</span> &lt;(<span class="built_in">ls</span>) &lt;(<span class="built_in">ls</span> ..)</span><br><span class="line">mcd.sh</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">tools</span><br></pre></td></tr></table></figure>

<p>如上，<code>&lt;(ls) &lt;(ls ..)</code>的作用是，<code>()</code>内部的命令会被执行，其输出将被存储到一个临时文件内，然后把文件的标识符handle交给最左边的命令。</p>
<p>因此，这里我们在ls这个目录，把输出放到临时文件内，再对父目录如法炮制，然后把两个文件连接。</p>
<p>这种写法非常方便，因为有些命令会从某个文件的内容，而不是从标准输入里，获得输入参数</p>
<p>综合案例：</p>
<p>现在来看一个里面包含这些内容的简单示例脚本：</p>
<p>example.sh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Start program at <span class="subst">$(date)</span>&quot;</span> <span class="comment"># Date will be substituted</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Running program <span class="variable">$0</span> with <span class="variable">$#</span> arguments with pid $$&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>;<span class="keyword">do</span></span><br><span class="line">        grep foobar <span class="string">&quot;<span class="variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">        <span class="comment"># When pattern is not found,grep has exit status</span></span><br><span class="line">        <span class="comment"># We redirect STDOUT and STDERR to a null register ..</span></span><br><span class="line">        <span class="keyword">if</span> [[ <span class="string">&quot;$?&quot;</span> -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;File <span class="variable">$file</span> does not have any foobar, adding one&quot;</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">        <span class="keyword">fi</span>      </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>第三行：有一个<code>$(date)</code>的参数，date打印出当前的时间。</p>
<p>第五行：<code>$0</code>代表着当前运行的脚本的名称，<code>$#</code>代表给定的参数个数，<code>$$</code>是这个命令的进程ID，一般缩写为PID。</p>
<p>第七行：<code>$@</code>可以展开成所有参数，比如有三个参数，你可以键入<code>$1 $2 $3</code>，如果你不知道有多少个参数，也可以直接键入<code>$@</code>。这里我们通过这种方式将所有参数放在这里，然后这些参数被传给for循环，for循环会创建一个<code>file</code>变量，依次地用这些参数赋值给<code>file</code>变量。</p>
<p>第八行：我们运行grep命令，它会在一堆文件里搜索一个子串。这里我们在文件里搜索字符串foobar，文件变量<code>file</code>将会展开为赋给它的值。</p>
<p>之前说过，如果我们在意程序的输出的话，我们可以把它重定向到某处（比如到一个文件里面保存下来，或者连接组合）。但有时候情况恰恰相反，例如有时候我们只想知道某个脚本的错误代码是什么，例如这里想知道grep能不能成功查找。我们并不在意程序的运行结果，因此我们甚至能直接扔掉整个输出，包括标准输出和标准错误流。这里我们做的就是把两个输出重定向到<code>/dev/null</code>，&#x2F;dev&#x2F;null是UNIX系统的一种特殊设备，输入到它的内容会被丢弃（就是说你可以随意乱写乱画，然后所有的内容都会被丢掉）。</p>
<p>这里的<code>&gt;</code>代表重定向输出流，<code>2&gt;</code>代表重定向标准错误流（因为这两个流是分立的，所以你要告诉bash去操作哪一个）。</p>
<p>所以这里我们执行命令，去检查文件有没有foobar字符串，如果有的话，返回一个0错误代码，如果没有返回一个非0错误代码。</p>
<p>第十一行：我们获取前一个命令的错误代码（<code>$?</code>），然后是一个比较运算符<code>-ne</code>（代表不等于Non Equal）</p>
<blockquote>
<p>其他编程序语言中有像&#x3D;和≠，bash里有很多预设的比较运算(可以使用命令<code>man test</code>查看)，这主要是为了你用Shell的时候，有很多东西要去测试。比如我们现在正在对比两个数，看它们是否相同。</p>
</blockquote>
<p>如果文件中没有foobar，前一个命令将会返回一个非零错误代码。</p>
<p>第十二行：我们将会如果前一个命令返回一个非0错误代码，我们将会输出一句话<code>File xxx does not have any foobar, adding one</code></p>
<p>第十三行：使用<code>&gt;&gt;</code>往对应文件中追加一行注释<code># foobar</code></p>
<p>现在我们来运行这个脚本，当前目录下有一些文件，我们将这些文件作为参数传给example.sh，检查是否有foobar。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span></span><br><span class="line">example.sh  hello.txt  mcd.sh</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ ./example.sh hello.txt mcd.sh</span><br><span class="line">Start program at Sun Dec 25 23:06:13 CST 2022</span><br><span class="line">Running program ./example.sh with 2 arguments with pid 2570038</span><br><span class="line">File hello.txt does not have any foobar, adding one</span><br><span class="line">File mcd.sh does not have any foobar, adding one</span><br></pre></td></tr></table></figure>

<p>我们在文件hello.txt和mcd.sh中没有找到foobar字符串，因此脚本分别给这两个文件添加了一个<code># foobar</code> 注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">cat</span> hello.txt</span><br><span class="line">hello,this is a txt file</span><br><span class="line"><span class="comment"># foobar</span></span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">cat</span> mcd.sh </span><br><span class="line"><span class="function"><span class="title">mcd</span></span>()&#123;</span><br><span class="line">	<span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">	<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># foobar</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通配符</li>
</ul>
<p>如果我们不想一个一个查找文件，可以使用通配符来进行匹配。</p>
<p>比如这里<code>*</code>匹配任意字符，这里将会显示出所有含有任意字符，并以<code>.sh</code>结尾的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span></span><br><span class="line">example.sh  hello.txt  image.png  mcd.sh  project1  project2  <span class="built_in">test</span></span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span> *.sh</span><br><span class="line">example.sh  mcd.sh</span><br></pre></td></tr></table></figure>

<p>现在如果我只想找有一个而不是两个特定字符的项，可以使用<code>?</code>，<code>?</code>匹配一个字符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span></span><br><span class="line">example.sh  hello.txt  image.png  mcd.sh  project1  project2  project42  <span class="built_in">test</span></span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span> project?</span><br><span class="line">project1:</span><br><span class="line">src</span><br><span class="line"></span><br><span class="line">project2:</span><br><span class="line">src</span><br></pre></td></tr></table></figure>

<p>现在我们得到了匹配的目录project1和project2</p>
<blockquote>
<p>src是匹配的目录下的子项</p>
</blockquote>
<p>总而言之，通配符非常强大，你也可以组合它们。</p>
<p>一个常用模式是花括号<code>&#123;&#125;</code>。</p>
<p>比如目录下有一个image.png图片，我们想转变该图像的格式，一般的做法是<code>convert image.png image.jpg</code>，但是你也可以键入<code>convert image.&#123;png,jpg&#125;</code>，它会展开成上面的那行。</p>
<p>又如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">touch</span> foo&#123;,1,2,10&#125;</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span></span><br><span class="line">example.sh  foo  foo1  foo10  foo2  hello.txt  mcd.sh project1  project2 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>如上所述，我们可以touch一串foo，所有的foo都会被展开。</p>
<p>你也可以进行多层操作，建立笛卡尔系：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">cat</span> &lt;(<span class="built_in">ls</span> project?/src/test)</span><br><span class="line">project1/src/test:</span><br><span class="line"></span><br><span class="line">project2/src/test:</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">touch</span> project&#123;1,2&#125;/src/test/test&#123;1,2,3&#125;.py</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">cat</span> &lt;(<span class="built_in">ls</span> project?/src/test)</span><br><span class="line">project1/src/test:</span><br><span class="line">test1.py</span><br><span class="line">test2.py</span><br><span class="line">test3.py</span><br><span class="line"></span><br><span class="line">project2/src/test:</span><br><span class="line">test1.py</span><br><span class="line">test2.py</span><br><span class="line">test3.py</span><br></pre></td></tr></table></figure>

<p>如上，我们在创建文件的路径上有两组花括号，这会用两组展开式形成笛卡尔积，意味着展开后所有的路径有2*3组。因此当我们运行命令<code>touch project&#123;1,2&#125;/src/test/test&#123;1,2,3&#125;.py</code>时，实际上分别在<code>./project1/src/test/</code>目录下和<code>./project2/src/test/</code>目录下创建了<code>test1.py</code>，<code>test2.py</code>，<code>test3.py</code>文件。</p>
<p>你也可以将<code>*</code>通配符和<code>&#123;&#125;</code>通配符结合，甚至用一些范围表示，如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">mkdir</span> foo bar</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">touch</span> &#123;foo,bar&#125;/&#123;a..d&#125;</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">cat</span> &lt;(<span class="built_in">ls</span> &#123;foo,bar&#125;/)</span><br><span class="line">bar/:</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line"></span><br><span class="line">foo/:</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure>

<p>如上，这将会从foo&#x2F;a一直到展开到foo&#x2F;d，而bar目录下同理。</p>
<ul>
<li>diff</li>
</ul>
<p>diff 命令用于比较文件的差异。diff 以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则 diff 会比较目录中相同文件名的文件，但不会比较其中子目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">touch</span> foo/x bar/y</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ diff &lt;(<span class="built_in">ls</span> foo) &lt;(<span class="built_in">ls</span> bar)</span><br><span class="line">5c5</span><br><span class="line">&lt; x</span><br><span class="line">---</span><br><span class="line">&gt; y</span><br></pre></td></tr></table></figure>

<p>如上，x只在第一个文件夹里，而y只在第二个文件夹内。</p>
<ul>
<li>其他Shell脚本</li>
</ul>
<p>目前为止我们只看了bash脚本，如果你喜欢其他脚本（bash对一些工作可能并不是最好的选择），你可以用很多语言写和Shell工具交互的脚本。注意，脚本并不一定只有用 bash 写才能在终端里调用。比如说，这是一段 Python 脚本，作用是将输入的参数倒序输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="built_in">reversed</span>(sys.argv[<span class="number">1</span>:]):</span><br><span class="line">    <span class="built_in">print</span>(arg)</span><br></pre></td></tr></table></figure>

<p>如上，python默认不会尝试和Shell交互，所以我们需要导入一些库<code>import sys</code>。第一行叫做shebang，Shell通过它了解怎么运行这个程序。</p>
<blockquote>
<p>shebang这个单词源于这行以<code>#!</code>开头，<code>#</code>是sharp，<code>!</code>是bang</p>
</blockquote>
<p>你可以随时键入类似<code>python script.py a b c</code>的命令来运行这个python脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ python script.py a b c</span><br><span class="line">c</span><br><span class="line">b</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p>但是如果想让它从Shell就能执行呢？这就需要用到shebang行。Shell用首行识别到需要用Python解释器运行这个程序，并且第一行给出了python解释器所在的路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ ./script.py a b c</span><br><span class="line">c</span><br><span class="line">b</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p>需要注意的是不同的设备很可能会把python放在不同的地方，最好不要假设文件放在固定的位置，其他的东西要是如此。</p>
<p> <code>shebang</code> 行中使用 <a href="https://man7.org/linux/man-pages/man1/env.1.html"><code>env</code></a> 命令，会根据给出的参数（这里是python），<code>env</code> 会利用之前的<code>PATH</code> 环境变量来进行定位，在此路径中找python二进制文件，然后用该文件去解释这个脚本。这会有更好的可移植性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="built_in">reversed</span>(sys.argv[<span class="number">1</span>:]):</span><br><span class="line">    <span class="built_in">print</span>(arg)</span><br></pre></td></tr></table></figure>

<ul>
<li>shellcheck</li>
</ul>
<p>编写bash脚本有时候会很别扭和反直觉。例如 <a href="https://github.com/koalaman/shellcheck">shellcheck</a> 这样的工具可以帮助你定位sh&#x2F;bash脚本中的错误。</p>
<blockquote>
<p><a href="https://github.com/koalaman/shellcheck/tree/v0.7.1#installing">koalaman&#x2F;shellcheck at v0.7.1 (github.com)</a></p>
</blockquote>
<p>shellcheck可以给出warning和语法错误提示，还能指出哪些地方你没正确引用等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ shellcheck mcd.sh</span><br><span class="line"></span><br><span class="line">In mcd.sh line 1:</span><br><span class="line"><span class="function"><span class="title">mcd</span></span>()&#123;</span><br><span class="line">^-- SC2148: Tips depend on target shell and yours is unknown. Add a shebang.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Shell函数和脚本的区别</li>
</ul>
<p>shell函数和脚本有如下一些不同点：</p>
<ol>
<li>函数只能与shell使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 <code>shebang</code> 是很重要的。</li>
<li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li>
<li>函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 <a href="https://man7.org/linux/man-pages/man1/export.1p.html"><code>export</code></a> 将环境变量导出，并将值传递给环境变量。</li>
<li>与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell脚本中往往也会包含它们自己的函数定义。</li>
</ol>
<h2 id="Shell工具"><a href="#Shell工具" class="headerlink" title="Shell工具"></a>Shell工具</h2><h3 id="查看命令如何使用"><a href="#查看命令如何使用" class="headerlink" title="查看命令如何使用"></a>查看命令如何使用</h3><ul>
<li>man命令</li>
</ul>
<p>给出一个命令，应该怎样了解如何使用这个命令行并找出它的不同的选项呢？最常用的方法是为对应的命令行添加<code>-h</code> 或 <code>--help</code> 标记。另外一个更详细的方法则是使用<code>man</code> 命令。<code>man</code>命令是手册（manual）的缩写，它提供了命令的用户手册。</p>
<p>事实上，目前我们给出的所有命令的说明链接，都是网页版的Linux命令手册，即使是安装的第三方命令。当然前提是开发者编写了手册并将其包含在了安装包中。在交互式的、基于字符处理的终端窗口中，一般也可以通过 <code>:help</code> 命令或键入 <code>?</code> 来获取帮助。</p>
<ul>
<li>tldr (too long don’t read)</li>
</ul>
<p>有时候手册内容太过详实，让我们难以在其中查找哪些最常用的标记和语法。<a href="https://tldr.sh/">TLDR pages</a>是一个很不错的替代品，它提供了一些案例，可以帮助你快速找到正确的选项。</p>
<blockquote>
<p>下载tldr：<code>npm install -g tldr</code></p>
<p>使用npm命令之前要先下载 <code>yum -y install npm</code></p>
</blockquote>
<h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><p>你当然可以使用ls，但是如果你想查找一个已经知道名字的文件或者目录，我们可以有更好的做法</p>
<ul>
<li>find</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/gexiaobaohelloworld/article/details/8206889">linux-find</a></p>
</blockquote>
<p>find大概是每个UNIX系统都有的工具，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ find . -name src -<span class="built_in">type</span> d</span><br><span class="line">./project1/src</span><br><span class="line">./project2/src</span><br></pre></td></tr></table></figure>

<p>这里意为，在当前文件夹<code>.</code>调用find，查找名为<code>src</code> 并且类型为目录的东西。键入以上命令，它就可以在当前目录递归查看所有符合规则的文件或者文件夹（find默认递归指定目录）。</p>
<p>find还有许多有用的flag，比如你甚至可以查询指定格式的文件路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ find . -path <span class="string">&#x27;**/test/*.py&#x27;</span> -<span class="built_in">type</span> f</span><br><span class="line">./project1/src/test/test2.py</span><br><span class="line">./project1/src/test/test1.py</span><br><span class="line">./project1/src/test/test3.py</span><br><span class="line">./project2/src/test/test2.py</span><br><span class="line">./project2/src/test/test1.py</span><br><span class="line">./project2/src/test/test3.py</span><br></pre></td></tr></table></figure>

<p>这里<code>**</code>是指可以匹配零或者多个目录名，然后在此路径下找到拓展名为<code>.py</code>的文件，并要求它们在一个test文件夹内，同时检查它是否为F类型（f代表文件file）</p>
<p>运用不用的flag，可以进行非路径和非文件名的筛选：</p>
<p>比如可以查找被修改过的文件，这里<code>-mtime</code>代表修改时间，<code>.</code>当前目录下，最近<code>1</code>天被修改过的东西都会被列出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ find . -mtime -1</span><br><span class="line">.</span><br><span class="line">./project1</span><br><span class="line">./project1/src</span><br><span class="line">./project1/src/test</span><br><span class="line">./project1/src/test/test2.py</span><br><span class="line">./project1/src/test/test1.py</span><br><span class="line">./project1/src/test/test3.py</span><br><span class="line">./project2</span><br><span class="line">./project2/src</span><br><span class="line">./project2/src/test</span><br><span class="line">./project2/src/test/test2.py</span><br><span class="line">./project2/src/test/test1.py</span><br><span class="line">./project2/src/test/test3.py</span><br><span class="line">./test</span><br><span class="line">./mcd.sh</span><br></pre></td></tr></table></figure>

<p>你甚至可以使用其他条件，比如大小，所有者，权限等等。</p>
<p>强大的是，find不仅可以查找东西，找到之后还可以做别的：例如</p>
<p>我们可以在当前目录下查找所有扩展名为<code>.tmp</code>的文件，然后要求find对于所有这些文件，执行<code>rm</code>命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ find . -name <span class="string">&quot;*.tmp&quot;</span></span><br><span class="line">./project1/src/test/test3.tmp</span><br><span class="line">./project1/src/test/test1.tmp</span><br><span class="line">./project1/src/test/test2.tmp</span><br><span class="line">./project2/src/test/test3.tmp</span><br><span class="line">./project2/src/test/test1.tmp</span><br><span class="line">./project2/src/test/test2.tmp</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ find . -name <span class="string">&quot;*.tmp&quot;</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ find . -name <span class="string">&quot;*.tmp&quot;</span></span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ </span><br></pre></td></tr></table></figure>

<p>如上，执行<code>find . -name &quot;*.tmp&quot; -exec rm &#123;&#125; \;</code>后，对应的tmp文件都被删除了。</p>
<ul>
<li>fd</li>
</ul>
<p><a href="https://github.com/sharkdp/fd"><code>fd</code></a> 是一个更简单、更快速、更友好的程序，它可以用来作为<code>find</code>的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。以模式<code>PATTERN</code> 搜索的语法是 <code>fd PATTERN</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ fd <span class="string">&quot;.*py&quot;</span></span><br><span class="line">project1/src/test/test1.py</span><br><span class="line">project1/src/test/test2.py</span><br><span class="line">project1/src/test/test3.py</span><br><span class="line">project2/src/test/test1.py</span><br><span class="line">project2/src/test/test2.py</span><br><span class="line">project2/src/test/test3.py</span><br></pre></td></tr></table></figure>

<ul>
<li>locate</li>
</ul>
<p>大多数人都认为 <code>find</code> 和 <code>fd</code> 已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p>
<p>这就要靠 <a href="https://man7.org/linux/man-pages/man1/locate.1.html"><code>locate</code></a> 了。 <code>locate</code> 使用一个由 <a href="https://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a>负责更新的数据库，在大多数系统中 <code>updatedb</code> 都会通过 <a href="https://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a> 每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code> 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code>则只能通过文件名。 <a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">这里</a>有一个更详细的对比。</p>
<h3 id="查找代码"><a href="#查找代码" class="headerlink" title="查找代码"></a>查找代码</h3><p>查找文件是很有用的技能，但是很多时候你的目标其实是查看文件的内容。常见的场景是查找具有匹配某种模式的全部文件，并找它们的位置。</p>
<ul>
<li>grep</li>
</ul>
<p>grep是用于对输入文本进行匹配的通用工具。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ grep foobar mcd.sh </span><br><span class="line"><span class="comment"># foobar</span></span><br></pre></td></tr></table></figure>

<p>使用-R可以递归地搜索</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ grep -R foobar .</span><br><span class="line">./example.sh:        grep foobar <span class="string">&quot;<span class="variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">./example.sh:                <span class="built_in">echo</span> <span class="string">&quot;File <span class="variable">$file</span> does not have any foobar, adding one&quot;</span></span><br><span class="line">./example.sh:                <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">./hello.txt:<span class="comment"># foobar</span></span><br><span class="line">./mcd.sh:<span class="comment"># foobar</span></span><br></pre></td></tr></table></figure>

<p><code>grep</code> 有很多选项，这也使它成为一个非常全能的工具。 <code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。但是也有很多办法可以对 <code>grep -R</code> 进行改进，例如使其忽略<code>.git</code> 文件夹，使用多CPU等等。</p>
<ul>
<li>rg（ripgrep）</li>
</ul>
<p>此外还出现了很多grep的替代品，包括 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a>。它们都特别好用，但是功能也都差不多，比较常用的是 ripgrep (<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。</p>
<blockquote>
<p><a href="https://outmanzzq.github.io/2019/11/13/ripgrep/">rg安装</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ rg <span class="string">&quot;foobar&quot;</span> -t sh ~/</span><br><span class="line">/home/lighthouse/missing/tools/mcd.sh</span><br><span class="line">5:<span class="comment"># foobar</span></span><br><span class="line"></span><br><span class="line">/home/lighthouse/missing/tools/example.sh</span><br><span class="line">8:        grep foobar <span class="string">&quot;<span class="variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">12:                <span class="built_in">echo</span> <span class="string">&quot;File <span class="variable">$file</span> does not have any foobar, adding one&quot;</span></span><br><span class="line">13:                <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>如上，该命令在<code>~/</code>目录下搜索类型(-t即type)为sh，并且文件内有“foobar”子串的文件。</p>
<p>rg不仅能找到对应文件，还能精确到匹配的行，比起使用grep，它还增加了代码彩色显示和文件处理啥的，也有Unicode支持，并且运行很快。</p>
<p>rg有许多有用的flag，比如说你想要点上下文(匹配内容的附近内容)，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ rg <span class="string">&quot;foobar&quot;</span> -t sh -C 5 ~/</span><br><span class="line">/home/lighthouse/missing/tools/mcd.sh</span><br><span class="line">1-<span class="function"><span class="title">mcd</span></span>()&#123;</span><br><span class="line">2-	<span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">3-	<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">4-&#125;</span><br><span class="line">5:<span class="comment"># foobar</span></span><br><span class="line"></span><br><span class="line">/home/lighthouse/missing/tools/example.sh</span><br><span class="line">3-<span class="built_in">echo</span> <span class="string">&quot;Start program at <span class="subst">$(date)</span>&quot;</span> <span class="comment"># Date will be substituted</span></span><br><span class="line">4-</span><br><span class="line">5-<span class="built_in">echo</span> <span class="string">&quot;Running program <span class="variable">$0</span> with <span class="variable">$#</span> arguments with pid $$&quot;</span></span><br><span class="line">6-</span><br><span class="line">7-<span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>;<span class="keyword">do</span></span><br><span class="line">8:        grep foobar <span class="string">&quot;<span class="variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">9-        <span class="comment"># When pattern is not found,grep has exit status</span></span><br><span class="line">10-        <span class="comment"># We redirect STDOUT and STDERR to a null register ..</span></span><br><span class="line">11-        <span class="keyword">if</span> [[ <span class="string">&quot;$?&quot;</span> -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">12:                <span class="built_in">echo</span> <span class="string">&quot;File <span class="variable">$file</span> does not have any foobar, adding one&quot;</span></span><br><span class="line">13:                <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">14-        <span class="keyword">fi</span>      </span><br><span class="line">15-<span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>如上，我们加上<code>-C [num]</code>（C意为context），不仅能够搜索到匹配内容，还能对每一个匹配的内容显示其前后[num]行的内容。这样你就可以知道匹配内容大概在什么位置，它周围都是什么内容。这个功能在查找在哪调用了什么函数 上十分有用。</p>
<p>我们也可以使用一个更高级的用法：</p>
<p><code>-u</code>意为不忽略隐藏文件，<code>--files-without-match</code>是打印出所有不匹配这个pattern的内容，<code>&#39;#!&#39;</code>的意思是匹配有<code>#!</code>的内容。也就是说，我们在搜索没有shebang的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ rg -u --files-without-match <span class="string">&#x27;#!&#x27;</span> -t sh</span><br><span class="line">mcd.sh</span><br></pre></td></tr></table></figure>

<p>此外rg还有些好用的flag，比如<code>--stats</code>这个flag，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ rg <span class="string">&quot;foobar&quot;</span> -t sh -C 5 --stats ~/</span><br><span class="line">/home/lighthouse/missing/tools/mcd.sh</span><br><span class="line">1-<span class="function"><span class="title">mcd</span></span>()&#123;</span><br><span class="line">2-	<span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">3-	<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">4-&#125;</span><br><span class="line">5:<span class="comment"># foobar</span></span><br><span class="line"></span><br><span class="line">/home/lighthouse/missing/tools/example.sh</span><br><span class="line">3-<span class="built_in">echo</span> <span class="string">&quot;Start program at <span class="subst">$(date)</span>&quot;</span> <span class="comment"># Date will be substituted</span></span><br><span class="line">4-</span><br><span class="line">5-<span class="built_in">echo</span> <span class="string">&quot;Running program <span class="variable">$0</span> with <span class="variable">$#</span> arguments with pid $$&quot;</span></span><br><span class="line">6-</span><br><span class="line">7-<span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>;<span class="keyword">do</span></span><br><span class="line">8:        grep foobar <span class="string">&quot;<span class="variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">9-        <span class="comment"># When pattern is not found,grep has exit status</span></span><br><span class="line">10-        <span class="comment"># We redirect STDOUT and STDERR to a null register ..</span></span><br><span class="line">11-        <span class="keyword">if</span> [[ <span class="string">&quot;$?&quot;</span> -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">12:                <span class="built_in">echo</span> <span class="string">&quot;File <span class="variable">$file</span> does not have any foobar, adding one&quot;</span></span><br><span class="line">13:                <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">14-        <span class="keyword">fi</span>      </span><br><span class="line">15-<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">4 matches</span><br><span class="line">4 matched lines</span><br><span class="line">2 files contained matches</span><br><span class="line">5 files searched</span><br><span class="line">643 bytes printed</span><br><span class="line">978 bytes searched</span><br><span class="line">0.000054 seconds spent searching</span><br><span class="line">0.002657 seconds</span><br></pre></td></tr></table></figure>

<p>如上，它除了搜索结果之外，还可以输出一些信息。比如成功匹配了多少行，查找了多少行和多少文件，打印了多少byte等。</p>
<ul>
<li>ack</li>
</ul>
<p><a href="https://beyondgrep.com/">ack</a>也是grep的一个替代工具，还有<a href="https://github.com/ggreer/the_silver_searcher">ag</a> 。当然这些工具都是可以替换的，只要会使用即可。</p>
<h3 id="查找shell命令"><a href="#查找shell命令" class="headerlink" title="查找shell命令"></a>查找shell命令</h3><ul>
<li>向上箭头</li>
</ul>
<p>首先，按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。</p>
<p>向上箭头并不是很有效率，所以bash有一些更加简单的方法。</p>
<ul>
<li>history</li>
</ul>
<p>它会打印出你的命令历史记录，当然一般来讲这会输出非常多的记录，你可以使用管道和grep来筛选。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">history</span> | grep <span class="built_in">echo</span></span><br><span class="line">   74  2022-12-29 01:16:27 <span class="built_in">echo</span> $?</span><br><span class="line">  112  2022-12-29 01:45:37 <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; mdc.sh</span><br><span class="line">  115  2022-12-29 01:46:01 <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; mcd.sh</span><br><span class="line">  126  2022-12-29 01:50:42 <span class="built_in">echo</span> <span class="string">&quot;hello,i am a txt file&quot;</span> &gt; hello.txt</span><br><span class="line">  197  2022-12-30 01:06:13 <span class="built_in">history</span> | grep <span class="built_in">echo</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Ctrl+R</li>
</ul>
<p>基本上，所有Shell都会默认把Ctrl+R这个组合键设成（按执行时间）倒叙搜索（backward search）</p>
<p>我们打开（按ctrl+r）倒叙搜索，然后输入<code>echo</code>，就会找到与之匹配的命令，如果我们接着按ctrl+r，就会倒着往前搜索匹配的命令，也可以重新执行命令。</p>
<ul>
<li>fzf</li>
</ul>
<p><code>Ctrl+R</code> 可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a> 使用。<code>fzf</code> 是一个通用对模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出</p>
<ul>
<li>基于历史的自动补全</li>
</ul>
<p>另外一个和历史命令相关的技巧我喜欢称之为<strong>基于历史的自动补全</strong>。 这一特性最初是由 <a href="https://fishshell.com/">fish</a> shell 创建的，它可以根据你最近使用过的开头相同的命令，动态地对当前对shell命令进行补全。这一功能在 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh</a> 中也可以使用，它可以极大的提高用户体验。</p>
<blockquote>
<p>你可以修改 shell history 的行为，例如，如果在命令的开头加上一个空格，它就不会被加进shell记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。 为此你需要在<code>.bashrc</code>中添加<code>HISTCONTROL=ignorespace</code>或者向<code>.zshrc</code> 添加 <code>setopt HIST_IGNORE_SPACE</code>。 如果你不小心忘了在前面加空格，可以通过编辑。<code>bash_history</code>或 <code>.zhistory</code> 来手动地从历史记录中移除那一项。</p>
</blockquote>
<h3 id="文件夹导航"><a href="#文件夹导航" class="headerlink" title="文件夹导航"></a>文件夹导航</h3><p>你可以使用<code>ls -R</code>递归地列出某目录下所有的文件和目录，但是这样列出的东西比较难理解。</p>
<ul>
<li>tree</li>
</ul>
<p>有一个叫<code>tree</code>的工具可以以比较友好的格式打印出目录的结构。</p>
<blockquote>
<p>centos安装：sudo yum -y install tree</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ tree /home</span><br><span class="line">/home</span><br><span class="line">`-- lighthouse</span><br><span class="line">    `-- missing</span><br><span class="line">        `-- tools</span><br><span class="line">            |-- example.sh</span><br><span class="line">            |-- hello.txt</span><br><span class="line">            |-- mcd.sh</span><br><span class="line">            |-- project1</span><br><span class="line">            |   `-- src</span><br><span class="line">            |       `-- <span class="built_in">test</span></span><br><span class="line">            |           |-- test1.py</span><br><span class="line">            |           |-- test2.py</span><br><span class="line">            |           `-- test3.py</span><br><span class="line">            |-- project2</span><br><span class="line">            |   `-- src</span><br><span class="line">            |       `-- <span class="built_in">test</span></span><br><span class="line">            |           |-- test1.py</span><br><span class="line">            |           |-- test2.py</span><br><span class="line">            |           `-- test3.py</span><br><span class="line">            `-- <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">10 directories, 9 files</span><br></pre></td></tr></table></figure>

<ul>
<li>broot</li>
</ul>
<p>broot也是做差不多的事情，但是比起列出所有文件，它会提示[还有更多文件，未列出]。你可以输入字符，broot可以模糊匹配符合条件的文件，并进行动态显示。这样你就可以快速的选择和定位。</p>
<ul>
<li>nnn</li>
</ul>
<p>nnn 默认列出运行 nnn 的当前目录的文件和文件夹。 文件夹列在顶部，而文件列在底部。而且是一个交互性的窗口，你可以通过向左箭头返回上一级目录，通过向右箭头到达子目录。按q即可退出窗口。</p>
<blockquote>
<p>centos 安装 nnn ：sudo yum install nnn</p>
</blockquote>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221230014444510.png" alt="image-20221230014444510" style="zoom:60%;" />

<ul>
<li>ranger</li>
</ul>
<p>ranger 是一个基于文本的由 Python 编写的文件管理器。不同层级的目录分别在一个面板的三列中进行展示. 可以通过快捷键, 书签, 鼠标以及历史命令在它们之间移动. 当选中文件或目录时, 会自动显示文件或目录的内容。</p>
<hr>
<p>由于本课程的目的是尽可能对你的日常习惯进行优化。因此，我们可以使用<a href="https://github.com/clvv/fasd">fasd</a>和 <a href="https://github.com/wting/autojump">autojump</a> 这两个工具来查找最常用或最近使用的文件和目录。</p>
<p>Fasd 基于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm">frecency </a>对文件和文件排序，也就是说它会同时针对频率（frequency）和时效（recency）进行排序。默认情况下，<code>fasd</code>使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如， 如果您经常访问<code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于 autojump，则使用<code>j cool</code>代替即可。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>阅读 <a href="https://man7.org/linux/man-pages/man1/ls.1.html"><code>man ls</code></a> ，然后使用<code>ls</code> 命令进行如下操作：</p>
<ul>
<li>所有文件（包括隐藏文件）</li>
<li>文件打印以人类可以理解的格式输出 (例如，使用454M 而不是 454279954)</li>
<li>文件以最近访问顺序排序</li>
<li>以彩色文本显示输出结果</li>
</ul>
<p>典型输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rw-r--r--   1 user group 1.1M Jan 14 09:53 baz</span><br><span class="line">drwxr-xr-x   5 user group  160 Jan 14 09:53 .</span><br><span class="line">-rw-r--r--   1 user group  514 Jan 14 06:42 bar</span><br><span class="line">-rw-r--r--   1 user group 106M Jan 13 12:12 foo</span><br><span class="line">drwx------+ 47 user group 1.5K Jan 12 18:08 ..</span><br></pre></td></tr></table></figure>

<hr>
<p>练习：</p>
<p>(1) 显示包括隐藏文件</p>
<blockquote>
<p>-a, –all<br>             do not ignore entries starting with .</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span> -a</span><br><span class="line">.  ..  example.sh  hello.txt  mcd.sh  project1  project2  <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>(2) 文件以人类可以理解的格式输出</p>
<blockquote>
<p>-h, –human-readable<br>              with -l, print sizes in human readable format (e.g., 1K 234M 2G)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span> -hl</span><br><span class="line">total 24K</span><br><span class="line">-rwxrwxr-- 1 lighthouse lighthouse  494 Dec 29 01:49 example.sh</span><br><span class="line">-rw-rw-r-- 1 lighthouse lighthouse   31 Dec 29 01:55 hello.txt</span><br><span class="line">-rw-rwxr-- 1 lighthouse lighthouse   42 Dec 29 01:46 mcd.sh</span><br><span class="line">drwxrwxr-x 3 lighthouse lighthouse 4.0K Dec 29 00:47 project1</span><br><span class="line">drwxrwxr-x 3 lighthouse lighthouse 4.0K Dec 29 00:47 project2</span><br><span class="line">drwxrwxr-x 2 lighthouse lighthouse 4.0K Dec 29 00:55 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>(3) 文件以最近访问顺序排序</p>
<blockquote>
<p>-t     sort by modification time, newest first</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span> -lt</span><br><span class="line">total 24</span><br><span class="line">-rw-rw-r-- 1 lighthouse lighthouse   31 Dec 29 01:55 hello.txt</span><br><span class="line">-rwxrwxr-- 1 lighthouse lighthouse  494 Dec 29 01:49 example.sh</span><br><span class="line">-rw-rwxr-- 1 lighthouse lighthouse   42 Dec 29 01:46 mcd.sh</span><br><span class="line">drwxrwxr-x 2 lighthouse lighthouse 4096 Dec 29 00:55 <span class="built_in">test</span></span><br><span class="line">drwxrwxr-x 3 lighthouse lighthouse 4096 Dec 29 00:47 project1</span><br><span class="line">drwxrwxr-x 3 lighthouse lighthouse 4096 Dec 29 00:47 project2</span><br></pre></td></tr></table></figure>

<p>(4) 以彩色文本显示输出结果</p>
<blockquote>
<p>–color[&#x3D;WHEN]<br>             colorize the output; WHEN can be ‘never’, ‘auto’, or ‘always’ (the default); more info below</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span> --color=auto</span><br><span class="line">example.sh  hello.txt  mcd.sh  project1  project2  <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>综合：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span> -laht --color=auto</span><br><span class="line">total 32K</span><br><span class="line">drwxrwxr-x 5 lighthouse lighthouse 4.0K Dec 30 01:14 .</span><br><span class="line">-rw-rw-r-- 1 lighthouse lighthouse   31 Dec 29 01:55 hello.txt</span><br><span class="line">-rwxrwxr-- 1 lighthouse lighthouse  494 Dec 29 01:49 example.sh</span><br><span class="line">-rw-rwxr-- 1 lighthouse lighthouse   42 Dec 29 01:46 mcd.sh</span><br><span class="line">drwxrwxr-x 2 lighthouse lighthouse 4.0K Dec 29 00:55 <span class="built_in">test</span></span><br><span class="line">drwxrwxr-x 3 lighthouse lighthouse 4.0K Dec 29 00:47 project1</span><br><span class="line">drwxrwxr-x 3 lighthouse lighthouse 4.0K Dec 29 00:47 project2</span><br><span class="line">drwxrwxr-x 3 lighthouse lighthouse 4.0K Dec 29 00:46 ..</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写两个bash函数 <code>marco</code> 和 <code>polo</code> 执行下面的操作。 每当你执行 <code>marco</code> 时，当前的工作目录应当以某种形式保存，当执行 <code>polo</code> 时，无论现在处在什么目录下，都应当 <code>cd</code> 回到当时执行 <code>marco</code> 的目录。 为了方便debug，你可以把代码写在单独的文件 <code>marco.sh</code> 中，并通过 <code>source marco.sh</code>命令，（重新）加载函数。</p>
<p>练习：</p>
<p>marco.sh:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">marco</span></span>()&#123;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(pwd)</span>&quot;</span> &gt; ~/pwd.txt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">polo</span></span>()&#123;</span><br><span class="line">jump=$(<span class="built_in">cat</span> ~/pwd.txt)</span><br><span class="line"><span class="comment"># 使用$(命令)的方式可以赋给变量</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$jump</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;You had alread jump to --&gt;<span class="variable">$jump</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">source</span> marco.sh</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ marco</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">cd</span> /</span><br><span class="line">[lighthouse@VM-8-17-centos /]$ polo</span><br><span class="line">You had alread jump to --&gt;/home/lighthouse/missing/tools</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ </span><br></pre></td></tr></table></figure>
</li>
<li><p>假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段bash脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">   </span><br><span class="line">n=$(( RANDOM % <span class="number">100</span> ))</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> [[ n -eq 42 ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;Something went wrong&quot;</span></span><br><span class="line">   &gt;&amp;2 <span class="built_in">echo</span> <span class="string">&quot;The error was using magic numbers&quot;</span></span><br><span class="line">   <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">   </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Everything went according to plan&quot;</span></span><br></pre></td></tr></table></figure>

<p>练习：</p>
<p>上述脚本的意思是，取一个随机数（RANDOM变量用于生成0~32767之前的任意随机数），随机数模100。如果结果等于42，就输出两句话，然后返回1退出码；否则就输出”Everything went according to plan“</p>
<blockquote>
<p>这里的<code>&gt;&amp;2</code>的意思是  将标准输出1和标准错误输出2 都重定向到终端中（标准输出或标准错误输出的目的地默认都为终端）</p>
<p><a href="https://www.cnblogs.com/itsharehome/p/8503206.html">Linux shell标准输入，标准输出，错误输出</a></p>
</blockquote>
<p>run.sh（buggy.sh为题目的脚本名）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">count=1</span><br><span class="line">   </span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    ./buggy.sh 1&gt;&gt; out.log 2&gt;&amp;1 <span class="comment">#把stout和sterr一起重定向到out.log文件中(追加)</span></span><br><span class="line">    <span class="keyword">if</span> [[ $? -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line"> 	 <span class="built_in">echo</span> <span class="string">&quot;运行错误，记录在out.log中&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;共运行 <span class="variable">$count</span> 次&quot;</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    ((count++))</span><br><span class="line">   </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ ./run.sh </span><br><span class="line">运行错误，记录在out.log中</span><br><span class="line">共运行 82 次</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ ./run.sh </span><br><span class="line">运行错误，记录在out.log中</span><br><span class="line">共运行 42 次</span><br></pre></td></tr></table></figure>
</li>
<li><p>本节课我们讲解的 <code>find</code> 命令中的 <code>-exec</code> 参数非常强大，它可以对我们查找的文件进行操作。但是，如果我们要对所有文件进行操作呢？例如创建一个zip压缩文件？我们已经知道，命令行可以从参数或标准输入接受输入。在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如<code>tar</code> 则需要从参数接受输入。这里我们可以使用<a href="https://man7.org/linux/man-pages/man1/xargs.1.html"><code>xargs</code></a> 命令，它可以使用标准输入中的内容作为参数。 例如 <code>ls | xargs rm</code> 会删除当前目录中的所有文件。</p>
<p>您的任务是编写一个命令，它可以递归地查找文件夹中所有的HTML文件，并将它们压缩成zip文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行（提示：查看 <code>xargs</code>的参数<code>-d</code>，译注：MacOS 上的 <code>xargs</code>没有<code>-d</code>，<a href="https://github.com/missing-semester/missing-semester/issues/93">查看这个issue</a>）</p>
<p>如果您使用的是 MacOS，请注意默认的 BSD <code>find</code> 与 <a href="https://en.wikipedia.org/wiki/List_of_GNU_Core_Utilities_commands">GNU coreutils</a> 中的是不一样的。你可以为<code>find</code>添加<code>-print0</code>选项，并为<code>xargs</code>添加<code>-0</code>选项。作为 Mac 用户，您需要注意 mac 系统自带的命令行工具和 GNU 中对应的工具是有区别的；如果你想使用 GNU 版本的工具，也可以使用 <a href="https://formulae.brew.sh/formula/coreutils">brew 来安装</a>。</p>
<p>练习：</p>
<p>事先在当前文件夹下创建了一些html文件（包括带有空格的he llo.html）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos question4]$ tree </span><br><span class="line">.</span><br><span class="line">|-- he\ llo.html</span><br><span class="line">|-- index.html</span><br><span class="line">|-- project1</span><br><span class="line">|   |-- <span class="built_in">test</span></span><br><span class="line">|   |-- test1.html</span><br><span class="line">|   |-- test2.html</span><br><span class="line">|   `-- test3.html</span><br><span class="line">|-- project2</span><br><span class="line">|   |-- <span class="built_in">test</span></span><br><span class="line">|   |-- test1.html</span><br><span class="line">|   |-- test2.html</span><br><span class="line">|   `-- test3.html</span><br><span class="line">|-- test1.html</span><br><span class="line">|-- test2.html</span><br><span class="line">|-- test3.html</span><br><span class="line">|-- test4.html</span><br><span class="line">|-- test5.html</span><br><span class="line">|-- test6.html</span><br><span class="line">|-- test7.html</span><br><span class="line">|-- test8.html</span><br><span class="line">`-- test9.html</span><br><span class="line"></span><br><span class="line">4 directories, 17 files</span><br></pre></td></tr></table></figure>

<p>使用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos question4]$ find .  -name <span class="string">&quot;*.html&quot;</span> | xargs -d <span class="string">&#x27;\n&#x27;</span> tar -cf html.zip</span><br></pre></td></tr></table></figure>

<p>查看压缩包内容：</p>
<p>可以看到包括有空格文件名的html在内全部压缩成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos question4]$ tar -tf html.zip </span><br><span class="line">./project1/test3.html</span><br><span class="line">./project1/test2.html</span><br><span class="line">./project1/test1.html</span><br><span class="line">./test6.html</span><br><span class="line">./test3.html</span><br><span class="line">./test8.html</span><br><span class="line">./test4.html</span><br><span class="line">./test9.html</span><br><span class="line">./project2/test3.html</span><br><span class="line">./project2/test2.html</span><br><span class="line">./project2/test1.html</span><br><span class="line">./test5.html</span><br><span class="line">./he llo.html</span><br><span class="line">./test2.html</span><br><span class="line">./index.html</span><br><span class="line">./test1.html</span><br><span class="line">./test7.html</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/141500550">xargs使用教程 </a>    <a href="https://zhuanlan.zhihu.com/p/91593509">Linux下查看压缩文件内容的 10 种方法</a></p>
<p>使用 <code>tar -tf</code> 命令可以在不提取 <code>tar</code> 文件的情况下查看压缩包内容。</p>
</blockquote>
</li>
<li><p>（进阶）编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos question4]$ find . -<span class="built_in">type</span> f -mmin -120 | xargs -d <span class="string">&#x27;\n&#x27;</span>  <span class="built_in">ls</span> -tl | <span class="built_in">head</span> -3</span><br><span class="line">-rw-rw-r-- 1 lighthouse lighthouse 10240 Jan  3 22:01 ./html.zip</span><br><span class="line">-rw-rw-r-- 1 lighthouse lighthouse     0 Jan  3 21:36 ./he llo.html</span><br><span class="line">-rw-rw-r-- 1 lighthouse lighthouse     0 Jan  3 21:15 ./project1/test1.html</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>the missing semester of cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
