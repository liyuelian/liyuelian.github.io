<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2023/01/14/23-56-00/</url>
    <content><![CDATA[<h1 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h1><h2 id="1-Git概述"><a href="#1-Git概述" class="headerlink" title="1.Git概述"></a>1.Git概述</h2><p>Git是一个免费的，开源的分布式版本控制系统，可以快速高效地处理从小型到大型的各种项目。</p>
<p>Git易于学习，占地面积小，性能极快。它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性。其性能优于Subversion，CVS，Perforce和ClearCase等版本控制工具。</p>
<span id="more"></span>

<h3 id="1-1何为版本控制"><a href="#1-1何为版本控制" class="headerlink" title="1.1何为版本控制"></a>1.1何为版本控制</h3><p>在学习Git之前，我们需要先明白一个概念：版本控制。</p>
<p>版本控制是一种记录文件内容变化，一边将来查阅特定版本修订情况的系统。</p>
<p>版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209001918788.png" alt="image-20221209001918788" style="zoom:55%;" />

<ul>
<li>为什么需要版本控制?</li>
</ul>
<p>从个人开发过渡到团体协作。</p>
<h3 id="1-2版本控制工具"><a href="#1-2版本控制工具" class="headerlink" title="1.2版本控制工具"></a>1.2版本控制工具</h3><h4 id="1-2-1集中式版本控制工具"><a href="#1-2-1集中式版本控制工具" class="headerlink" title="1.2.1集中式版本控制工具"></a>1.2.1集中式版本控制工具</h4><p>CVS，SVN(Subversion)，VSS……</p>
<p>集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS），诸如CVS，SVN等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连接到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。</p>
<p>这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做什么，而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统，要远比在每个客户端上维护本地数据库来得轻松容易。</p>
<p>事分两面，有好有坏，这么做显而易见的缺点是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209003803838.png" alt="image-20221209003803838" style="zoom: 35%;" />

<h4 id="1-2-2分布式版本控制工具"><a href="#1-2-2分布式版本控制工具" class="headerlink" title="1.2.2分布式版本控制工具"></a>1.2.2分布式版本控制工具</h4><p>于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 </p>
<p>在这类系统中，像Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p>
<p>分布式的版本控制系统出现之后，解决了集中式版本控制系统的缺陷：</p>
<ol>
<li>服务器断网的情况下也可以进行开发，因为版本控制系统是在本地进行的</li>
<li>每个客户端保存的都是整个完整的项目，包含历史记录，更加安全</li>
</ol>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209003903055.png" alt="image-20221209003903055" style="zoom:65%;" />

<h3 id="1-3Git发展历史"><a href="#1-3Git发展历史" class="headerlink" title="1.3Git发展历史"></a>1.3Git发展历史</h3><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209215608236.png" alt="image-20221209215608236" style="zoom:60%;" />

<h3 id="1-4Git工作机制"><a href="#1-4Git工作机制" class="headerlink" title="1.4Git工作机制"></a>1.4Git工作机制</h3><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209215634523.png" alt="image-20221209215634523" style="zoom:55%;" />

<p>工作区：指的是你代码存放的磁盘目录位置</p>
<blockquote>
<p>除此之外可以通过pull，将代码推送到远程库中</p>
</blockquote>
<h3 id="1-5Git和代码托管中心"><a href="#1-5Git和代码托管中心" class="headerlink" title="1.5Git和代码托管中心"></a>1.5Git和代码托管中心</h3><p>代码托管中心是基于网络服务器的远程代码仓库，一般我们简单称为远程库。</p>
<p>局域网：GitLab</p>
<p>互联网：GitHub，Gitee</p>
<h2 id="2-Git安装"><a href="#2-Git安装" class="headerlink" title="2.Git安装"></a>2.Git安装</h2><p>关于Git的详细介绍：<a href="https://git-scm.com/book/zh/v2">Git - Book (git-scm.com)</a></p>
<p>Git下载地址：<a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a></p>
<p>Git安装教程：<a href="https://blog.csdn.net/mukes/article/details/115693833">Git-详细安装教程</a></p>
<h2 id="3-Git常用命令"><a href="#3-Git常用命令" class="headerlink" title="3.Git常用命令"></a>3.Git常用命令</h2><table>
<thead>
<tr>
<th>命令名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>git config –global user.name 用户名</td>
<td>设置用户签名</td>
</tr>
<tr>
<td>git config –global user.email 邮箱</td>
<td>设置用户签名</td>
</tr>
<tr>
<td>git init</td>
<td>初始化本地库</td>
</tr>
<tr>
<td>git status</td>
<td>查看本地库状态</td>
</tr>
<tr>
<td>git add 文件名</td>
<td>添加到暂存区</td>
</tr>
<tr>
<td>git commit -m “日志信息” 文件名</td>
<td>提交到本地库</td>
</tr>
<tr>
<td>git reflog</td>
<td>查看历史记录</td>
</tr>
<tr>
<td>git reset –hard 版本号</td>
<td>版本穿梭</td>
</tr>
</tbody></table>
<h3 id="3-1设置用户签名"><a href="#3-1设置用户签名" class="headerlink" title="3.1设置用户签名"></a>3.1设置用户签名</h3><p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name 你的用户名</span><br><span class="line">git config --global user.email 你的邮箱</span><br></pre></td></tr></table></figure>

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209224428028.png" alt="image-20221209224428028" style="zoom:67%;" />

<blockquote>
<p>用户名和邮箱可以多次设置</p>
</blockquote>
<p>可以在c盘的用户目录下的gitconfig文件中查看修改内容：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209225222338.png" alt="image-20221209225222338" style="zoom:80%;" />

<blockquote>
<p>说明：</p>
<p>签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。<strong>Git 首次安装必须设置一下用户签名，否则无法提交代码。</strong><br>※注意：这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。</p>
</blockquote>
<h3 id="3-2初始化本地库"><a href="#3-2初始化本地库" class="headerlink" title="3.2初始化本地库"></a>3.2初始化本地库</h3><p>使用<code>git init</code>命令初始化本地仓库</p>
<p>1.创建一个项目文件夹，在文件夹下面右键，点击Git Bash Here，就可以将当前的路径赋给git命令行，即进入到当前目录。使用git init命令初始化当前目录：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209225620534.png" alt="image-20221209225620534" style="zoom: 67%;" />

<p>2.初始化成功之后可以在当前目录下看到.git文件（隐藏文件）：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209230419104.png" alt="image-20221209230419104" style="zoom:67%;" />

<h3 id="3-3查看本地库状态"><a href="#3-3查看本地库状态" class="headerlink" title="3.3查看本地库状态"></a>3.3查看本地库状态</h3><p>使用<code>git status</code>命令来查看本地库状态</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209230657136.png" alt="image-20221209230657136" style="zoom:67%;" />

<h3 id="3-4添加暂存区"><a href="#3-4添加暂存区" class="headerlink" title="3.4添加暂存区"></a>3.4添加暂存区</h3><p>使用<code>git add 文件名</code> 命令将工作区的文件添加到暂存区</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209231331429.png" alt="image-20221209231331429" style="zoom:67%;" />

<p>1.添加过后，Git就可以追踪到该文件：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209231541310.png" alt="image-20221209231541310" style="zoom:67%;" />

<p>2.如果在暂存区将该文件的cached删除（不是删除工作区的文件），删除后工作区的该文件又会变回未追踪状态</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209231800416.png" alt="image-20221209231800416" style="zoom:67%;" />

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209232019992.png" alt="image-20221209232019992" style="zoom:67%;" />

<h3 id="3-5提交本地库"><a href="#3-5提交本地库" class="headerlink" title="3.5提交本地库"></a>3.5提交本地库</h3><p>使用<code>git commit -m &quot;日志信息&quot; 文件名</code>命令将暂存区的缓存文件提交到本地仓库</p>
<blockquote>
<p>日志信息必须填写</p>
</blockquote>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209232730387.png" alt="image-20221209232730387" style="zoom:67%;" />

<p>1.这时如果查看状态，可以看到如下状态，说明已经提交过文件，并且在提交过后文件既没有新增，也没有修改，工作树是干净的</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209232934074.png" alt="image-20221209232934074" style="zoom: 67%;" />

<p>2.也可以通过git reflog命令来查看引用日志信息：下图说明指针head指向了master分支第一次提交的版本</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209233253426.png" alt="image-20221209233253426" style="zoom:67%;" />

<p>3.还可以使用git log命令来查看详细的日志：不仅可以看到提交的版本号，还可以看到提交者信息和提交时间</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209233611342.png" alt="image-20221209233611342" style="zoom:67%;" />

<h3 id="3-6修改文件"><a href="#3-6修改文件" class="headerlink" title="3.6修改文件"></a>3.6修改文件</h3><p>1.如果我们将**追踪过(创建过快照)**的文件再次进行修改，那么此时该文件的状态将是modified，且是红色的。代表已追踪过的文件又修改了，但是没有提交到暂存区。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209234419006.png" alt="image-20221209234419006" style="zoom:67%;" />

<p>2.这时，只要将修改过的文件再次添加到暂存区，文件的状态仍是modified，但是已经变为了绿色。代表已追踪过文件又修改了，并且已经提交到了暂存区。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209235150197.png" alt="image-20221209235150197" style="zoom:67%;" />

<p>3.将该文件提交commit后，再次查看本地库的状态，就可以看到工作树清空了</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209235534925.png" alt="image-20221209235534925" style="zoom:67%;" />

<p>4.查看日志，可以看到本地仓库中有两个代码版本，head指针指向了master分支的第二个版本</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221209235822216.png" alt="image-20221209235822216" style="zoom:67%;" />

<h3 id="3-7历史版本"><a href="#3-7历史版本" class="headerlink" title="3.7历史版本"></a>3.7历史版本</h3><h4 id="3-7-1查看历史版本信息"><a href="#3-7-1查看历史版本信息" class="headerlink" title="3.7.1查看历史版本信息"></a>3.7.1查看历史版本信息</h4><p><code>git reflog</code> 查看版本信息</p>
<p><code>git log</code> 查看版本详细信息</p>
<blockquote>
<p>git reflog 和 git log 的区别：</p>
<p><code>git log</code>是显示当前的<code>HEAD</code>和它的祖先的，递归是沿着当前指针的父亲，父亲的父亲，……，这样的原则。</p>
<p><code>git reflog</code>根本不遍历<code>HEAD</code>的祖先。它是<code>HEAD</code>所指向的一个顺序的提交列表：它的<code>undo</code>历史。<code>reflog</code>并不是<code>repo</code>（仓库）的一部分，它单独存储，而且不包含在<code>pushes</code>，<code>fetches</code>或者<code>clones</code>里面，它纯属是本地的。<br><code>reflog</code>可以很好地帮助你恢复你误操作的数据，例如你错误地<code>reset</code>了一个旧的提交，或者<code>rebase</code>，……，这个时候你可以使用<code>reflog</code>去查看在误操作之前的信息，并且使用<code>git reset --hard</code> 去恢复之前的状态。</p>
<p><a href="https://www.oxysun.cn/git/git-reflog.html">git-reflog的用法总结</a></p>
</blockquote>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221210000943339.png" alt="image-20221210000943339" style="zoom:67%;" />

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221210001013923.png" alt="image-20221210001013923" style="zoom:63%;" />

<h4 id="3-7-2版本穿梭"><a href="#3-7-2版本穿梭" class="headerlink" title="3.7.2版本穿梭"></a>3.7.2版本穿梭</h4><p>命令：<code>git reset --hard 版本号</code></p>
<blockquote>
<p>版本号可以通过git reflog命令查看</p>
</blockquote>
<p>1.如下，通过命令可以穿梭回第二个版本。</p>
<p>通过git reflog命令查看日志，可以发现head指针已经指向第二个版本了</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221210001534395.png" alt="image-20221210001534395" style="zoom:67%;" />

<p>这时查看文件，可以发现文件的内容变成了第二个版本commit时的内容。</p>
<p>2.通过上述过程，可以将提交过的文件变为任意版本</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221210002428435.png" alt="image-20221210002428435" style="zoom:67%;" />

<blockquote>
<p>progit：在 Git中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。<strong>为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。</strong> Git对待数据更像是一个快照流。</p>
</blockquote>
<h2 id="4-Git分支操作"><a href="#4-Git分支操作" class="headerlink" title="4.Git分支操作"></a>4.Git分支操作</h2><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221210004730687.png" alt="image-20221210004730687" style="zoom:67%;" />

<h3 id="4-1什么是分支"><a href="#4-1什么是分支" class="headerlink" title="4.1什么是分支"></a>4.1什么是分支</h3><p>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用）</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211000615923.png" alt="image-20221211000615923" style="zoom:67%;" />

<h3 id="4-2分支的好处"><a href="#4-2分支的好处" class="headerlink" title="4.2分支的好处"></a>4.2分支的好处</h3><p>同时并行推进多个功能的开发，提高开发效率。各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。</p>
<h3 id="4-3分支的操作"><a href="#4-3分支的操作" class="headerlink" title="4.3分支的操作"></a>4.3分支的操作</h3><table>
<thead>
<tr>
<th>分支命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>git branch 分支名</td>
<td>创建分支</td>
</tr>
<tr>
<td>git branch -v</td>
<td>查看分支</td>
</tr>
<tr>
<td>git checkout 分支名</td>
<td>切换分支(事实上是切换HEAD指针的指向)</td>
</tr>
<tr>
<td>git merge 分支名</td>
<td>把指定的分支合并到当前分支上</td>
</tr>
</tbody></table>
<h4 id="4-3-1查看分支"><a href="#4-3-1查看分支" class="headerlink" title="4.3.1查看分支"></a>4.3.1查看分支</h4><p><code>git branch -v</code> 查看分支</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211001748269.png" alt="image-20221211001748269" style="zoom:67%;" />

<p><code>*</code>代表当前所在的分支</p>
<h4 id="4-3-2创建分支"><a href="#4-3-2创建分支" class="headerlink" title="4.3.2创建分支"></a>4.3.2创建分支</h4><p><code>git branch 分支名</code> 创建分支</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211002144858.png" alt="image-20221211002144858" style="zoom:67%;" />

<p><code>git checkout -d 分支名</code>创建分支并切换到该分支上</p>
<h4 id="4-3-3切换分支"><a href="#4-3-3切换分支" class="headerlink" title="4.3.3切换分支"></a>4.3.3切换分支</h4><p><code>git checkout 分支名</code> 切换分支</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211002419771.png" alt="image-20221211002419771" style="zoom:67%;" />

<p>可以看到当前分支已经切换到hot-fix分支</p>
<blockquote>
<p>master、hot-fix 其实都是指向具体版本记录的指针。当前所在的分支，其实是由 HEAD<br>决定的。所以创建分支的本质就是多创建一个指针。<br>HEAD 如果指向 master，那么我们现在就在 master 分支上。<br>HEAD 如果执行 hotfix，那么我们现在就在 hotfix 分支上。<br>所以切换分支的本质就是<strong>移动 HEAD 指针</strong>。</p>
</blockquote>
<h4 id="4-3-4修改分支"><a href="#4-3-4修改分支" class="headerlink" title="4.3.4修改分支"></a>4.3.4修改分支</h4><p>分支的版本控制和主分支完全一致</p>
<p>比如现在修改hot-fix分支的hello.txt文件，查看该文件状态：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211003437436.png" alt="image-20221211003437436" style="zoom:67%;" />

<p>将其添加到暂存区并提交：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211003543855.png" alt="image-20221211003543855" style="zoom:67%;" />

<p>查看历史版本记录：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211003639625.png" alt="image-20221211003639625" style="zoom:67%;" />

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211003714457.png" alt="image-20221211003714457" style="zoom:67%;" />

<p>注：这里查看hot-fix分支可以看到之前在master分支上的提交记录，是因为分支的底层仍然是指针，它在创建的时候把复制分支当做父记录。这也是为什么创建一个新分支消耗的内存非常小。</p>
<h4 id="4-3-5删除分支"><a href="#4-3-5删除分支" class="headerlink" title="4.3.5删除分支"></a>4.3.5删除分支</h4><p>删除本地分支</p>
<p><code>git branch -d 分支名</code></p>
<p>删除远程分支</p>
<p><code>git push remote_name -d remote_branch_name</code></p>
<h4 id="4-3-6合并分支-正常合并"><a href="#4-3-6合并分支-正常合并" class="headerlink" title="4.3.6合并分支-正常合并"></a>4.3.6合并分支-正常合并</h4><p><code>git merge 分支名</code>：把指定的分支合并到当前分支上</p>
<blockquote>
<p>案例演示：在master分支上合并hot-fix分支（正常合并）</p>
</blockquote>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211004458756.png" alt="image-20221211004458756" style="zoom:67%;" />

<h4 id="4-3-7合并分支-冲突合并"><a href="#4-3-7合并分支-冲突合并" class="headerlink" title="4.3.7合并分支-冲突合并"></a>4.3.7合并分支-冲突合并</h4><p>冲突产生的原因：合并分支时，<strong>两个分支在同一个文件的同一个位置</strong>有两套完全不同的修改，Git无法替我们确定使用哪一个，必须<strong>人为决定</strong>新代码内容。</p>
<blockquote>
<p>案例演示：合并冲突分支</p>
</blockquote>
<p>我们分别在master分支和hot-fix分支的同一个文件上的同一行进行修改，并分别commit</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211005355223.png" alt="image-20221211005355223" style="zoom:67%;" />

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211005548285.png" alt="image-20221211005548285" style="zoom:67%;" />

<p>现在我们切换回master分支，在master分支上进行分支合并</p>
<p>系统提示：有文件合并冲突，修改冲突然后才能提交结果</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211010437064.png" alt="image-20221211010437064" style="zoom:67%;" />

<p>这时的本地库状态为：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211011220009.png" alt="image-20221211011220009" style="zoom:67%;" />

<p>用vim打开冲突的文件：可以看到产生冲突的地方已经用符号标注出来了，下图中的标注解释为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD </span><br><span class="line">当前分支的代码 </span><br><span class="line">=======</span><br><span class="line">合并过来的代码 </span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; hot-fix</span><br></pre></td></tr></table></figure>

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211011935638.png" alt="image-20221211011935638" style="zoom:67%;" />

<p>手动修改文件，并删除特殊符号，保存文件：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211012539662.png" alt="image-20221211012539662" style="zoom:67%;" />

<p>保存完文件之后，还要把修改后的文件再添加到暂存区：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211012817643.png" alt="image-20221211012817643" style="zoom:67%;" />

<p>然后提交保存：</p>
<blockquote>
<p><strong>注意此时commit不能带文件名</strong>，否则会提示错误。因为两个分支上的hello.txt都进行了修改，在合并冲突的情况下，git不知道提交的是哪一个文件</p>
</blockquote>
<p>合并成功，右上角的MERGING标识消失：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211013143720.png" alt="image-20221211013143720" style="zoom:67%;" />

<blockquote>
<p>注意：这里的合并只会修改master分支的文件，hot-fix分支的文件没有被修改</p>
</blockquote>
<h2 id="5-Git团队协作机制"><a href="#5-Git团队协作机制" class="headerlink" title="5.Git团队协作机制"></a>5.Git团队协作机制</h2><h3 id="5-1团队内协作"><a href="#5-1团队内协作" class="headerlink" title="5.1团队内协作"></a>5.1团队内协作</h3><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211014417956.png" alt="image-20221211014417956" style="zoom:60%;" />

<h3 id="5-2跨团队协作"><a href="#5-2跨团队协作" class="headerlink" title="5.2跨团队协作"></a>5.2跨团队协作</h3><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211014505535.png" alt="image-20221211014505535" style="zoom:60%;" />



<h2 id="6-GitHub操作"><a href="#6-GitHub操作" class="headerlink" title="6.GitHub操作"></a>6.GitHub操作</h2><p>github网址：<a href="https://github.com/">GitHub</a></p>
<h3 id="6-1创建远程库"><a href="#6-1创建远程库" class="headerlink" title="6.1创建远程库"></a>6.1创建远程库</h3><ol>
<li><p>注册登录账号，点击账号页面</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130184900892.png" alt="image-20221130184900892" style="zoom:67%;" />
</li>
<li><p>点击页面右上方的+号，选择new repository，创建新项目</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130203615053.png" alt="image-20221130203615053" style="zoom:67%;" />
</li>
<li><p>在repository name中填写你的仓库名</p>
<p>注意：仓库名不支持中文，所有的中文符号会被自动识别为<code>-</code>符号。</p>
</li>
<li><p>填写项目简介，简介支持中文</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130204103838.png" alt="image-20221130204103838" style="zoom:60%;" />
</li>
<li><p>点击add a readme file选项，项目会自动创建一个readme文件</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130204415065.png" alt="image-20221130204415065" style="zoom:67%;" />
</li>
<li><p>其他的选项默认即可</p>
</li>
<li><p>最后点击按钮创建</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130204525444.png" alt="image-20221130204525444" style="zoom:67%;" /></li>
</ol>
<h3 id="6-2远程仓库操作"><a href="#6-2远程仓库操作" class="headerlink" title="6.2远程仓库操作"></a>6.2远程仓库操作</h3><table>
<thead>
<tr>
<th>命令名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>git remote -v</td>
<td>查看当前所有远程地址别名</td>
</tr>
<tr>
<td>git remote add 别名 远程地址</td>
<td>起别名</td>
</tr>
<tr>
<td>git push 别名 分支</td>
<td>推送本地分支上的内容到远程仓库</td>
</tr>
<tr>
<td>git clone 远程地址</td>
<td>将远程仓库的内容克隆到本地</td>
</tr>
<tr>
<td>git pull 远程库地址别名 远程分支名</td>
<td>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</td>
</tr>
</tbody></table>
<h4 id="6-2-1创建远程仓库别名"><a href="#6-2-1创建远程仓库别名" class="headerlink" title="6.2.1创建远程仓库别名"></a>6.2.1创建远程仓库别名</h4><p><code>git remote -v</code>  查看当前所有远程地址别名</p>
<p><code>git remote add 别名 远程地址</code> 给远程仓库起别名</p>
<blockquote>
<p>这里使用ssh链接，使用ssh链接前请看6.4SSH免密登录</p>
</blockquote>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211234051674.png" alt="image-20221211234051674" style="zoom:80%;" />

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211234403603.png" alt="image-20221211234403603" style="zoom:67%;" />

<p>可以看到拉取远程仓库和推送都可以使用该别名</p>
<h4 id="6-2-2推送本地分支到远程仓库"><a href="#6-2-2推送本地分支到远程仓库" class="headerlink" title="6.2.2推送本地分支到远程仓库"></a>6.2.2推送本地分支到远程仓库</h4><p><code>git push 别名 分支</code>  推送本地分支上的内容到远程仓库，如果没有起别名，使用远程地址代替也可以</p>
<p>现在将本地仓库上的master分支推动到远程仓库上：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211234239729.png" alt="image-20221211234239729" style="zoom:67%;" />

<p>在远程仓库上查看，已经成功推送文件：</p>
<p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211234655576.png" alt="image-20221211234655576"></p>
<blockquote>
<p>2021年8月13日起，Github不再支持使用密码push，即不再接受帐户密码登录，下面这个push方法过时了：</p>
</blockquote>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211233106729.png" alt="image-20221211233106729" style="zoom:67%;" />

<h4 id="6-2-3拉取远程库到本地库"><a href="#6-2-3拉取远程库到本地库" class="headerlink" title="6.2.3拉取远程库到本地库"></a>6.2.3拉取远程库到本地库</h4><p><code>git pull 远程库地址别名 远程分支名</code>  将远程仓库对于分支最新内容拉下来后与当前本地分支<strong>直接合并</strong></p>
<p>有时候远程仓库上的代码进行了更新，我们需要将新的代码下载到本地仓库里：</p>
<p>可以使用别名或者直接使用远程仓库进行拉取</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221211235731470.png" alt="image-20221211235731470" style="zoom:67%;" />

<p>这时查看本地文件的状态，发现工作树干净的，说明拉取动作会自动帮你提交本地库：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212000107413.png" alt="image-20221212000107413" style="zoom:67%;" />

<h4 id="6-2-4克隆远程仓库到本地"><a href="#6-2-4克隆远程仓库到本地" class="headerlink" title="6.2.4克隆远程仓库到本地"></a>6.2.4克隆远程仓库到本地</h4><p><code>git clone 远程地址</code>  将远程仓库的内容克隆到本地</p>
<p>在远程仓库上复制链接：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212001026285.png" alt="image-20221212001026285" style="zoom:67%;" />

<p>在本地新建一个空白文件夹git-demo-second，在该文件夹中右键点击git bash here，打开git命令面板，使用克隆命令将远程仓库克隆到本地：</p>
<blockquote>
<p>克隆公共仓库的代码不需要登录</p>
</blockquote>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212001206908.png" alt="image-20221212001206908" style="zoom:67%;" />

<p>克隆成功之后可以发现在git-demo-second目录下，已经成功下载了git-demo仓库的代码：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212001439777.png" alt="image-20221212001439777" style="zoom:67%;" />

<p>打开文件夹，不仅可以看到代码文件，还能看到.git隐藏文件：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212001608421.png" alt="image-20221212001608421" style="zoom:67%;" />

<p>这说明克隆clone会做如下操作：</p>
<ol>
<li>拉取代码</li>
<li>初始化本地仓库</li>
<li>创建别名（创建的别名默认为origin，如下：）</li>
</ol>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212001854036.png" alt="image-20221212001854036" style="zoom:67%;" />

<h3 id="6-3团队内协作"><a href="#6-3团队内协作" class="headerlink" title="6.3团队内协作"></a>6.3团队内协作</h3><h4 id="6-3-1选择邀请合作者"><a href="#6-3-1选择邀请合作者" class="headerlink" title="6.3.1选择邀请合作者"></a>6.3.1选择邀请合作者</h4><p>如果他人想要推送代码到你的仓库，获取你想要推送代码到他人的仓库，必须得到仓库所有者的许可权限，即仓库所有者拉取他人才能进入团队协作。</p>
<p>仓库拥有者操作：</p>
<p>仓库settings–Collaborators–Add people</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212003542826.png" alt="image-20221212003542826" style="zoom:60%;" />

<p>输入拉取者的账户名称，选择后点击下方按钮：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212004208595.png" alt="image-20221212004208595" style="zoom:50%;" />

<p>复制邀请链接Pending Invite，发送给被邀请者：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212004259379.png" alt="image-20221212004259379" style="zoom:60%;" />

<p>被邀请者登录自己的github账号，登录后在浏览器地址栏中粘贴邀请链接，回车：</p>
<p>如下所示，被邀请者点击Accept invitation即可加入团队。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212004813866.png" alt="image-20221212004813866" style="zoom: 60%;" />

<p>点击Accept invitation后会自动跳转到加入的仓库界面：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212005037737.png" alt="image-20221212005037737" style="zoom:64%;" />

<p>加入的合作者可以在自己的本地上直接推送代码到远程仓库中。</p>
<h4 id="6-3-2跨团队协作"><a href="#6-3-2跨团队协作" class="headerlink" title="6.3.2跨团队协作"></a>6.3.2跨团队协作</h4><p>非团队内的人可以点击fork，将他人的仓库复制到自己的账户下，之后就可以对代码进行修改了。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212010135282.png" alt="image-20221212010135282" style="zoom:67%;" />

<p>修改完之后如果要把代码提交到他人的仓库下，要到别人的仓库下点击new pull request：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212010627051.png" alt="image-20221212010627051" style="zoom:60%;" />

<p>点击完之后会自动将你修改的代码展示出来，与作者的代码进行对比：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212010809078.png" alt="image-20221212010809078" style="zoom:60%;" />

<p>点击上一步的Create pull request后会创建一个拉取请求，可以在这里填写你的提交留言，点击提交，等待作者审批。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212011152845.png" alt="image-20221212011152845" style="zoom:60%;" />

<hr>
<p>仓库所有者可以在仓库的Pull request界面看到别人提交的pull request</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212011646407.png" alt="image-20221212011646407" style="zoom:67%;" />

<p>点击上一步的pull request标题即可查看提交详情：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212011826713.png" alt="image-20221212011826713" style="zoom:60%;" />

<p>点击留言下方的链接可查看别人提交的代码：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212011946432.png" alt="image-20221212011946432" style="zoom:60%;" />

<p>也可以给提交者留言(Write)：</p>
<p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212012319262.png" alt="image-20221212012319262"></p>
<p>或者合并别人提交的代码(Merge pull request)：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212012727389.png" alt="image-20221212012727389" style="zoom: 67%;" />

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212012808702.png" alt="image-20221212012808702" style="zoom: 67%;" />

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212012901910.png" alt="image-20221212012901910" style="zoom: 80%;" />

<h3 id="6-4SSH免密登录"><a href="#6-4SSH免密登录" class="headerlink" title="6.4SSH免密登录"></a>6.4SSH免密登录</h3><p>想要使用ssh免密登录，首先要添加秘钥。</p>
<p>在本地电脑的用户目录下有一个.ssh目录（第一次安装git的用户可能没有该目录，或者打开该目录是空的）</p>
<p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212013250386.png" alt="image-20221212013250386" style="zoom:67%;" /> <img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212013346468.png" alt="image-20221212013346468" style="zoom:67%;" /></p>
<p>在git命令窗口中，运行命令生成.ssh 秘钥目录：<code>ssh-keygen -t rsa -C 你的邮箱</code></p>
<blockquote>
<p>这里的邮箱是你注册github账号的邮箱</p>
</blockquote>
<p>连续三次回车即可：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212013936873.png" alt="image-20221212013936873" style="zoom: 80%;" />

<p>这时再次打开.ssh目录，可以发现该目录下已经创建了两个文件：</p>
<p>打开id_rsa.pub，全选复制里面的内容</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212014130291.png" alt="image-20221212014130291" style="zoom:80%;" />

<p>打开之前邮箱对应的账号：点击账号头像–下拉点击Settings–在设置页面选择SSH and GPG keys</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212014832102.png" alt="image-20221212014832102" style="zoom:67%;" />

<p>点击右上方的New SSH key，将之前复制的内容粘贴到框中，添加title，点击Add SSH key即可添加成功：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212015225672.png" alt="image-20221212015225672" style="zoom: 67%;" />

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212015309531.png" alt="image-20221212015309531" style="zoom:67%;" />

<hr>
<p>SSH的使用1：</p>
<p>之后就可以在本地使用SSH链接拉取仓库</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212015603581.png" alt="image-20221212015603581" style="zoom:67%;" />

<p>第一次使用ssh的时候会提示是否继续链接，填写yes，回车：</p>
<p>显示成功拉取远程仓库代码</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212015736835.png" alt="image-20221212015736835" style="zoom:67%;" />

<p>使用2：可以使用ssh免密推送代码到远程仓库</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221212020808323.png" alt="image-20221212020808323" style="zoom:67%;" />



<h2 id="7-IDEA集成git"><a href="#7-IDEA集成git" class="headerlink" title="7.IDEA集成git"></a>7.IDEA集成git</h2><h3 id="7-1配置git忽略文件"><a href="#7-1配置git忽略文件" class="headerlink" title="7.1配置git忽略文件"></a>7.1配置git忽略文件</h3><ul>
<li><p>为什么要忽略他们？<br>答：与项目的实际功能无关，不参与服务器上部署运行。把它们忽略掉能够屏蔽 IDE 工具之间的差异。</p>
</li>
<li><p>怎么忽略？<br>1）创建忽略规则文件 xxxx.ignore（前缀名随便起，建议是 git.ignore），这个文件的存放位置原则上在哪里都可以，为了便于让~&#x2F;.gitconfig 文件引用，建议也放在用户home目录下</p>
<p>git.ignore 文件模版内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line">#virtual machine crash logs,see http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">target</span><br><span class="line">.idea</span><br><span class="line">*.iml</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/01/14/23-56-00/</url>
    <content><![CDATA[<h2 id="1-git和github是什么"><a href="#1-git和github是什么" class="headerlink" title="1.git和github是什么"></a>1.git和github是什么</h2><p>git是一个版本控制软件，而github是基于Git，用于托管Git上面的仓库的一个网站。</p>
<ol>
<li><p>Git版本控制系统可以帮你保存文件的所有修改记录，并使用版本号进行区分。你可以随时浏览历史版本，将改错的文件还原到指定的版本，还可以对比不同的版本的文件差异，起到恢复和保护的作用。</p>
</li>
<li><p>GitHub是主流的代码托管平台，可以理解为一个存放和管理代码的网盘。大家可以把自己的代码传上去进行共享和维护，当然也可以从平台下载代码</p>
</li>
<li><p>注意，git是开源软件，任何人都可以使用没有风险，但github是运行git的商业托管服务，不是开源的，不要混淆</p>
</li>
</ol>
<h2 id="2-github基本使用"><a href="#2-github基本使用" class="headerlink" title="2.github基本使用"></a>2.github基本使用</h2><h3 id="2-1创建Repository"><a href="#2-1创建Repository" class="headerlink" title="2.1创建Repository"></a>2.1创建Repository</h3><blockquote>
<p>github网址：<a href="https://github.com/">GitHub</a></p>
</blockquote>
<ol>
<li><p>注册登录账号，点击账号页面</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130184900892.png" alt="image-20221130184900892" style="zoom:67%;" />

<span id="more"></span>
</li>
<li><p>点击页面右上方的+号，选择new repository，创建新项目</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130203615053.png" alt="image-20221130203615053" style="zoom:67%;" />
</li>
<li><p>在repository name中填写你的仓库名</p>
<p>注意：仓库名不支持中文，所有的中文符号会被自动识别为<code>-</code>符号。</p>
</li>
<li><p>填写项目简介，简介支持中文</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130204103838.png" alt="image-20221130204103838" style="zoom:60%;" />
</li>
<li><p>点击add a readme file选项，项目会自动创建一个readme文件</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130204415065.png" alt="image-20221130204415065" style="zoom:67%;" />
</li>
<li><p>其他的选项默认即可</p>
</li>
<li><p>最后点击按钮创建</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130204525444.png" alt="image-20221130204525444" style="zoom:67%;" />
</li>
<li><p>页面右上方的三个选项分别表示：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130215334019.png" alt="image-20221130215334019" style="zoom:67%;" />

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130215349172.png" alt="image-20221130215349172" style="zoom:50%;" /></li>
</ol>
<h3 id="2-2上传文件"><a href="#2-2上传文件" class="headerlink" title="2.2上传文件"></a>2.2上传文件</h3><ol>
<li><p>创建repository，点击add file，选择upload files</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130204828980.png" alt="image-20221130204828980" style="zoom:67%;" />
</li>
<li><p>把需要上传的文件直接拖到上传框中</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130205127569.png" alt="image-20221130205127569" style="zoom:67%;" />
</li>
<li><p>上传完毕之后，点击最下面的commit change即可</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130205321841.png" alt="image-20221130205321841" style="zoom:67%;" /></li>
</ol>
<h3 id="2-3在线修改文件"><a href="#2-3在线修改文件" class="headerlink" title="2.3在线修改文件"></a>2.3在线修改文件</h3><ol>
<li><p>点开一个文件</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130205604883.png" alt="image-20221130205604883" style="zoom:67%;" />
</li>
<li><p>点击文件显示页面右上方的编辑按钮</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130205735509.png" alt="image-20221130205735509" style="zoom:67%;" />
</li>
<li><p>修改文件</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130205851219.png" alt="image-20221130205851219" style="zoom:67%;" />
</li>
<li><p>在下方的commit change点击保存更改</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130210014693.png" alt="image-20221130210014693" style="zoom:67%;" /></li>
</ol>
<h3 id="2-4话题互动-Issues"><a href="#2-4话题互动-Issues" class="headerlink" title="2.4话题互动-Issues"></a>2.4话题互动-Issues</h3><ul>
<li>在别人的项目中留言</li>
</ul>
<ol>
<li><p>点击项目页面上方的issues按钮，点击右边的new issue</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130210612892.png" alt="image-20221130210612892" style="zoom:67%;" />
</li>
<li><p>在留言框中填写你的标题，留言正文，点击submit new issue即可提交新的话题</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130210758651.png" alt="image-20221130210758651" style="zoom:67%;" />
</li>
<li><p>作者就能看到你的话题留言了</p>
</li>
<li><p>也可以直接选择其他人的话题，在该话题中进行留言</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130212336430.png" alt="image-20221130212336430" style="zoom:67%;" />

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130212206040.png" alt="image-20221130212206040" style="zoom:67%;" /></li>
</ol>
<ul>
<li><p>自己的项目中留言</p>
<p>在自己的项目中，可以自己发起话题，可以在别人发起的话题中留言，也可以选择close with comment，关闭他人或自己发起的话题。</p>
</li>
</ul>
<h3 id="2-4下载别人的代码"><a href="#2-4下载别人的代码" class="headerlink" title="2.4下载别人的代码"></a>2.4下载别人的代码</h3><ol>
<li><p>点击进入他人的项目页面</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130201825193.png" alt="image-20221130201825193" style="zoom:80%;" />
</li>
<li><p>点击右上方的code按钮</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130202121452.png" alt="image-20221130202121452" style="zoom:60%;" />
</li>
<li><p>下载完毕，在下载文件夹中找到该文件并解压，即可得到源码。</p>
<blockquote>
<p>项目中扩展名为md的文件是以纯文本格式存储的，用记事本一样可以凑活着看</p>
</blockquote>
</li>
<li><p>如果你还想看看这个作者有别的项目，可以点击源码区上方的头像，来到作者的主页</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130202815732.png" alt="image-20221130202815732" style="zoom:67%;" />
</li>
<li><p>在作者主页点击repository，显示作者的所有项目</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221130203410784.png" alt="image-20221130203410784" style="zoom:80%;" /></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/01/14/23-56-00/</url>
    <content><![CDATA[<h1 id="主要"><a href="#主要" class="headerlink" title="主要"></a>主要</h1><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="Git-Branch"><a href="#Git-Branch" class="headerlink" title="Git Branch"></a>Git Branch</h3><p>Git 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。所以许多 Git 爱好者传颂：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">早建分支！多用分支！</span><br></pre></td></tr></table></figure>

<p>这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p>
<p>在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“我想基于这个提交以及它所有的父提交进行新的工作。”</p>
<p>咱们通过实际操作来看看分支是什么样子的。</p>
<p>接下来，我们将要创建一个到名为 <code>newImage</code> 的分支。</p>
<p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222020812463.png" alt="image-20221222020812463" style="zoom:67%;" /> <code>git branch newImage</code><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222020826638.png" alt="image-20221222020826638" style="zoom:67%;" /></p>
<p>看到了吗，创建分支就是这么容易！新创建的分支 <code>newImage</code> 指向的是提交记录 <code>C1</code>。</p>
<span id="more"></span>

<p>现在咱们试着往新分支里提交一些东西。点击下面的按钮</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222020914464.png" alt="image-20221222020914464" style="zoom:67%;" />

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222020932215.png" alt="image-20221222020932215" style="zoom:67%;" />

<p>哎呀！为什么 <code>main</code> 分支前进了，但 <code>newImage</code> 分支还待在原地呢？！这是因为我们没有“在”这个新分支上，看到 <code>main</code> 分支上的那个星号（*）了吗？这表示当前所在的分支是 <code>main</code>。</p>
<p>现在重来，咱们告诉 Git 我们想要切换到新的分支上：<code>git checkout &lt;name&gt;</code></p>
<p>下面的命令会让我们在提交修改之前先切换到新的分支上:</p>
<p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222021038299.png" alt="image-20221222021038299" style="zoom:67%;" /> <code>git checkout newImage;git commit</code><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222021105446.png" alt="image-20221222021105446" style="zoom:67%;" /></p>
<p>这就对了！我们的修改已经保存到新的分支里了。</p>
<blockquote>
<p>注意：在 Git 2.23 版本中，引入了一个名为 <code>git switch</code> 的新命令，最终会取代 <code>git checkout</code>，因为 <code>checkout</code> 作为单个命令有点超载（它承载了很多独立的功能）。 由于现在很多人还无法使用 <code>switch</code>，本次课程仍然使用 <code>checkout</code> 而不是 <code>switch</code>， 但是如果你想尝试一下新命令，我们的应用也是支持的！并且你可以从<a href="https://git-scm.com/docs/git-switch">这里</a>学到更多关于新命令的内容。</p>
</blockquote>
<p>对了，有个更简洁的方式：</p>
<p>如果你想创建一个新的分支同时切换到新创建的分支的话，可以通过 </p>
<p><code>git checkout -b &lt;your-branch-name&gt;</code> 来实现。</p>
<h3 id="Git-Rebase"><a href="#Git-Rebase" class="headerlink" title="Git Rebase"></a>Git Rebase</h3><h4 id="原理理解"><a href="#原理理解" class="headerlink" title="原理理解"></a>原理理解</h4><blockquote>
<p><a href="https://www.cnblogs.com/michael-xiang/p/13179837.html">图解 Git 基本命令 merge 和 rebase - Michael翔 - 博客园 (cnblogs.com)</a></p>
<p><code>rebase</code> 合并往往又被称为 「变基」.这里的「基」就是一个「基点」、「起点」的意思。「变基」就是改变当前分支的起点。<strong>注意，是当前分支！</strong> <code>rebase</code> 命令后面紧接着的就是「基分支」。</p>
</blockquote>
<p><strong>官方原文解释</strong>：当执行rebase操作时，git会从两个分支的共同祖先开始提取待变基分支上的修改，然后将待变基分支指向基分支的最新提交，最后将刚才提取的修改应用到基分支的最新提交的后面。</p>
<p>变基前：</p>
<p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/RQ39Rv.png" alt="分叉"></p>
<p><code>git reabse master feature</code> 变基后：</p>
<p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/HepjTM.png" alt="变基后"></p>
<h4 id="rebase-总结"><a href="#rebase-总结" class="headerlink" title="rebase 总结"></a>rebase 总结</h4><p><code>rebase</code> 命令其实关键在于理解「基」，<code>git rebase &lt;基分支&gt;</code>，就是将当前基分支与当前分支的差异提交获取到，然后在「基分支」最新提交点后面将差异提交逐个再次提交，最后将当前分支的 HEAD 指针指向最新的提交点。</p>
<p>「基分支」的 HEAD 位置是不变的。要想完成分支合并，完成变基之后，需要再进行分支间的合并等操作。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>第二种合并分支的方法是 <code>git rebase</code>。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p>
<p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p>
<p>咱们还是实际操作一下吧……</p>
<p>还是准备了两个分支；注意当前所在的分支是 bugFix（星号标识的是当前分支）</p>
<p>我们想要把 bugFix 分支里的工作直接移到 main 分支上。移动以后会使得两个分支的功能看起来像是按顺序开发，但实际上它们是并行开发的。</p>
<p>咱们这次用 <code>git rebase</code> 实现此目标</p>
<p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222014212999.png" alt="image-20221222014212999" style="zoom: 55%;" /> <code>git rebase main</code><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222014311313.png" alt="image-20221222014311313" style="zoom:60%;" /></p>
<p>怎么样？！现在 bugFix 分支上的工作在 main 的最顶端，同时我们也得到了一个更线性的提交序列。</p>
<p>注意，提交记录 C3 依然存在（树上那个半透明的节点），而 C3’ 是我们 Rebase 到 main 分支上的 C3 的副本。</p>
<p>现在唯一的问题就是 main 还没有更新，下面咱们就来更新它吧……</p>
<p>现在我们切换到了 <code>main</code> 上。把它 rebase 到 <code>bugFix</code> 分支上……</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222014553962.png" alt="image-20221222014553962" style="zoom:67%;" />

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222014723842.png" alt="image-20221222014723842" style="zoom:67%;" />

<p>好了！由于 <code>bugFix</code> 继承自 <code>main</code>，所以 Git 只是简单的把 <code>main</code> 分支的引用向前移动了一下而已。</p>
<h2 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h2><h3 id="分离HEAD"><a href="#分离HEAD" class="headerlink" title="分离HEAD"></a>分离HEAD</h3><p>在接触 Git 更高级功能之前，我们有必要先学习在你项目的提交树上前后移动的几种方法。一旦熟悉了如何在 Git 提交树上移动，你驾驭其它命令的能力也将水涨船高！</p>
<ul>
<li>HEAD</li>
</ul>
<p>我们首先看一下 “HEAD”。 HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。</p>
<p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。</p>
<p>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p>
<p>下面咱们通过实际操作看一下。我们将会观察提交前后 HEAD 的位置。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222195956499.png" alt="image-20221222195956499" style="zoom:67%;" />

<p><code>git checkout C1 ; git checkout main ; git commit ; git checkout C2</code></p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222200049793.png" alt="image-20221222200049793" style="zoom:67%;" />

<p>看到了吗？ HEAD 指向了 <code>main</code>，随着提交向前移动。</p>
<ul>
<li>分离的 HEAD</li>
</ul>
<p>分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。在命令执行之前的状态如下所示：</p>
<p>HEAD -&gt; main -&gt; C1</p>
<p>HEAD 指向 main， main 指向 C1：</p>
<p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222195956499.png" alt="image-20221222195956499" style="zoom:67%;" /> <code>git checkout C1</code><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222200302145.png" alt="image-20221222200302145" style="zoom:67%;" /></p>
<p>现在变成了</p>
<p>HEAD -&gt; C1</p>
<h3 id="相对引用-和-num"><a href="#相对引用-和-num" class="headerlink" title="相对引用 ^和~[num]"></a>相对引用 ^和~[num]</h3><h4 id="符号"><a href="#符号" class="headerlink" title="^ 符号"></a>^ 符号</h4><p>通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 <code>git log</code> 来查查看提交记录的哈希值。</p>
<p>并且哈希值在真实的 Git 世界中也会更长（译者注：基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是 <code>fed2da64c0efc5293610bdd892f82a58e8cbc5d8</code>。舌头都快打结了吧…</p>
<p>比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入<code>fed2</code> 而不是上面的一长串字符。</p>
<p>正如我前面所说，通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。这个就很厉害了!</p>
<p>使用相对引用的话，你就可以从一个易于记忆的地方（比如 <code>bugFix</code> 分支或 <code>HEAD</code>）开始计算。</p>
<p>相对引用非常给力，这里我介绍两个简单的用法：</p>
<ul>
<li>使用 <code>^</code> 向上移动 1 个提交记录</li>
<li>使用 <code>~&lt;num&gt;</code> 向上移动多个提交记录，如 <code>~3</code></li>
</ul>
<h3 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h3><p>git reset 和 git revert</p>
<h2 id="移动提交记录"><a href="#移动提交记录" class="headerlink" title="移动提交记录"></a>移动提交记录</h2><h3 id="整理提交记录-gitcherry-pick"><a href="#整理提交记录-gitcherry-pick" class="headerlink" title="整理提交记录 gitcherry-pick"></a>整理提交记录 gitcherry-pick</h3><p>git cherry-pick</p>
<p>命令形式为:</p>
<p><code>git cherry-pick &lt;提交号1&gt; &lt;提交号2&gt; ...</code></p>
<p>如果你想将一些提交复制到当前所在的位置（<code>HEAD</code>）下面的话， Cherry-pick 是最直接的方式了。</p>
<h3 id="交互式的-rebase"><a href="#交互式的-rebase" class="headerlink" title="交互式的 rebase"></a>交互式的 rebase</h3><p>当你知道你所需要的提交记录（<strong>并且</strong>还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。</p>
<p>但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了</p>
<p>交互式 rebase 指的是使用带参数 <code>--interactive</code> 的 rebase 命令, 简写为 <code>-i</code></p>
<p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p>
<p>在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。 考虑到课程的初衷，我弄了一个对话框来模拟这些操作。</p>
<p>当 rebase UI界面打开时, 你能做3件事:</p>
<ul>
<li>调整提交记录的顺序（通过鼠标拖放来完成）</li>
<li>删除你不想要的提交（通过切换 <code>pick</code> 的状态来完成，关闭就意味着你不想要这个提交记录）</li>
<li>合并提交。 遗憾的是由于某种逻辑的原因，我们的课程不支持此功能，因此我不会详细介绍这个操作。简而言之，它允许你把多个提交记录合并成一个。</li>
</ul>
<p>接下来咱们看个实例：当你点击下面的按钮时，会出现一个交互对话框。对提交记录做个排序（当然你也可以删除某些提交），点击确定看结果</p>
<p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222015129265.png" alt="image-20221222015129265" style="zoom:67%;" /> <img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222015135920.png" alt="image-20221222015135920" style="zoom:67%;" /></p>
<p>在ui中进行的操作：省略记录C3，C4，将C2，C5顺序调整如下，点击confirm</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222015224620.png" alt="image-20221222015224620" style="zoom:50%;" />

<p>结果：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222015431517.png" alt="image-20221222015431517" style="zoom:67%;" />

<p>个人理解：<code>git rebase main</code> 意为复制当前提交记录（HEAD指向的记录），作为main基分支的新记录；<code>git rebase -i HEAD~4</code>的意思就是，将从HEAD指向的记录到基分支HEAD<del>4指向的记录，复制为HEAD</del>4所指的提交记录的新记录（顺序和数量在ui中自由调整）</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="本地栈式提交"><a href="#本地栈式提交" class="headerlink" title="本地栈式提交"></a>本地栈式提交</h3><p>来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。</p>
<p>这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！</p>
<p>最后就差把 <code>bugFix</code> 分支里的工作合并回 <code>main</code> 分支了。你可以选择通过 fast-forward 快速合并到 <code>main</code> 分支上，但这样的话 <code>main</code> 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……</p>
<p>实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用</p>
<ul>
<li><code>git rebase -i</code></li>
<li><code>git cherry-pick</code></li>
</ul>
<p>来达到目的。</p>
<h3 id="提交的技巧-1"><a href="#提交的技巧-1" class="headerlink" title="提交的技巧 #1"></a>提交的技巧 #1</h3><p>接下来这种情况也是很常见的：你之前在 <code>newImage</code> 分支上进行了一次提交，然后又基于它创建了 <code>caption</code> 分支，然后又提交了一次。</p>
<p>此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 <code>newImage</code> 中图片的分辨率，尽管那个提交记录并不是最新的了。</p>
<p>我们可以通过下面的方法来克服困难：</p>
<ul>
<li>先用 <code>git rebase -i</code> 将提交重新排序，然后把我们想要修改的提交记录挪到最前</li>
<li>然后用 <code>git commit --amend</code> 来进行一些小修改</li>
<li>接着再用 <code>git rebase -i</code> 来将他们调回原来的顺序</li>
<li>最后我们把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！</li>
</ul>
<p>当然完成这个任务的方法不止上面提到的一种（我知道你在看 cherry-pick 啦），之后我们会多点关注这些技巧啦，但现在暂时只专注上面这种方法。 最后有必要说明一下目标状态中的那几个<code>&#39;</code> —— 我们把这个提交移动了两次，每移动一次会产生一个 <code>&#39;</code>；而 C2 上多出来的那个是我们在使用了 amend 参数提交时产生的，所以最终结果就是这样了。</p>
<p>也就是说，我在对比结果的时候只会对比提交树的结构，对于 <code>&#39;</code> 的数量上的不同，并不纳入对比范围内。只要你的 <code>main</code> 分支结构与目标结构相同，我就算你通过</p>
<h3 id="提交的技巧-2"><a href="#提交的技巧-2" class="headerlink" title="提交的技巧 #2"></a>提交的技巧 #2</h3><p>正如你在上一关所见到的，我们可以使用 <code>rebase -i</code> 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 <code>--amend</code> 修改它，然后把它们重新排成我们想要的顺序。</p>
<p>但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。下面还是看看 <code>git cherry-pick</code> 是怎么做的吧。</p>
<p>要在心里牢记 cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上（只要不是 HEAD 上游的提交就没问题）。来看看这个例子：</p>
<p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222022945739.png" alt="image-20221222022945739" style="zoom:67%;" /> <code>git cherry-pick C2</code><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222023002305.png" alt="image-20221222023002305" style="zoom:67%;" /></p>
<h3 id="Git-Tags"><a href="#Git-Tags" class="headerlink" title="Git Tags"></a>Git Tags</h3><p>相信通过前面课程的学习你已经发现了：分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。</p>
<p>你可能会问了：有没有什么可以<em>永远</em>指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？</p>
<p>当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。</p>
<p>更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>
<p>咱们来看看标签到底是什么样。</p>
<h3 id="Git-Describe"><a href="#Git-Describe" class="headerlink" title="Git Describe"></a>Git Describe</h3><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你<strong>最近</strong>的锚点（也就是标签），它就是 <code>git describe</code>！</p>
<p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 <code>git bisect</code>（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。</p>
<p><code>git describe</code> 的语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git describe &lt;ref&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;ref&gt;</code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（<code>HEAD</code>）。</p>
<p>它输出的结果是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</span><br></pre></td></tr></table></figure>

<p><code>tag</code> 表示的是离 <code>ref</code> 最近的标签， <code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录， <code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。</p>
<p>当 <code>ref</code> 提交记录上有某个标签时，则只输出标签名称</p>
<p>让我们来看一个例子，对于下面的提交树：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221221021602959.png" alt="image-20221221021602959" style="zoom:70%;" />

<p><code>git describe main</code> 会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v1_2_gC2</span><br></pre></td></tr></table></figure>

<p><code>git describe side</code> 会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v2_1_gC4</span><br></pre></td></tr></table></figure>

<h2 id="高级话题"><a href="#高级话题" class="headerlink" title="高级话题"></a>高级话题</h2><h3 id="多次-rebase"><a href="#多次-rebase" class="headerlink" title="多次 rebase"></a>多次 rebase</h3><p>哥们儿，我们准备了很多分支！咱们把这些分支 rebase 到 main 上吧。</p>
<p>但是你的领导给你提了点要求 —— 他们希望得到有序的提交历史，也就是我们最终的结果应该是 <code>C6&#39;</code> 在 <code>C7&#39;</code> 上面， <code>C5&#39;</code> 在 <code>C6&#39;</code> 上面，依此类推。</p>
<p>即使你搞砸了也没关系，用 <code>reset</code> 命令就可以重新开始了。记得看看我们提供的答案，看你能否使用更少的命令来完成任务！</p>
<h3 id="两个父节点"><a href="#两个父节点" class="headerlink" title="两个父节点"></a>两个父节点</h3><p>操作符 <code>^</code> 与 <code>~</code> 符一样，后面也可以跟一个数字。</p>
<p>但是该操作符后面的数字与 <code>~</code> 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</p>
<p>Git 默认选择合并提交的“第一个”父提交，在操作符 <code>^</code> 后跟一个数字可以改变这一默认行为。</p>
<p>废话不多说，举个例子。</p>
<p>这里有一个合并提交记录。如果不加数字修改符直接检出 <code>main^</code>，会回到第一个父提交记录。</p>
<p>(<em>在我们的图示中，第一个父提交记录是指合并提交记录正上方的那个提交记录。</em>)</p>
<p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222192924500.png" alt="image-20221222192924500" style="zoom:67%;" /> 使用<code>git checkout main^</code>后<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222193020089.png" alt="image-20221222193020089" style="zoom:67%;" /></p>
<p>现在来试试选择另一个父提交……</p>
<p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222192924500.png" alt="image-20221222192924500" style="zoom:67%;" /> 使用<code>git checkout main^2</code>后<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222193118680.png" alt="image-20221222193118680" style="zoom:67%;" /></p>
<p>看见了吧？我们回到了另外一个父提交上</p>
<p>使用 <code>^</code> 和 <code>~</code> 可以自由地在提交树中移动，非常给力：</p>
<p>更厉害的是，这些操作符还支持链式操作！</p>
<p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222193211736.png" alt="image-20221222193211736" style="zoom:67%;" /> 使用<code>git checkout HEAD~^2~2</code>后<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222193422440.png" alt="image-20221222193422440" style="zoom:60%;" /></p>
<h1 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h1><h2 id="Push-amp-Pull——Git-远程仓库"><a href="#Push-amp-Pull——Git-远程仓库" class="headerlink" title="Push&amp;Pull——Git 远程仓库"></a>Push&amp;Pull——Git 远程仓库</h2><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><ul>
<li>远程仓库</li>
</ul>
<p>远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录</p>
<p>话虽如此, 远程仓库却有一系列强大的特性</p>
<ul>
<li>首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。</li>
<li>还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更)</li>
</ul>
<p>现在用网站来对远程仓库进行可视化操作变得越发流行了(像 <a href="https://github.com/">GitHub</a>), 但远程仓库<strong>永远</strong>是这些工具的顶梁柱, 因此理解其概念非常的重要!</p>
<p>我们现在需要学习远程仓库的操作 —— 我们需要一个配置这种环境的命令, 它就是 <code>git clone</code>。 从技术上来讲，<code>git clone</code> 命令在真实的环境下的作用是在<strong>本地</strong>创建一个远程仓库的拷贝（比如从 github.com）</p>
<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><p>既然你已经看过 <code>git clone</code> 命令了，咱们深入地看一下发生了什么。</p>
<p>你可能注意到的第一个事就是在我们的本地仓库多了一个名为 <code>o/main</code> 的分支, 这种类型的分支就叫<strong>远程分支</strong>。由于远程分支的特性导致其拥有一些特殊属性。</p>
<p>远程分支反映了远程仓库(在你上次和它通信时)的<strong>状态</strong>。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.</p>
<p>远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p>
<ul>
<li>为什么有 <code>o/</code>？</li>
</ul>
<p>你可能想问这些远程分支的前面的 <code>o/</code> 是什么意思呢？好吧, 远程分支有一个命名规范 —— 它们的格式是:</p>
<p><code>&lt;remote name&gt;/&lt;branch name&gt;</code></p>
<p>因此，如果你看到一个名为 <code>o/main</code> 的分支，那么这个分支就叫 <code>main</code>，远程仓库的名称就是 <code>o</code>。</p>
<p>大多数的开发人员会将它们主要的远程仓库命名为 <code>origin</code>，并不是 <code>o</code>。这是因为当你用 <code>git clone</code> 某个仓库时，Git 已经帮你把远程仓库的名称设置为 <code>origin</code> 了</p>
<p>不过 <code>origin</code> 对于我们的 UI 来说太长了，因此不得不使用简写 <code>o</code> :) 但是要记住, 当你使用真正的 Git 时, 你的远程仓库默认为 <code>origin</code>!</p>
<p>说了这么多，让我们看看实例。</p>
<p>如果检出远程分支会怎么样呢？（注：虚线的是远程仓库）</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222202151997.png" alt="image-20221222202151997" style="zoom:67%;" />

<p><code>git checkout o/mian;git commit</code></p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222202251909.png" alt="image-20221222202251896" style="zoom:67%;" />

<p>正如你所见，Git 变成了分离 HEAD 状态，当添加新的提交时 <code>o/main</code> 也不会更新。这是因为 <code>o/main</code> 只有在远程仓库中相应的分支更新了以后才会更新。</p>
<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。</p>
<p>本节课我们将学习如何从远程仓库获取数据 —— 命令如其名，它就是 <code>git fetch</code>。</p>
<p>你会看到当我们从远程仓库获取数据时, 远程分支也会更新以反映最新的远程仓库。在上一节课程中我们已经提及过这一点了。</p>
<p>在解释 <code>git fetch</code> 前，我们先看看实例。这里我们有一个远程仓库, 它有两个我们本地仓库中没有的提交。</p>
<p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222202555552.png" alt="image-20221222202555552" style="zoom:60%;" /> <code>git fetch</code><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222202738220.png" alt="image-20221222202738220" style="zoom:67%;" /></p>
<p>就是这样了! <code>C2</code>,<code>C3</code> 被下载到了本地仓库，同时远程分支 <code>o/main</code> 也被更新，反映到了这一变化</p>
<ul>
<li>git fetch 做了些什么</li>
</ul>
<p><code>git fetch</code> 完成了仅有的但是很重要的两步:</p>
<ol>
<li>从远程仓库下载本地仓库中缺失的提交记录</li>
<li>更新远程分支指针(如 <code>o/main</code>)</li>
</ol>
<p><code>git fetch</code> 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。</p>
<p>如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你<strong>最后一次与它通信时</strong>的状态，<code>git fetch</code> 就是你与远程仓库通信的方式了！希望我说的够明白了，你已经了解 <code>git fetch</code> 与远程分支之间的关系了吧。</p>
<p><code>git fetch</code> 通常通过互联网（使用 <code>http://</code> 或 <code>git://</code> 协议) 与远程仓库通信。</p>
<ul>
<li>git fetch 不会做的事</li>
</ul>
<p><code>git fetch</code> 并不会改变你本地仓库的状态。它不会更新你的 <code>main</code> 分支，也不会修改你磁盘上的文件。</p>
<p>理解这一点很重要，因为许多开发人员误以为执行了 <code>git fetch</code> 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是<strong>并没有</strong>修改你本地的文件。我们在后面的课程中将会讲解能完成该操作的命令 :D</p>
<p>所以, 你可以将 <code>git fetch</code> 的理解为单纯的下载操作。</p>
<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>既然我们已经知道了如何用 <code>git fetch</code> 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。</p>
<p>其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p>
<ul>
<li><code>git cherry-pick o/main</code></li>
<li><code>git rebase o/main</code></li>
<li><code>git merge o/main</code></li>
<li>等等</li>
</ul>
<p>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 <code>git pull</code>。</p>
<p>我们先来看看 <code>fetch</code>、<code>merge</code> 依次执行的效果：</p>
<blockquote>
<p>虚线为远程仓库，o&#x2F;main为远程分支</p>
</blockquote>
<p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222203951010.png" alt="image-20221222203951010" style="zoom:60%;" /> <code>git fetch;git merge o/main</code><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222204130135.png" style="zoom:52%;" /></p>
<p>我们用 <code>fetch</code> 下载了 <code>C3</code>, 然后通过 <code>git merge o/main</code> 合并了这一提交记录。现在我们的 <code>main</code> 分支包含了远程仓库中的更新（在本例中远程仓库名为 <code>origin</code>）</p>
<p>如果使用 <code>git pull</code> 呢?</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222204130135.png" style="zoom:52%;" />

<p>同样的结果！这清楚地说明了 <code>git pull</code> 就是 git fetch 和 git merge 的缩写！</p>
<h3 id="模拟团队合作"><a href="#模拟团队合作" class="headerlink" title="模拟团队合作"></a>模拟团队合作</h3><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>OK，我们已经学过了如何从远程仓库获取更新并合并到本地的分支当中。这非常棒……但是我如何与大家分享<strong>我的</strong>成果呢？</p>
<p>嗯，上传自己分享内容与下载他人的分享刚好相反，那与 <code>git pull</code> 相反的命令是什么呢？<code>git push</code>！</p>
<p><code>git push</code> 负责将<strong>你的</strong>变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 <code>git push</code> 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！</p>
<p>你可以将 <code>git push</code> 想象成发布你成果的命令。它有许多应用技巧，稍后我们会了解到，但是咱们还是先从基础的开始吧……</p>
<p>注意 —— <code>git push</code> 不带任何参数时的行为与 Git 的一个名为 <code>push.default</code> 的配置有关。它的默认值取决于你正使用的 Git 的版本，但是在教程中我们使用的是 <code>upstream</code>。 这没什么太大的影响，但是在你的项目中进行推送之前，最好检查一下这个配置。</p>
<p>这里我们准备了一些远程仓库中没有的提交记录, 咱们开始先上传吧!</p>
<p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222204506335.png" alt="image-20221222204506335" style="zoom:67%;" /> <code>git push</code><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222204538170.png" alt="image-20221222204538170" style="zoom:67%;" /></p>
<p>过去了, 远程仓库接收了 <code>C2</code>，远程仓库中的 <code>main</code> 分支也被更新到指向 <code>C2</code> 了，我们的远程分支 (o&#x2F;main) 也同样被更新了。所有的分支都同步了！</p>
<h3 id="偏离的提交"><a href="#偏离的提交" class="headerlink" title="偏离的提交"></a>偏离的提交</h3><p>现在我们已经知道了如何从其它地方 <code>pull</code> 提交记录，以及如何 <code>push</code> 我们自己的变更。看起来似乎没什么难度，但是为何还会让人们如此困惑呢？</p>
<p>困难来自于远程库提交历史的<strong>偏离</strong>。在讨论这个问题的细节前，我们先来看一个例子……</p>
<p>假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目<strong>旧版</strong>的代码，与远程仓库最新的代码不匹配了。</p>
<p>这种情况下, <code>git push</code> 就不知道该如何操作了。如果你执行 <code>git push</code>，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？</p>
<p>因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 <code>push</code> 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。</p>
<p>说了这么多，咱们还是看看实际案例吧！</p>
<p><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222204756441.png" alt="image-20221222204756441" style="zoom:67%;" /> <code>git push</code><img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222204756441.png" style="zoom:67%;" /></p>
<p>看见了吧？什么都没有变，因为命令失败了！<code>git push</code> 失败是因为你最新提交的 <code>C3</code> 基于远程分支中的 <code>C1</code>。而远程仓库中该分支已经更新到 <code>C2</code> 了，所以 Git 拒绝了你的推送请求。</p>
<p>那该如何解决这个问题呢？很简单，你需要做的就是使你的工作基于最新的远程分支。</p>
<p>有许多方法做到这一点呢，不过最直接的方法就是通过 rebase 调整你的工作。咱们继续，看看怎么 rebase！</p>
<p>如果我们在 push 之前做 rebase 呢？</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222204756441.png" alt="image-20221222204756441" style="zoom:67%;" />

<p> <code>git fetch;git rebase o/main;git push</code></p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222205052497.png" alt="image-20221222205052497" style="zoom:67%;" />

<p>我们用 <code>git fetch</code> 更新了本地仓库中的远程分支，然后用 rebase 将我们的工作移动到最新的提交记录下，最后再用 <code>git push</code> 推送到远程仓库。</p>
<p>还有其它的方法可以在远程仓库变更了以后更新我的工作吗? 当然有，我们还可以使用 <code>merge</code></p>
<p>尽管 <code>git merge</code> 不会移动你的工作（它会创建新的合并提交），但是它会告诉 Git 你已经合并了远程仓库的所有变更。这是因为远程分支现在是你本地分支的祖先，也就是说你的提交已经包含了远程分支的所有变化。</p>
<p>咱们们用 merge 替换 rebase 来试一下……</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222204756441.png" alt="image-20221222204756441" style="zoom:67%;" />

<p><code>git fetch;git merge o/main;git push</code></p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222205316741.png" alt="image-20221222205316741" style="zoom:67%;" />

<p>我们用 <code>git fetch</code> 更新了本地仓库中的远程分支，然后<strong>合并</strong>了新变更到我们的本地分支（为了包含远程仓库的变更），最后我们用 <code>git push</code> 把工作推送到远程仓库</p>
<p>很好！但是要敲那么多命令，有没有更简单一点的？</p>
<p>当然 —— 前面已经介绍过 <code>git pull</code> 就是 fetch 和 merge 的简写，类似的 <code>git pull --rebase</code> 就是 fetch 和 rebase 的简写！</p>
<p>让我们看看简写命令是如何工作的。</p>
<p>这次用 <code>--rebase</code>……</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222204756441.png" alt="image-20221222204756441" style="zoom:67%;" />

<p><code>git pull --rebase;git push</code></p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222205554169.png" alt="image-20221222205554169" style="zoom:60%;" />

<p>跟之前结果一样，但是命令更短了。</p>
<p>换用常规的 <code>pull</code></p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222205316741.png" alt="image-20221222205316741" style="zoom:67%;" />

<p>还是跟以前一样!</p>
<p>由 fetch、rebase&#x2F;merge 和 push 组成的工作流很普遍。后续课程我们会讲解更复杂的工作流</p>
<h3 id="Remote-Rejected"><a href="#Remote-Rejected" class="headerlink" title="Remote Rejected"></a>Remote Rejected</h3><p>远程服务器拒绝!</p>
<p>如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:</p>
<p><code>! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)</code></p>
<ul>
<li>为什么会被拒绝?</li>
</ul>
<p>远程服务器拒绝直接推送(push)提交到main, 因为策略配置要求 pull requests 来提交更新.</p>
<p>你应该按照流程,新建一个分支, 推送(push)这个分支并申请pull request,但是你忘记并直接提交给了main.现在你卡住并且无法推送你的更新.</p>
<ul>
<li>解决办法</li>
</ul>
<p>新建一个分支feature, 推送到远程服务器. 然后reset你的main分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题.</p>
]]></content>
  </entry>
  <entry>
    <title>HelloWorld!</title>
    <url>/2023/01/12/22-29-15/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>hexo博客搭建记录</title>
    <url>/2023/01/12/22-36-04/</url>
    <content><![CDATA[<h1 id="Hexo博客搭建记录"><a href="#Hexo博客搭建记录" class="headerlink" title="Hexo博客搭建记录"></a>Hexo博客搭建记录</h1><blockquote>
<p>参考视频：<a href="https://www.bilibili.com/video/av44544186/?vd_source=7e137c3a1559f85aacb1f151bb0a830d">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程</a></p>
<p>以下命令操作建议使用管理员权限完成</p>
</blockquote>
<h2 id="1-nodejs-amp-hexo-安装"><a href="#1-nodejs-amp-hexo-安装" class="headerlink" title="1. nodejs &amp; hexo 安装"></a>1. nodejs &amp; hexo 安装</h2><p>1.首先下载node.js，并安装（安装node时，会自动安装npm），安装完毕后在控制台输入<code>node -v</code>，如果显示版本则说明安装成功。</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\&gt;node -v</span><br><span class="line">v16.18.1</span><br><span class="line"></span><br><span class="line">D:\&gt;npm -v</span><br><span class="line">8.19.2</span><br></pre></td></tr></table></figure>

<p>2.安装cnpm，命令为<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
<p>（因为这里我已经下过了，所以显示可能不准确）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">npm WARN deprecated @npmcli/move-file@2.0.1: This functionality has been moved to @npmcli/fs</span><br><span class="line"></span><br><span class="line">added 4 packages, removed 6 packages, and changed 415 packages <span class="keyword">in</span> 1m</span><br><span class="line"></span><br><span class="line">11 packages are looking <span class="keyword">for</span> funding</span><br><span class="line">  run `npm fund` <span class="keyword">for</span> details</span><br></pre></td></tr></table></figure>

<p>输入<code>cnpm -v</code>，如果出现下面的字样说明安装cnpm成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\&gt;cnpm -v</span><br><span class="line">cnpm@9.0.1 (D:\apps\nodejs16.18.1\node_global\node_modules\cnpm\lib\parse_argv.js)</span><br><span class="line">npm@8.19.3 (D:\apps\nodejs16.18.1\node_global\node_modules\cnpm\node_modules\npm\index.js)</span><br><span class="line">node@16.18.1 (D:\apps\nodejs16.18.1\node.exe)</span><br><span class="line">npminstall@7.3.1 (D:\apps\nodejs16.18.1\node_global\node_modules\cnpm\node_modules\npminstall\lib\index.js)</span><br><span class="line">prefix=D:\apps\nodejs16.18.1\node_global</span><br><span class="line">win32 x64 10.0.19044</span><br><span class="line">registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>

<p>3.使用cnpm安装hexo，命令<code>cnpm install -g hexo-cli</code>，安装完毕后使用命令<code>hexo -v</code>，如果出现以下字样说明安装hexo成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\&gt;hexo -v</span><br><span class="line">hexo-cli: 4.3.0</span><br><span class="line">os: win32 10.0.19044</span><br><span class="line">node: 16.18.1</span><br><span class="line">v8: 9.4.146.26-node.22</span><br><span class="line">uv: 1.43.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.9</span><br><span class="line">ares: 1.18.1</span><br><span class="line">modules: 93</span><br><span class="line">nghttp2: 1.47.0</span><br><span class="line">napi: 8</span><br><span class="line">llhttp: 6.0.10</span><br><span class="line">openssl: 1.1.1q+quic</span><br><span class="line">cldr: 41.0</span><br><span class="line">icu: 71.1</span><br><span class="line">tz: 2022b</span><br><span class="line">unicode: 14.0</span><br><span class="line">ngtcp2: 0.8.1</span><br><span class="line">nghttp3: 0.7.0</span><br></pre></td></tr></table></figure>

<h2 id="2-使用hexo搭建博客"><a href="#2-使用hexo搭建博客" class="headerlink" title="2.使用hexo搭建博客"></a>2.使用hexo搭建博客</h2><p>1.首先使用命令<code>hexo init &lt;yourBlogName&gt;</code>：创建你的站点目录，并使用hexo初始化该文件夹</p>
<blockquote>
<p>如果在搭建博客的过程中有问题，只要把文件夹删掉重来即可</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\&gt;hexo init blog</span><br><span class="line">INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git</span><br><span class="line">INFO  Install dependencies</span><br><span class="line">INFO  Start blogging with Hexo!</span><br></pre></td></tr></table></figure>

<p>初始化成功后，站点目录下生成的文件：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112003332202.png" alt="image-20230112003332202" style="zoom:67%;" />

<p>2.使用命令<code>hexo s</code>，启动博客（注意要之前的目录下运行），博客在本地的4000端口启动，访问<a href="http://localhost:4000/">http://localhost:4000/</a> 即可以看到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\blog&gt;hexo s</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112004204737.png" alt="image-20230112004204737" style="zoom:50%;" />

<p>3.使用命令<code>hexo n &quot;文章名&quot;</code>，创建博客文章。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\blog&gt;hexo n <span class="string">&quot;我的第一篇博客文章&quot;</span></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Created: D:\blog\<span class="built_in">source</span>\_posts\我的第一篇博客文章.md</span><br></pre></td></tr></table></figure>

<p>进入对应的目录下，可以看到已经成功生成文件，然后就可以在文件中写博客了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\blog&gt;<span class="built_in">cd</span> D:\blog\<span class="built_in">source</span>\_posts\</span><br><span class="line">D:\blog\<span class="built_in">source</span>\_posts&gt;<span class="built_in">dir</span></span><br><span class="line"> 驱动器 D 中的卷是 Data</span><br><span class="line"> 卷的序列号是 8A15-B825</span><br><span class="line"></span><br><span class="line"> D:\blog\<span class="built_in">source</span>\_posts 的目录</span><br><span class="line"></span><br><span class="line">2023/01/12  00:48    &lt;DIR&gt;          .</span><br><span class="line">2023/01/12  00:48    &lt;DIR&gt;          ..</span><br><span class="line">2023/01/12  00:08               876 hello-world.md</span><br><span class="line">2023/01/12  00:48                75 我的第一篇博客文章.md</span><br><span class="line">               2 个文件            951 字节</span><br><span class="line">               2 个目录 1,724,429,172,736 可用字节</span><br></pre></td></tr></table></figure>

<p>4.返回博客目录，使用命令<code>hexo clean</code>清理一下缓存文件，使用命令<code>hexo g</code>在hexo站点根目录下生成public文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\blog\<span class="built_in">source</span>\_posts&gt;<span class="built_in">cd</span> ../..</span><br><span class="line"></span><br><span class="line">D:\blog&gt;hexo clean</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Deleted database.</span><br><span class="line"></span><br><span class="line">D:\blog&gt;hexo g</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded <span class="keyword">in</span> 157 ms</span><br><span class="line">INFO  Generated: archives/index.html</span><br><span class="line">INFO  Generated: index.html</span><br><span class="line">INFO  Generated: tags/杂记/index.html</span><br><span class="line">INFO  Generated: archives/2023/01/index.html</span><br><span class="line">INFO  Generated: js/jquery-3.4.1.min.js</span><br><span class="line">INFO  Generated: fancybox/jquery.fancybox.min.css</span><br><span class="line">INFO  Generated: css/fonts/fontawesome-webfont.woff</span><br><span class="line">INFO  Generated: fancybox/jquery.fancybox.min.js</span><br><span class="line">INFO  Generated: archives/2023/index.html</span><br><span class="line">INFO  Generated: js/script.js</span><br><span class="line">INFO  Generated: css/style.css</span><br><span class="line">INFO  Generated: css/fonts/fontawesome-webfont.ttf</span><br><span class="line">INFO  Generated: css/images/banner.jpg</span><br><span class="line">INFO  Generated: css/fonts/fontawesome-webfont.eot</span><br><span class="line">INFO  Generated: css/fonts/FontAwesome.otf</span><br><span class="line">INFO  Generated: css/fonts/fontawesome-webfont.woff2</span><br><span class="line">INFO  Generated: 2023/01/12/hello-world/index.html</span><br><span class="line">INFO  Generated: 2023/01/12/我的第一篇博客文章/index.html</span><br><span class="line">INFO  Generated: css/fonts/fontawesome-webfont.svg</span><br><span class="line">INFO  19 files generated <span class="keyword">in</span> 360 ms</span><br><span class="line"></span><br><span class="line">D:\blog&gt;</span><br></pre></td></tr></table></figure>

<p>5.然后重新启动服务，浏览器访问端口，成功生成新的文章。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112010050731.png" alt="image-20230112010050731" style="zoom:67%;" />

<h2 id="3-将博客部署到github"><a href="#3-将博客部署到github" class="headerlink" title="3.将博客部署到github"></a>3.将博客部署到github</h2><p>1.登录github，创建新仓库，仓库名必须如下：</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112010910756.png" alt="image-20230112010910756" style="zoom:67%;" />

<p>其他选项默认，然后点击创建仓库。</p>
<p>2.使用命令<code>npm install hexo-deployer-git --save</code>，安装git。</p>
<p>注意设置用户名和邮件：(随意)</p>
<p><code>git config --global user.name &lt;你的用户名&gt;</code><br><code>git config --global user.email &lt;你的邮箱&gt;</code></p>
<p>3.在hexo博客目录下的 _config.yml 文件，最后几行改为如下形式，然后保存。</p>
<blockquote>
<p>注意：每个冒号后面要加空格</p>
</blockquote>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112012113713.png" alt="image-20230112012113713" style="zoom:67%;" />

<p>4.使用命令<code>hexo d</code>，将博客部署到github中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\blog&gt;hexo d</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Setting up Git deployment...</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> D:/blog/.deploy_git/.git/</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Enumerating objects: 39, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (39/39), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (29/29), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (39/39), 886.59 KiB | 1.82 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 39 (delta 5), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">To github.com:liyuelian/liyuelian.github.io.git</span><br><span class="line"> * [new branch]      HEAD -&gt; master</span><br><span class="line">branch <span class="string">&#x27;master&#x27;</span> <span class="built_in">set</span> up to track <span class="string">&#x27;git@github.com:liyuelian/liyuelian.github.io.git/master&#x27;</span>.</span><br><span class="line">INFO  Deploy <span class="keyword">done</span>: git</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里没有设置ssh免密登录的要输入github账号密码</p>
</blockquote>
<p>5.在github仓库刷新，可以看到所有hexo文件已经上传到仓库中。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112013058368.png" alt="image-20230112013058368" style="zoom:67%;" />

<p>6.在地址栏中访问<code>&lt;你的github用户名&gt;.github.io</code>，即可看到个人博客网站。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112013505644.png" alt="image-20230112013505644" style="zoom:67%;" />

<h2 id="4-如何发布新文章"><a href="#4-如何发布新文章" class="headerlink" title="4.如何发布新文章"></a>4.如何发布新文章</h2><blockquote>
<p>参考：<a href="https://cloud.tencent.com/developer/article/1662733">Hexo博客教程（二）| 如何写作新文章并发布</a></p>
</blockquote>
<p>1.首先使用命令<code>hexo new &lt;title&gt;</code>创建新文章，然后到hexo目录&#x2F;source&#x2F;_posts下去编写文章。</p>
<p>使用该命令创建的md文件头会有一个前置信息Front-matter，用于给hexo渲染md文档。</p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">title</td>
<td align="left">文章标题</td>
</tr>
<tr>
<td align="left">date</td>
<td align="left">文章创建日期</td>
</tr>
<tr>
<td align="left">comments</td>
<td align="left">是否启动文章评论功能</td>
</tr>
<tr>
<td align="left">tags</td>
<td align="left">文章标签</td>
</tr>
<tr>
<td align="left">categories</td>
<td align="left">文章分类</td>
</tr>
<tr>
<td align="left">keywords</td>
<td align="left">文章关键字</td>
</tr>
</tbody></table>
<p>2.使用命令<code>hexo clean</code>，清除掉旧的数据</p>
<blockquote>
<p>这个命令会清除掉之前生成的网页，即站点根目录下的<code>public</code>文件夹。</p>
</blockquote>
<p>3.使用命令<code>hexo g</code></p>
<blockquote>
<p>这个命令会将<code>source</code>文件夹下所有的md文件进行渲染，生成HTML页面，存放在<code>public</code>文件夹下。</p>
</blockquote>
<p>特别提醒！ 每次修改文章后，都要执行这两条命令，清除掉旧的数据，然后重新生成页面。</p>
<p>4.使用命令<code>hexo d</code>，将文件上传到你的远程仓库中即可。</p>
<blockquote>
<p>可以先使用hexo s，先在本地预览一下</p>
</blockquote>
<h2 id="5-如何更换博客主题"><a href="#5-如何更换博客主题" class="headerlink" title="5.如何更换博客主题"></a>5.如何更换博客主题</h2><blockquote>
<p>以yilia主题为例：<a href="https://github.com/litten/hexo-theme-yilia">litten&#x2F;hexo-theme-yilia: A simple and elegant theme for hexo. (github.com)</a></p>
</blockquote>
<p>1.在你的hexo目录下运行：<code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\blog&gt;git <span class="built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br><span class="line">Cloning into <span class="string">&#x27;themes/yilia&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 2037, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (1/1), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 2037 (delta 0), reused 0 (delta 0), pack-reused 2036</span><br><span class="line">Receiving objects: 100% (2037/2037), 10.53 MiB | 398.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line">Resolving deltas: 100% (1079/1079), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112020544576.png" alt="image-20230112020544576" style="zoom:67%;" />

<p>2.在_config.yml文件中修改主题，保存。</p>
<blockquote>
<p>注意冒号后面有空格</p>
</blockquote>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112020815301.png" alt="image-20230112020815301" style="zoom:67%;" />

<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112020902973.png" alt="image-20230112020902973" style="zoom:67%;" />

<p>3.在hexo目录下使用<code>hexo clean</code>，然后使用<code>hexo g</code>重新生成public文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\blog&gt;hexo clean</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Deleted database.</span><br><span class="line">INFO  Deleted public folder.</span><br><span class="line"></span><br><span class="line">D:\blog&gt;hexo g</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded <span class="keyword">in</span> 285 ms</span><br><span class="line">...</span><br><span class="line">INFO  20 files generated <span class="keyword">in</span> 64 ms</span><br></pre></td></tr></table></figure>

<p>4.使用<code>hexo s</code>在本地启动，预览一下</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230112021746933.png" alt="image-20230112021746933" style="zoom:67%;" />

<p>5.觉得没问题了，就在hexo目录下使用<code>hexo d</code>，将新的博客文件发布到你的远程仓库中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\blog&gt;hexo d</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Deploying: git</span><br><span class="line">...</span><br><span class="line">INFO  Deploy <span class="keyword">done</span>: git</span><br></pre></td></tr></table></figure>

<p>然后在你的&lt;github个人用户名&gt;.github.io上就可以看到新的博客主题了</p>
<blockquote>
<p>有时候会延迟一会才能更新</p>
</blockquote>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>主题 1 The Shell</title>
    <url>/2023/01/12/00-15-22/</url>
    <content><![CDATA[<h1 id="主题-1-The-Shell"><a href="#主题-1-The-Shell" class="headerlink" title="主题 1 The Shell"></a>主题 1 The Shell</h1><p><a href="https://missing-semester-cn.github.io/2020/course-shell/">课程概览与 shell · the missing semester of your cs education (missing-semester-cn.github.io)</a></p>
<h2 id="Shell是什么？"><a href="#Shell是什么？" class="headerlink" title="Shell是什么？"></a>Shell是什么？</h2><p>一旦你想脱离可视化界面让你做的，然后做点别的事情，那么Shell将是你和计算机交互的最主要的方式之一。</p>
<p>可视化界面受限于，它只能做被设计出来的操作——比如你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。这就是这门课介绍命令行工具和基于文本的工具的理由，shell则是你去做这些操作的地方。</p>
<p>在Windows和Linux可以找到成堆的终端（Terminal），这些是能显示Shell的文本窗口。其中普遍的是bash，或者叫Bourne Again Shell。由于bash的普遍性，这门课中将使用bash。</p>
<span id="more"></span>

<h2 id="使用Shell"><a href="#使用Shell" class="headerlink" title="使用Shell"></a>使用Shell</h2><p>终端（Terminal）是你电脑上和shell交互的主要文本界面。</p>
<p>当你打开一个终端，你通常会在终端中看到这样的一行，称为命令行提示符（Shell Prompt）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<p>它告诉你，你的主机名是<code>VM-8-17-centos</code>，你的用户名是<code>root</code>，还有你当前所在的路径为<code>~</code>（path）。</p>
<p>可以在终端上执行命令，通常是带着参数（argument）执行程序。参数一般是一些紧随程序名后面的，用空格分开的东西。</p>
<ul>
<li>date</li>
</ul>
<p>date输入当前日期和时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># date</span></span><br><span class="line">Sat Dec 17 01:04:35 CST 2022</span><br></pre></td></tr></table></figure>

<ul>
<li>echo</li>
</ul>
<p>echo打印出你传给它的参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># echo hello</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<ul>
<li>参数以空格分隔</li>
</ul>
<p>如上所说，参数是被空格分隔的，如果传递一个多单词的参数，就必须用引号括起来，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># echo &quot;Hello Wrold&quot;</span></span><br><span class="line">Hello Wrold</span><br></pre></td></tr></table></figure>

<p>这样echo程序会收到一个字符串参数<code>Hello World</code>，中间还有一个空格。此外使用单引号也是可以的。</p>
<blockquote>
<p>单双引号的区别将在bash scripting 再说</p>
</blockquote>
<p>此外也可以使用转义符将空格转义，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># echo Hello\ World</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于如何给参数，变量转义，解析和加括号将在之后涉及</p>
</blockquote>
<p>我们在创建目录或文件时，如果某个参数是带空格的，也需要使用引号转义或者用转义符将空格转义，否者shell将会将该参数识别成两个参数。</p>
<p>如下shell将<code>my photo</code>识别成两个参数，创建了两个目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># mkdir my photo</span></span><br><span class="line">[root@VM-8-17-centos ~]<span class="comment"># ls</span></span><br><span class="line">my  photo</span><br></pre></td></tr></table></figure>

<p>正确的做法为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># mkdir &quot;my photo&quot;</span></span><br><span class="line">[root@VM-8-17-centos ~]<span class="comment"># ll</span></span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x 2 root root 4096 Dec 17 01:23 <span class="string">&#x27;my photo&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="在Shell中导航"><a href="#在Shell中导航" class="headerlink" title="在Shell中导航"></a>在Shell中导航</h2><ul>
<li>环境变量</li>
</ul>
<p>你可能会好奇，当输入date或者echo等命令时，Shell怎么知道这些程序要做什么。</p>
<p>你的机器可能内嵌了终端程序，或者某些浏览器。同样的，电脑也内嵌了很多围绕终端工作的程序，这些程序位于你的文件系统（File System），Shell有办法在系统中搜索某个程序，然后执行。</p>
<p>当然，Shell不会在所有文件中进行搜索，那样效率太低了。</p>
<p>Shell借助一个叫做 <strong>环境变量（Environment Variable）</strong> 的东西来完成搜索。</p>
<blockquote>
<p>环境变量就类似编程语言中的变量，Shell或者说bash本身就是一种程序设计语言。你输入的提示符（Prompt）不仅能带参运行程序，你也可以写入while循环，for循环，条件语句等，甚至可以定义函数，甚至变量。关于Shell Scripting的下一讲会有涉及</p>
</blockquote>
<p>环境变量是Shell本就设定好的，无论何时打开shell都无需重新设置。一堆东西都会预先设置好，比如哪里是home目录，你的用户名是什么等。</p>
<ul>
<li>PATH变量</li>
</ul>
<p>如下，当我们执行<code>echo $PATH</code>时，将会输出一些电脑上的目录，这些目录就是Shell寻找程序时所查找的目录。这些目录以冒号分隔。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># echo $PATH</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure>

<p>当你输入一个程序名称时，电脑会在这个列表中的每个目录里，查找名字与你所输入的指令相同的一个程序或者文件。如果在这些目录中可以找到待运行的程序，程序可以正常运行，否则失败。</p>
<ul>
<li>which</li>
</ul>
<p>如果我们想要知道电脑具体运行了哪一个目录里的程序，可以使用which指令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># which echo</span></span><br><span class="line">/usr/bin/echo</span><br><span class="line">[root@VM-8-17-centos ~]<span class="comment"># which date</span></span><br><span class="line">/usr/bin/date</span><br></pre></td></tr></table></figure>

<ul>
<li>路径</li>
</ul>
<p>路径是用来描述你的计算机里文件位置的东西。</p>
<p>在Linux或者Mac Os上，路径被一连串的斜杠分隔，可以看到上面echo指令的路径起点在根目录<code>/</code>（&#x2F; 即整个文件系统的最顶层）</p>
<blockquote>
<p>在Windows里，路径以反斜杠\ 而非斜杠&#x2F;分隔。</p>
</blockquote>
<p>在Linux或Mac Os上，所有东西都在一个叫根（root）的空间的下面的某处。因此所有以斜杠开头&#x2F;的路径都是<strong>绝对路径</strong>。</p>
<p>而在Windows下，每一个分区都有一个根，类似于C:\或者D:\，所以Windows里每一个驱动器(硬盘)下都有独立的一套文件系统的层次结构。</p>
<blockquote>
<p>绝对路径：是可以绝对准确地确定一个文件的位置的路径</p>
<p>相对路径：是相对于你当前所在位置的路径</p>
</blockquote>
<ul>
<li>pwd</li>
</ul>
<p>打印工作目录（print working directory）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br></pre></td></tr></table></figure>

<p>你可以改变当前工作目录，所有的相对路径都是相对于当前工作目录的</p>
<ul>
<li>cd</li>
</ul>
<p>change directory 改变当前工作目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos ~]<span class="comment"># cd /home</span></span><br><span class="line">[root@VM-8-17-centos home]<span class="comment"># pwd</span></span><br><span class="line">/home</span><br></pre></td></tr></table></figure>

<blockquote>
<p>shell提示只会给路径的最后一段名称，当然也可以通过设置是它总能显示当前的完整路径</p>
</blockquote>
<ul>
<li>特殊的目录 <code>. </code>和<code> ..</code></li>
</ul>
<p><code>.</code> 表示当前目录，<code>..</code>表示上一级（父）目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># pwd</span></span><br><span class="line">/home/lighthouse</span><br><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cd ../../..</span></span><br><span class="line">[root@VM-8-17-centos /]<span class="comment"># pwd</span></span><br><span class="line">/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用相对or绝对路径取决于哪个方便，但是如果有时候你需要运行某个程序或者写一个程序，它调用了类似echo或者date这样的程序，你希望它在哪个地方都能跑起来，要么你就只给出这个要被运行的程序的名字(让shell用path去找出它们在哪里)，要么就需要给出绝对路径</p>
<p>一般来说程序默认在当前目录运行</p>
</blockquote>
<ul>
<li>ls</li>
</ul>
<p>输入本级目录下的所有文件信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># ls</span></span><br><span class="line">bin  boot  data  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>

<p>如果给定路径参数，则会输出给定路径目录下的文件信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># ls home/lighthouse/</span></span><br><span class="line">dirdemo  hello2.txt  hello.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>特殊符号<code>-</code>和<code>~</code></li>
</ul>
<p><code>~</code>表示<strong>当前</strong>用户的home目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># cd ~</span></span><br><span class="line">[root@VM-8-17-centos ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br></pre></td></tr></table></figure>

<p>在cd命令中，<code>-</code>参数表示之前所处的工作目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># cd -</span></span><br><span class="line">/home</span><br><span class="line">[root@VM-8-17-centos home]<span class="comment"># cd -</span></span><br><span class="line">/</span><br></pre></td></tr></table></figure>

<ul>
<li>–help</li>
</ul>
<p>大多数命令都有一个 –help选项，可以帮助你了解命令的用法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># ls --help</span></span><br><span class="line">Usage: <span class="built_in">ls</span> [OPTION]... [FILE]...</span><br><span class="line">List information about the FILEs (the current directory by default).</span><br><span class="line">Sort entries alphabetically <span class="keyword">if</span> none of -cftuvSUX nor --<span class="built_in">sort</span> is specified.</span><br><span class="line"></span><br><span class="line">Mandatory arguments to long options are mandatory <span class="keyword">for</span> short options too.</span><br><span class="line">  -a, --all                  <span class="keyword">do</span> not ignore entries starting with .</span><br><span class="line">  -A, --almost-all           <span class="keyword">do</span> not list implied . and ..</span><br><span class="line">      --author               with -l, <span class="built_in">print</span> the author of each file</span><br><span class="line">  -b, --escape               <span class="built_in">print</span> C-style escapes <span class="keyword">for</span> nongraphic characters</span><br><span class="line">      --block-size=SIZE      with -l, scale sizes by SIZE when printing them;</span><br><span class="line">                               e.g., <span class="string">&#x27;--block-size=M&#x27;</span>; see SIZE format below</span><br><span class="line">  -B, --ignore-backups       <span class="keyword">do</span> not list implied entries ending with ~</span><br><span class="line">……</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>比如usage这行信息，[ ]表示这部分内容可填可不填，…表示可以填写多个option或flag</p>
<blockquote>
<p>option是有多个参数字符可以选择，flag是只有一个参数字符选择</p>
</blockquote>
<ul>
<li>权限</li>
</ul>
<p>使用ls -l 命令可以以长列表格式输出当前目录下的文件信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># ls -l</span></span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x 2 lighthouse lighthouse 4096 Dec 13 00:33 dirdemo</span><br><span class="line">-rw-r--r-- 1 root       root          6 Dec 15 19:56 hello2.txt</span><br><span class="line">-rw-rw-r-- 1 lighthouse lighthouse   52 Dec 15 19:59 hello.txt</span><br></pre></td></tr></table></figure>

<p>首先前面带着d的这行条目，代表这是一个目录，例如上面的dirdemo就是一个目录，hello2.txt和hello.txt则是文件。</p>
<p>d后面的字符<code>rwxrwxr-x</code>代表文件被授予的权限。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221222225758192.png" alt="image-20221222225758192" style="zoom:67%;" />

<p>阅读这一串字符的方法如下：9个字符，每三个一组，分为三组。</p>
<p>第一组：代表权限被授予给了文件的所有者</p>
<p>第二组：代表给拥有这些文件的用户组的权限</p>
<p>第三组：代表给非所有者的其他人的权限</p>
<p>其中 <code>-</code> 表示该用户不具备相应的权限。</p>
<p>同时可以发现所有字符都是有rwx组成的，r（read）表示读取权限，w（write）表示写入权限，x（execute）表示执行权限。这三者的权限使用数字表示：4表示r，2表示w，1表示x。</p>
<p>权限对于文件和目录有不同的解释：</p>
<p>对文件而言，如果你有读取权限，可以读取文件的内容。文件的写权限就是</p>
<p>目录的读取权限可以允许你<strong>看</strong>这个文件夹中有哪些东西（列出这个目录的内容）；目录的写入权限是你能否<strong>重命名、新建或者删除</strong>里面的文件；注意如果你有目录里的文件的写入权限，却没有目录的写入权限，那你就不能删除这个文件（即使你清空了这个文件也不能删除它，因为这要目录的写入权限）；最后是目录的执行权限，通常来讲就是搜索权限。这意味着你能不能<strong>进入</strong>这个目录。</p>
<blockquote>
<p>为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限(即目录的执行权限)</p>
</blockquote>
<ul>
<li>mv</li>
</ul>
<p>它接受两个路径作为参数，第一个是原有的路径，第二个是新的路径。这意味着mv既可以让你重命名一个文件，又可以让你移动一个文件。</p>
<ul>
<li>cp</li>
</ul>
<p>copy复制，该命令可以让你复制文件，用法很类似。它也接受两个路径作为参数，复制源路径和目标路径，这些路径要是完整路径（意为着你需要明确指定文件路径，这个命令没有搜索功能）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cp hello.txt ../food.txt</span></span><br><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cd ..</span></span><br><span class="line">[root@VM-8-17-centos home]<span class="comment"># ls</span></span><br><span class="line">food.txt  lighthouse</span><br></pre></td></tr></table></figure>

<ul>
<li>rm</li>
</ul>
<p>移除（删除一个文件），你可以传递一个路径作为参数。</p>
<p>需要注意默认的移除是非递归的，也就是说你不能rm移除一个目录（因为目录中可能会有文件），你可以传递一个执行递归移除的-r 标识，它就会递归删除目录下的所有内容</p>
<ul>
<li>rmdir</li>
</ul>
<p>移除目录，同样也是非递归的，这意味着你不能使用该命令删除一个非空目录</p>
<ul>
<li>mkdir</li>
</ul>
<p>创建一个新目录</p>
<ul>
<li>man</li>
</ul>
<p>manual pages(手册&#x2F;说明书)，这个程序接受其他程序的名字作为一个参数，然后显示它的说明书。</p>
<p>和<code>程序名 --help</code>命令相似。</p>
<ul>
<li>快捷键Ctrl+L</li>
</ul>
<p>清空终端，让光标回到顶部（和clear命令相似）</p>
<h2 id="在程序间创建连接"><a href="#在程序间创建连接" class="headerlink" title="在程序间创建连接"></a>在程序间创建连接</h2><ul>
<li>流（Stream）</li>
</ul>
<p>程序有两个主要的流（stream），默认下程序会有一个输入流（input stream）和一个输出流（output stream）</p>
<ol>
<li><p>默认输入流里的内容来自你的键盘，基本上输入流是终端，无论你向终端输入什么，最后都会传到程序里。</p>
</li>
<li><p>默认的输出流（即当程序想要输出一些内容时），默认也是终端</p>
<blockquote>
<p>这也是为什么当你在终端中打入<code>echo hello</code>时，hello会直接显示在你的终端里</p>
</blockquote>
</li>
</ol>
<p>Shell提供了重定向这些流的方法，把输入和输出都改到程序员指明的地方。最直接的方式就是使用大于小于号(即所谓的尖角括号)。</p>
<ol>
<li>小于号表示重定向这个程序的输入流</li>
<li>大于号表示重定向程序的输出流</li>
</ol>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># echo hello &gt; hello.txt</span></span><br><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cat hello.txt </span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>将echo程序输出的内容hello，输入到hello.txt文件中</p>
<p>cat的作用是打印出一个文件的内容，cat同样支持流的重定向。</p>
<p>在这个例子中，Shell就会打开hello.txt，取出它的内容，设置成cat的输入，cat就会把这些内容打印到它的输出流，这里没有重定向，所以cat的输出流还是终端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cat &lt; hello.txt</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>也可以同时使用两种重定向，如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cat &lt; hello.txt &gt; hello2.txt</span></span><br><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cat hello2.txt </span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>用hello.txt的内容作为cat的输入流，然后把cat输出的所欲内容存到hello2.txt中</p>
<ul>
<li>双大于号</li>
</ul>
<p>作用是追加（append）而不是覆写（overwrite）</p>
<blockquote>
<p>追加指向文件尾继续添加内容，覆写是清空文件再写入内容</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cat &lt; hello.txt &gt; hello2.txt</span></span><br><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cat hello2.txt </span></span><br><span class="line">hello</span><br><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cat &lt; hello.txt &gt;&gt; hello2.txt</span></span><br><span class="line">[root@VM-8-17-centos lighthouse]<span class="comment"># cat hello2.txt </span></span><br><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<ul>
<li>管道符</li>
</ul>
<p>pipe，管道符就是一个竖线<code>|</code>。管道的意思是，取左侧程序的输出，称为右侧程序的输入。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># ls -l | tail -n3</span></span><br><span class="line">drwxrwxrwt.  10 root root  4096 Dec 22 22:03 tmp</span><br><span class="line">drwxr-xr-x.  12 root root  4096 Dec 31  2021 usr</span><br><span class="line">drwxr-xr-x.  20 root root  4096 Dec 31  2021 var</span><br></pre></td></tr></table></figure>

<p>ls的输出作为tail的输入，tail的输出则会输到终端（因为你没有重定向tail的输出）</p>
<blockquote>
<p>tail 打印它输入的最后n行</p>
</blockquote>
<p>当然也可以重定向tail的输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># ls -l | tail -n3 &gt; ls.txt</span></span><br><span class="line">[root@VM-8-17-centos /]<span class="comment"># cat ls.txt</span></span><br><span class="line">drwxrwxrwt.  10 root root  4096 Dec 22 22:03 tmp</span><br><span class="line">drwxr-xr-x.  12 root root  4096 Dec 31  2021 usr</span><br><span class="line">drwxr-xr-x.  20 root root  4096 Dec 31  2021 var</span><br></pre></td></tr></table></figure>

<p>使用管道可以构建一些复杂的命令：</p>
<p>我们可以做一些操作例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># curl --head --silent baidu.com</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu, 22 Dec 2022 16:17:30 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT</span><br><span class="line">ETag: <span class="string">&quot;51-47cf7e6ee8400&quot;</span></span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 81</span><br><span class="line">Cache-Control: max-age=86400</span><br><span class="line">Expires: Fri, 23 Dec 2022 16:17:30 GMT</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure>

<p>这会给你访问baidu.com的时候所有的HTTP Headers</p>
<p>你可以使用管道将这些输出接到grep -i content-length</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># curl --head --silent baidu.com | grep -i content-length</span></span><br><span class="line">Content-Length: 81</span><br></pre></td></tr></table></figure>

<blockquote>
<p>grep 命令支持在输入流里搜索给定的关键字</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM-8-17-centos /]<span class="comment"># curl --head --silent baidu.com | grep -i content-length | cut --delimiter=&#x27; &#x27; -f2</span></span><br><span class="line">81</span><br></pre></td></tr></table></figure>

<blockquote>
<p>cut 命令可以接收一个分隔符delimiter，将输入流以分隔符的形式输出，-f设置输出第几个字段</p>
</blockquote>
<p>可以发现通过将命令链接起来，你可以做很多文本操作的特技</p>
<p>并且pipe不止用于文本数据，还可以拿来处理比如图片。当你有一个程序可以接收并处理二进制图片，然后输出一个二进制图片的时候，可以像这样把它连进去，你甚至可以这样处理视频。</p>
<h2 id="一个功能全面又强大的工具"><a href="#一个功能全面又强大的工具" class="headerlink" title="一个功能全面又强大的工具"></a>一个功能全面又强大的工具</h2><ul>
<li>root用户</li>
</ul>
<p>在linux和Mac OS中，root用户类似于Windows的管理员（Administrator），有值为0的用户ID。</p>
<p>root用户允许在系统上做<strong>任意行为</strong>。就算一个文件中任何人都不可读的或者任何人都不可写的，root却可以访问这个文件并且读写。多数情况下，应该使用一个普通用户来操作电脑，因为root具有风险，比如在root下运行了一个错误的程序，可能会毁掉你的整个电脑。</p>
<ul>
<li>sudo</li>
</ul>
<p>但是如果在普通用户下需要使用root权限操作时，可以使用sudo命令，这可以让你使用超级用户权限运行程序。</p>
<p>sudo的通常用法是，<code>sudo 需要调用的命令</code></p>
<p>应用场景：</p>
<p>在你的电脑中有很多特别的文件系统，例如sysfs。我们进入到在&#x2F;sys目录，这个文件系统不是真实存在的文件，相反，这是一堆内核参数。内核（kernel）基本上就是你电脑（操作系统）的核心。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos sys]$ <span class="built_in">ls</span></span><br><span class="line">block  bus  class  dev  devices  firmware  fs  hypervisor  kernel  module  power</span><br></pre></td></tr></table></figure>

<p>通过这些像是文件系统的东西，可以访问到内核的参数。</p>
<p>由于这些内核参数是以文件形式展露的，我们可以使用先前的所有工具去操作它们。例如：</p>
<p>你可以在&#x2F;sys&#x2F;class&#x2F;backlight&#x2F;intel_backlight&#x2F;下的brightness操作背光亮度</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221223021905164.png" alt="image-20221223021905164" style="zoom:67%;" />

<p>但是如果直接操作，会显示拒绝访问，因为内核的东西基本上都要root权限。</p>
<p>但是如果运行命令<code>sudo echo 500 &gt; brightness</code>，依然显示没有权限</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221223022224630.png" alt="image-20221223022224630" style="zoom: 67%;" />

<p>因为输入输出的重定向是程序不知道的，管道和重定向都是Shell设好的，现在的情况是，我告诉Shell去运行sudo，并且包括参数echo 500 ，然后发送输出到brightness这个文件。也就是说，sudo的root权限只给了前面的echo命令。Shell打开brightness的时候，用的不是sudo，因此显示没有权限。</p>
<p>因此，现在的解决方法是：</p>
<p>方法一：切换到root终端，<code>sudo su</code></p>
<blockquote>
<p>su命令能让你以超级用户登录shell</p>
</blockquote>
<p>使用超级用户登录后，可以看到提示符从<code>$</code>变成了<code>#</code>。然后运行<code>echo 500 &gt; brightness</code>,屏幕的亮度变暗了，并且没有出现权限不足提示。因为现在Shell以root身份运行，root用户允许打开该内核文件。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221223023516151.png" alt="image-20221223023516151" style="zoom:67%;" />

<p>方法二：使用管道和重定向</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221223024934470.png" alt="image-20221223024934470" style="zoom:67%;" />

<p>Shell去运行<code>echo 1060</code>，会输出1060，然后告诉Shell去运行<code>sudo tee brightness</code>命令，然后把echo的输出送入tee的输入，然后tee打开brightness文件（tee程序以root权限运行），并将tee的输入流写入到brightness文件和标准输出流（这里是终端）</p>
<blockquote>
<p>tee命令取它的输入，然后写入到一个文件，并且写入到标准输出流</p>
<p>tee - read from standard input and write to standard output and files</p>
</blockquote>
<p>使用方法二可以毋需登录到root用户。</p>
<p>可以在其他需要root权限的地方法使用这种方法：</p>
<p>例如我现在想让键盘上的滚动锁定灯亮起来，该内核文件在&#x2F;sys&#x2F;class&#x2F;leds&#x2F;input1::scrolllock&#x2F;brightness</p>
<p>使用同样的方法，将参数由0变为1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos input1::scrolllock]$ <span class="built_in">ls</span></span><br><span class="line">brightness  device  max_brightness  power  subsystem  trigger  uevent</span><br><span class="line">[lighthouse@VM-8-17-centos input1::scrolllock]$ <span class="built_in">cat</span> brightness </span><br><span class="line">0</span><br><span class="line">[lighthouse@VM-8-17-centos input1::scrolllock]$ <span class="built_in">echo</span> 1 | <span class="built_in">tee</span> brightness </span><br><span class="line"><span class="built_in">tee</span>: brightness: Permission denied</span><br><span class="line">1</span><br><span class="line">[lighthouse@VM-8-17-centos input1::scrolllock]$ <span class="built_in">echo</span> 1 |sudo <span class="built_in">tee</span> brightness </span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>现在键盘上的滚动锁定灯已经亮起来了</p>
<ul>
<li>打开文件</li>
</ul>
<p>xdg-open命令，这个指令可能只在linux上运行，在Mac Os上可能叫做open</p>
<p>你给出一个文件名，然后xdg-open就会使用合适的程序打开它</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>本课程需要使用类Unix shell，例如 Bash 或 ZSH。使用<code>echo $SHELL</code>命令可以查看您的 shell 是否满足要求。如果打印结果为<code>/bin/bash</code>或<code>/usr/bin/zsh</code>则是可以的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tmp]$ <span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>/tmp</code> 下新建一个名为 <code>missing</code> 的文件夹。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tmp]$ <span class="built_in">mkdir</span> missing</span><br></pre></td></tr></table></figure>
</li>
<li><p>用 <code>man</code> 查看程序 <code>touch</code> 的使用手册。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tmp]$ man <span class="built_in">touch</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用 <code>touch</code> 在 <code>missing</code> 文件夹中新建一个叫 <code>semester</code> 的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tmp]$ <span class="built_in">touch</span> ./missing/semester</span><br></pre></td></tr></table></figure>
</li>
<li><p>将以下内容一行一行地写入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">curl --head --silent https://missing.csail.mit.edu</span><br></pre></td></tr></table></figure>

<p>第一行可能有点棘手， <code>#</code> 在Bash中表示注释，而 <code>!</code> 即使被双引号（<code>&quot;</code>）包裹也具有特殊的含义。 单引号（<code>&#39;</code>）则不一样，此处利用这一点解决输入问题。更多信息请参考 <a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">Bash quoting 手册</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos missing]$ <span class="built_in">echo</span> <span class="string">&#x27;#!/bin/sh&#x27;</span> &gt; semester </span><br><span class="line">[lighthouse@VM-8-17-centos missing]$ <span class="built_in">echo</span> <span class="string">&quot;curl --head --silent https://missing.csail.mit.edu&quot;</span> &gt;&gt; semester</span><br><span class="line">[lighthouse@VM-8-17-centos missing]$ <span class="built_in">cat</span> semester </span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">curl --<span class="built_in">head</span> --silent https://missing.csail.mit.edu</span><br></pre></td></tr></table></figure>
</li>
<li><p>尝试执行这个文件。例如，将该脚本的路径（<code>./semester</code>）输入到您的shell中并回车。如果程序无法执行，请使用 <code>ls</code> 命令来获取信息并理解其不能执行的原因。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos missing]$ ./semester</span><br><span class="line">-bash: ./semester: Permission denied</span><br><span class="line">[lighthouse@VM-8-17-centos missing]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r-- 1 lighthouse lighthouse 60 Dec 30 23:44 semester</span><br></pre></td></tr></table></figure>

<p>原因是没有执行x权限</p>
</li>
<li><p>查看 <code>chmod</code> 的手册(例如，使用 <code>man chmod</code> 命令)</p>
<p>略</p>
</li>
<li><p>使用 <code>chmod</code> 命令改变权限，使 <code>./semester</code> 能够成功执行，不要使用 <code>sh semester</code> 来执行该程序。您的 shell 是如何知晓这个文件需要使用 <code>sh</code> 来解析呢？更多信息请参考：<a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos missing]$ <span class="built_in">chmod</span> 764 semester</span><br><span class="line">[lighthouse@VM-8-17-centos missing]$ ./semester</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 7991</span><br><span class="line">Server: GitHub.com</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Last-Modified: Mon, 05 Dec 2022 15:59:23 GMT</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">ETag: <span class="string">&quot;638e155b-1f37&quot;</span></span><br><span class="line">expires: Tue, 27 Dec 2022 02:31:08 GMT</span><br><span class="line">Cache-Control: max-age=600</span><br><span class="line">x-proxy-cache: MISS</span><br><span class="line">X-GitHub-Request-Id: 5400:19D5:CB919:12261D:63AA5694</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Date: Fri, 30 Dec 2022 15:59:50 GMT</span><br><span class="line">Via: 1.1 varnish</span><br><span class="line">Age: 0</span><br><span class="line">X-Served-By: cache-nrt-rjtf7700066-NRT</span><br><span class="line">X-Cache: HIT</span><br><span class="line">X-Cache-Hits: 1</span><br><span class="line">X-Timer: S1672415990.322601,VS0,VE211</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Fastly-Request-ID: b5ca5ecd45fb43becb00f6f5b089c1d56b46a765</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>|</code> 和 <code>&gt;</code> ，将 <code>semester</code> 文件输出的最后更改日期信息，写入主目录下的 <code>last-modified.txt</code> 的文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos missing]$ ./semester | grep Last &gt; ~/last-modified.txt</span><br><span class="line">[lighthouse@VM-8-17-centos missing]$ <span class="built_in">cat</span> ~/last-modified.txt</span><br><span class="line">Last-Modified: Mon, 05 Dec 2022 15:59:23 GMT</span><br></pre></td></tr></table></figure>
</li>
<li><p>写一段命令来从 <code>/sys</code> 中获取笔记本的电量信息，或者台式机 CPU 的温度。注意：macOS 并没有 sysfs，所以 Mac 用户可以跳过这一题。</p>
<p>略</p>
</li>
</ol>
]]></content>
      <categories>
        <category>the missing semester of cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>主题 3 编辑器(Vim)</title>
    <url>/2023/01/12/00-15-22/</url>
    <content><![CDATA[<h1 id="主题-3-编辑器-Vim"><a href="#主题-3-编辑器-Vim" class="headerlink" title="主题 3 编辑器(Vim)"></a>主题 3 编辑器(Vim)</h1><p><a href="https://missing-semester-cn.github.io/2020/editors/">编辑器 (Vim) · the missing semester of your cs education (missing-semester-cn.github.io)</a></p>
<p>代码编辑器和和其他的编辑器（比如用来写文章的编辑器）有一些不同。</p>
<p>这是因为写程序和写文章不同。当你写程序时，会花大量时间来阅读你写的东西，或者来移动光标，做一些小小的修改；而不是像写文章的时候，从上到下一气呵成。因此，对于不同的用途，我们会使用不同的编辑器，这是很合理的。</p>
<h2 id="1-该学哪个编辑器"><a href="#1-该学哪个编辑器" class="headerlink" title="1.该学哪个编辑器?"></a>1.该学哪个编辑器?</h2><span id="more"></span>

<p><a href="https://insights.stackoverflow.com/survey/2019/#development-environments-and-tools">Stack Overflow 的调查</a>显示，VS Code是目前最流行的代码编辑器。而 <a href="https://www.vim.org/">Vim</a> 则是最流行的基于命令行的编辑器。就算最终你没有打算长期使用Vim，我们仍然认为学习Vim背后的思想很有价值。</p>
<p>另外，许多工具也觉得vim哲学很棒，从而提供了Vim模式。例如当前最热门的VS Code，支持Vim键位绑定，该插件已经被下载了数百万次。</p>
<h2 id="2-Vim的哲学"><a href="#2-Vim的哲学" class="headerlink" title="2.Vim的哲学"></a>2.Vim的哲学</h2><p>Vim是一个基于模式（Modal）的编辑器，这意味着Vim有多个模式。</p>
<blockquote>
<p>Modal这个词源于Mode</p>
</blockquote>
<p>多模式的思想源于，当你在写程序的时候会经常做不同的事情。</p>
<p>在编程的时候，你会把大量时间花在阅读&#x2F;编辑而不是在写代码上。所以，Vim 是一个<strong>多模态</strong>编辑器：它对于插入文字和操纵文字有不同的模式。Vim 是可编程的（可以使用 Vimscript 或者像 Python 一样的其他程序语言），Vim 的接口本身也是一个程序语言：键入操作（以及其助记名） 是命令，这些命令也是可组合的。Vim 避免了使用鼠标，因为那样太慢了；Vim 甚至避免用上下左右键因为那样需要太多的手指移动。</p>
<p>这样的设计哲学使得 Vim 成为了一个能跟上你思维速度的编辑器。</p>
<h2 id="3-编辑模式"><a href="#3-编辑模式" class="headerlink" title="3.编辑模式"></a>3.编辑模式</h2><ul>
<li><p><strong>正常模式</strong>：Normal，在文件中四处移动光标进行修改</p>
</li>
<li><p><strong>插入模式</strong>：Insert，插入文本</p>
</li>
<li><p><strong>替换模式</strong>：replace，替换文本</p>
</li>
<li><p><strong>可视化模式</strong>（一般，行，块）：Visual，Visual Line，Visual Block，选中文本块</p>
</li>
<li><p><strong>命令行模式</strong>：Command Line，用于执行命令</p>
</li>
<li><p>Normal-正常模式 &amp; Insert-插入模式</p>
</li>
</ul>
<p>当你开始使用Vim时，它会在<code>Normal</code>模式下启动。在这个模式下，各种键位组合拥有在这个模式下的特定意义。其中就有一些按键组合来切换到其他的模式。而切换后这些键位组合和意义也相应改变。</p>
<p>你的大部分时间都会在<code>Insert</code>和<code>Normal</code>模式下，在Normal模式下按下<code>i</code>键就可以进入Insert模式。而在Insert模式下按下<code>Esc</code>就可以回到Normal模式。</p>
<blockquote>
<p>这里注意一下我们表示按键的方式，这个表示方式将会用于笔记以及Vim给你的提示中：当仅仅是代表<code>i</code>键这样一个按键本身时，那么就会直接写<code>i</code>。但是对于如Ctrl+v这种按键组合，就有可能以这么几种形式来体现：</p>
<p>第一种是一个脱字符号后跟着控制用字符：<code>^v</code>（这里控制用字符指v，也就是组合键中的另一个键），另一种写法可能是你最熟悉的：<code>Ctrl-v</code>，而有的地方我们可能会写成：<code>&lt;c-v&gt;</code></p>
</blockquote>
<p>Vim有好几种模式，而Normal模式是用来移动光标、阅读东西，以及在文件间切换的。而Insert模式是用来输入的，因此在Insert模式下，你的按键大多会直接进入buffer（缓冲区），而在Normal模式下则不然，它们不会进入buffer，而是用来进行了一些浏览和编辑操作。</p>
<blockquote>
<p><a href="https://joshldavis.com/2014/04/05/vim-tab-madness-buffers-vs-tabs/">Vim Tab Madness. Buffers vs Tabs</a>	<a href="https://blog.csdn.net/jy692405180/article/details/79775125">如何理解并正确使用 Vim 中的 Buffer ,  Window 和 Tab</a>  </p>
</blockquote>
<ul>
<li>replace-替换模式</li>
</ul>
<p>不像插入模式那样会把字符往后移，替换模式会直接覆盖掉文本。</p>
<ul>
<li>可视化模式（一般，行，块）</li>
</ul>
<p>可视化模式有Visual 模式，Visual Line模式，以及一个Visual Block模式。</p>
<hr>
<ul>
<li>各种模式的切换</li>
</ul>
<p>你可以按下 <code>&lt;ESC&gt;</code>（退出键）从任何其他模式返回正常模式。在正常模式，键入 <code>i</code> 进入插入 模式，<code>R</code> 进入替换模式，<code>v</code> 进入可视（一般）模式，<code>shift+V</code> 进入可视（行）模式，<code>&lt;C-v&gt;</code> （Ctrl-V, 有时也写作 <code>^V</code>）进入可视（块）模式，<code>:</code> 进入命令模式。</p>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20230106005400023.png" alt="image-20230106005400023" style="zoom:60%;" />

<ul>
<li>映射Esc键</li>
</ul>
<p>从非Normal模式切换到Normal模式下都是按<code>Esc</code>键，因此使用Vim时要频繁按<code>Esc</code>键。但这个键在键盘的角落里，按起来很不方便，所以很多人会将键盘上某个键映射成Esc。通常这个键是<code>Caps Lock</code>，因为它在键盘的中间一行上。</p>
<h2 id="4-基本操作"><a href="#4-基本操作" class="headerlink" title="4.基本操作"></a>4.基本操作</h2><ul>
<li>如何打开Vim程序</li>
</ul>
<p>Vim是一个基于命令行的编辑器，我们要打开Vim，只需要在命令行中键入<code>vim</code>。vim也可以接收参数，当我们想用它直接编辑特定的文件时，可以在vim 后面加上文件的路径+文件名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos vim]$ <span class="built_in">ls</span></span><br><span class="line">poem.md</span><br><span class="line">[lighthouse@VM-8-17-centos vim]$ vim poem.md </span><br></pre></td></tr></table></figure>

<h3 id="4-1插入文本"><a href="#4-1插入文本" class="headerlink" title="4.1插入文本"></a>4.1插入文本</h3><h3 id="4-2缓存，标签页，窗口"><a href="#4-2缓存，标签页，窗口" class="headerlink" title="4.2缓存，标签页，窗口"></a>4.2缓存，标签页，窗口</h3><h3 id="4-3命令行"><a href="#4-3命令行" class="headerlink" title="4.3命令行"></a>4.3命令行</h3><h2 id="5-Vim的接口其实是一种编程语言"><a href="#5-Vim的接口其实是一种编程语言" class="headerlink" title="5.Vim的接口其实是一种编程语言"></a>5.Vim的接口其实是一种编程语言</h2><h3 id="5-1移动"><a href="#5-1移动" class="headerlink" title="5.1移动"></a>5.1移动</h3><h3 id="5-2选择"><a href="#5-2选择" class="headerlink" title="5.2选择"></a>5.2选择</h3><h3 id="5-3编辑"><a href="#5-3编辑" class="headerlink" title="5.3编辑"></a>5.3编辑</h3><h3 id="5-4计数"><a href="#5-4计数" class="headerlink" title="5.4计数"></a>5.4计数</h3><h3 id="5-5修饰语"><a href="#5-5修饰语" class="headerlink" title="5.5修饰语"></a>5.5修饰语</h3><h2 id="6-演示"><a href="#6-演示" class="headerlink" title="6.演示"></a>6.演示</h2><h2 id="7-自定义Vim"><a href="#7-自定义Vim" class="headerlink" title="7.自定义Vim"></a>7.自定义Vim</h2><h2 id="8-扩展Vim"><a href="#8-扩展Vim" class="headerlink" title="8.扩展Vim"></a>8.扩展Vim</h2><h2 id="9-其他程序的Vim模式"><a href="#9-其他程序的Vim模式" class="headerlink" title="9.其他程序的Vim模式"></a>9.其他程序的Vim模式</h2><h2 id="10-Vim-进阶"><a href="#10-Vim-进阶" class="headerlink" title="10.Vim 进阶"></a>10.Vim 进阶</h2><h2 id="11-拓展资料"><a href="#11-拓展资料" class="headerlink" title="11.拓展资料"></a>11.拓展资料</h2><h2 id="12-课后练习"><a href="#12-课后练习" class="headerlink" title="12.课后练习"></a>12.课后练习</h2>]]></content>
      <categories>
        <category>the missing semester of cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>主题 2 Shell工具和脚本</title>
    <url>/2023/01/12/00-15-22/</url>
    <content><![CDATA[<h1 id="主题-2-Shell工具和脚本"><a href="#主题-2-Shell工具和脚本" class="headerlink" title="主题 2 Shell工具和脚本"></a>主题 2 Shell工具和脚本</h1><p><a href="https://missing-semester-cn.github.io/2020/shell-tools/">Shell 工具和脚本 · the missing semester of your cs education (missing-semester-cn.github.io)</a></p>
<h2 id="Shell脚本"><a href="#Shell脚本" class="headerlink" title="Shell脚本"></a>Shell脚本</h2><p>shell 脚本是一种更加复杂度的工具。</p>
<ul>
<li>定义变量</li>
</ul>
<p>在bash中为变量赋值的语法是<code>foo=bar</code>，意为定义变量foo，foo的值为bar。访问变量使用$变量名</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ foo=bar</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$foo</span>&quot;</span></span><br><span class="line">bar</span><br></pre></td></tr></table></figure>

<p>需要注意的是，Shell中使用空格作为分隔参数的保留字符。</p>
<p>如果将上诉赋值语句写为<code>foo = bar</code>，将不起作用。事实上，这样写并没有将bar赋给foo，而是用<code>=</code>和<code>bar</code>作为参数调用<code>foo</code>程序。因为这样Shell会认为你正在执行一个名为<code>foo</code>的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ foo = bar</span><br><span class="line">-bash: foo: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>

<p>你需要特别注意这类问题，比如如果有带空格的文件名，你需要使用引号将其括起来。</p>
<ul>
<li>在bash中处理字符串</li>
</ul>
<p>有两种定义字符串的方法，可以使用双引号定义字符串，也可以使用单引号定义字符串。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line">Hello</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>

<p>Bash中的字符串通过<code>&#39;</code> 和 <code>&quot;</code>分隔符来定义，但是它们的含义并不相同。</p>
<p>以<code>&#39;</code>定义的字符串为原义字符串，其中的变量不会被转义，而 <code>&quot;</code>定义的字符串会将变量值进行替换。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> <span class="string">&quot;Value is <span class="variable">$foo</span>&quot;</span></span><br><span class="line">Value is bar</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> <span class="string">&#x27;Value is $foo&#x27;</span></span><br><span class="line">Value is <span class="variable">$foo</span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义函数</li>
</ul>
<p>和其他大多数的编程语言一样，<code>bash</code>也支持<code>if</code>, <code>case</code>, <code>while</code> 和 <code>for</code> 这些控制流关键字。同样地， <code>bash</code> 也支持函数，它可以接受参数并基于参数进行操作。</p>
<p>下面这个函数是一个例子，它会创建一个文件夹并使用<code>cd</code>进入该文件夹。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">cat</span> mcd.sh</span><br><span class="line"><span class="function"><span class="title">mcd</span></span>()&#123;</span><br><span class="line">	<span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">	<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里 <code>$1</code> 是脚本的第一个参数的意思</p>
</blockquote>
<p><code>source 脚本名</code>，这将会在Shell中加载脚本并运行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">source</span> mcd.sh</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ mcd <span class="built_in">test</span></span><br><span class="line">[lighthouse@VM-8-17-centos <span class="built_in">test</span>]$ </span><br></pre></td></tr></table></figure>

<p>如上，在执行了<code>source mcd.sh</code>之后，看似无事发生，但实际上Shel中已经定义了mcd函数。我们给mcd传递一个参数test，这个参数被用于作为创建的目录名（即$1），然后Shell自动切换到了test目录里。整个过程就是，我们创建了文件夹并进入其中。</p>
<ul>
<li>保留字</li>
</ul>
<p>在bash中，许多$开头的东西一般都是被保留的（指留作特定用途）</p>
<p> <code>$1</code> 是脚本的第一个参数的意思。与其他脚本语言不同的是，bash使用了很多特殊的变量来表示参数、错误代码和相关变量。下面列举其中一些变量，更完整的列表可以参考 <a href="https://www.tldp.org/LDP/abs/html/special-chars.html">这里</a>。</p>
<table>
<thead>
<tr>
<th>形式</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td>$0</td>
<td>脚本名</td>
</tr>
<tr>
<td>$1~$9</td>
<td>脚本的参数， $1 是第一个参数，依此类推</td>
</tr>
<tr>
<td>$@</td>
<td>所有参数</td>
</tr>
<tr>
<td>$#</td>
<td>参数个数</td>
</tr>
<tr>
<td>$?</td>
<td>前一个命令的返回值</td>
</tr>
<tr>
<td>$$</td>
<td>当前脚本的进程识别码</td>
</tr>
<tr>
<td>!!</td>
<td>完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</td>
</tr>
<tr>
<td>$_</td>
<td>上一条命令的最后一个参数，如果你正在使用的是交互式 shell，你可以通过按下 <code>Esc</code> 之后键入 <code>.</code> 来获取这个值。</td>
</tr>
</tbody></table>
<p>有一些保留字可以直接在Shell中使用，例如<code>$?</code>可以获取上一条命令的错误代码(返回值)，再比如<code>$_</code>会返回上一条命令的最后一个参数。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">mkdir</span> <span class="built_in">test</span></span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">cd</span> <span class="variable">$_</span></span><br><span class="line">[lighthouse@VM-8-17-centos <span class="built_in">test</span>]$ </span><br></pre></td></tr></table></figure>

<p>如上，我们无需在写一次<code>test</code>，使用<code>$_</code>访问该参数，它就会被替换成test，现在我们进入到test目录中了。</p>
<p>这样的例子有很多，再例如<code>!!</code>，它返回完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">mkdir</span> /mnt/new</span><br><span class="line"><span class="built_in">mkdir</span>: cannot create directory ‘/mnt/new’: Permission denied</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ sudo !!</span><br><span class="line">sudo <span class="built_in">mkdir</span> /mnt/new</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">rmdir</span> /mnt/new</span><br><span class="line"><span class="built_in">rmdir</span>: failed to remove <span class="string">&#x27;/mnt/new&#x27;</span>: Permission denied</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ sudo !!</span><br><span class="line">sudo <span class="built_in">rmdir</span> /mnt/new</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ </span><br></pre></td></tr></table></figure>

<ul>
<li>标准错误流</li>
</ul>
<p>如果你的程序出错了，你想输出错误但不想污染标准输出，那么你可以写进这个流。</p>
<ul>
<li>错误代码</li>
</ul>
<p>还有一种叫做错误代码<code>$?</code>（error code）的东西，是一种告诉你整个运行过程结果如何的方式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line">Hello</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>这里显示<code>echo &quot;Hello&quot; </code>运行的错误代码为0，0是因为一切正常，没有出现问题。</p>
<p>这种退出码和如C语言里代表的意思一样。</p>
<p>0代表一切正常，没有出现错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ grep foobar mcd.sh</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>如上，我们尝试着在mcd.sh脚本中查找<code>foobar</code>字符串，而它不存在，所以grep什么都没输出。但是通过反馈一个1的错误代码，它让我们知道这件事没有成功。</p>
<p>此外，true的错误代码始终是0；false的错误代码则是1。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="literal">true</span></span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="literal">false</span></span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<ul>
<li>逻辑运算符</li>
</ul>
<p>下面bash要做的是执行第一个命令，如果第一个命令失败，再去执行第二个（短路运算法则）。因为它尝试做一个逻辑或，如果第一个命令没有0错误码，就会去执行第二个命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="literal">false</span> || <span class="built_in">echo</span> <span class="string">&quot;Oops fail&quot;</span></span><br><span class="line">Oops fail</span><br></pre></td></tr></table></figure>

<p>相似地，如果我们把false换成true，那么将不会执行第二个命令，因为第一个命令已经返回一个0错误码了，第二个命令将会被短路。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="literal">true</span> || <span class="built_in">echo</span> <span class="string">&quot;Oops fail&quot;</span></span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ </span><br></pre></td></tr></table></figure>

<p>相似的，我们使用与运算符<code>&amp;&amp;</code>，它仅当第一个命令执行无错误时，才会执行第二个部分。如果第一个命令失败，那么第二个命令就不会被执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="literal">true</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Things went well&quot;</span></span><br><span class="line">Things went well</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="literal">false</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;This will not print&quot;</span></span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ </span><br></pre></td></tr></table></figure>

<p>使用<code>;</code>号连接的代码，无论你执行什么，都可以通过。在同一行使用分号来连接命令，如下，它始终会被打印出来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="literal">false</span> ; <span class="built_in">echo</span> <span class="string">&quot;This will always print&quot;</span></span><br><span class="line">This will always <span class="built_in">print</span></span><br></pre></td></tr></table></figure>

<ul>
<li>把命令的输出存到变量里</li>
</ul>
<p>这里我们获取pwd命令的输出，它会打印出我们当前的工作路径，然后把其存入foo变量中。然后我们询问变量foo的值，我们就可以看到这个字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ foo=$(<span class="built_in">pwd</span>)</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> <span class="variable">$foo</span></span><br><span class="line">/home/lighthouse/missing-semester/tools</span><br></pre></td></tr></table></figure>

<p>更广泛地来说，我们可以通过一个叫做命令替换的东西，把它放进任意字符串中。并且因为我们使用的不是单引号，所以这串东西会被展开。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> <span class="string">&quot;We are in <span class="subst">$(pwd)</span>&quot;</span></span><br><span class="line">We are <span class="keyword">in</span> /home/lighthouse/missing-semester/tools</span><br></pre></td></tr></table></figure>

<ul>
<li>过程替换</li>
</ul>
<p>另一个比较好用知名度更低的东西叫做过程替换。和之前的命令替换是类似的，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">cat</span> &lt;(<span class="built_in">ls</span>) &lt;(<span class="built_in">ls</span> ..)</span><br><span class="line">mcd.sh</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">tools</span><br></pre></td></tr></table></figure>

<p>如上，<code>&lt;(ls) &lt;(ls ..)</code>的作用是，<code>()</code>内部的命令会被执行，其输出将被存储到一个临时文件内，然后把文件的标识符handle交给最左边的命令。</p>
<p>因此，这里我们在ls这个目录，把输出放到临时文件内，再对父目录如法炮制，然后把两个文件连接。</p>
<p>这种写法非常方便，因为有些命令会从某个文件的内容，而不是从标准输入里，获得输入参数</p>
<p>综合案例：</p>
<p>现在来看一个里面包含这些内容的简单示例脚本：</p>
<p>example.sh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Start program at <span class="subst">$(date)</span>&quot;</span> <span class="comment"># Date will be substituted</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Running program <span class="variable">$0</span> with <span class="variable">$#</span> arguments with pid $$&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>;<span class="keyword">do</span></span><br><span class="line">        grep foobar <span class="string">&quot;<span class="variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">        <span class="comment"># When pattern is not found,grep has exit status</span></span><br><span class="line">        <span class="comment"># We redirect STDOUT and STDERR to a null register ..</span></span><br><span class="line">        <span class="keyword">if</span> [[ <span class="string">&quot;$?&quot;</span> -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;File <span class="variable">$file</span> does not have any foobar, adding one&quot;</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">        <span class="keyword">fi</span>      </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>第三行：有一个<code>$(date)</code>的参数，date打印出当前的时间。</p>
<p>第五行：<code>$0</code>代表着当前运行的脚本的名称，<code>$#</code>代表给定的参数个数，<code>$$</code>是这个命令的进程ID，一般缩写为PID。</p>
<p>第七行：<code>$@</code>可以展开成所有参数，比如有三个参数，你可以键入<code>$1 $2 $3</code>，如果你不知道有多少个参数，也可以直接键入<code>$@</code>。这里我们通过这种方式将所有参数放在这里，然后这些参数被传给for循环，for循环会创建一个<code>file</code>变量，依次地用这些参数赋值给<code>file</code>变量。</p>
<p>第八行：我们运行grep命令，它会在一堆文件里搜索一个子串。这里我们在文件里搜索字符串foobar，文件变量<code>file</code>将会展开为赋给它的值。</p>
<p>之前说过，如果我们在意程序的输出的话，我们可以把它重定向到某处（比如到一个文件里面保存下来，或者连接组合）。但有时候情况恰恰相反，例如有时候我们只想知道某个脚本的错误代码是什么，例如这里想知道grep能不能成功查找。我们并不在意程序的运行结果，因此我们甚至能直接扔掉整个输出，包括标准输出和标准错误流。这里我们做的就是把两个输出重定向到<code>/dev/null</code>，&#x2F;dev&#x2F;null是UNIX系统的一种特殊设备，输入到它的内容会被丢弃（就是说你可以随意乱写乱画，然后所有的内容都会被丢掉）。</p>
<p>这里的<code>&gt;</code>代表重定向输出流，<code>2&gt;</code>代表重定向标准错误流（因为这两个流是分立的，所以你要告诉bash去操作哪一个）。</p>
<p>所以这里我们执行命令，去检查文件有没有foobar字符串，如果有的话，返回一个0错误代码，如果没有返回一个非0错误代码。</p>
<p>第十一行：我们获取前一个命令的错误代码（<code>$?</code>），然后是一个比较运算符<code>-ne</code>（代表不等于Non Equal）</p>
<blockquote>
<p>其他编程序语言中有像&#x3D;和≠，bash里有很多预设的比较运算(可以使用命令<code>man test</code>查看)，这主要是为了你用Shell的时候，有很多东西要去测试。比如我们现在正在对比两个数，看它们是否相同。</p>
</blockquote>
<p>如果文件中没有foobar，前一个命令将会返回一个非零错误代码。</p>
<p>第十二行：我们将会如果前一个命令返回一个非0错误代码，我们将会输出一句话<code>File xxx does not have any foobar, adding one</code></p>
<p>第十三行：使用<code>&gt;&gt;</code>往对应文件中追加一行注释<code># foobar</code></p>
<p>现在我们来运行这个脚本，当前目录下有一些文件，我们将这些文件作为参数传给example.sh，检查是否有foobar。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span></span><br><span class="line">example.sh  hello.txt  mcd.sh</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ ./example.sh hello.txt mcd.sh</span><br><span class="line">Start program at Sun Dec 25 23:06:13 CST 2022</span><br><span class="line">Running program ./example.sh with 2 arguments with pid 2570038</span><br><span class="line">File hello.txt does not have any foobar, adding one</span><br><span class="line">File mcd.sh does not have any foobar, adding one</span><br></pre></td></tr></table></figure>

<p>我们在文件hello.txt和mcd.sh中没有找到foobar字符串，因此脚本分别给这两个文件添加了一个<code># foobar</code> 注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">cat</span> hello.txt</span><br><span class="line">hello,this is a txt file</span><br><span class="line"><span class="comment"># foobar</span></span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">cat</span> mcd.sh </span><br><span class="line"><span class="function"><span class="title">mcd</span></span>()&#123;</span><br><span class="line">	<span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">	<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># foobar</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通配符</li>
</ul>
<p>如果我们不想一个一个查找文件，可以使用通配符来进行匹配。</p>
<p>比如这里<code>*</code>匹配任意字符，这里将会显示出所有含有任意字符，并以<code>.sh</code>结尾的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span></span><br><span class="line">example.sh  hello.txt  image.png  mcd.sh  project1  project2  <span class="built_in">test</span></span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span> *.sh</span><br><span class="line">example.sh  mcd.sh</span><br></pre></td></tr></table></figure>

<p>现在如果我只想找有一个而不是两个特定字符的项，可以使用<code>?</code>，<code>?</code>匹配一个字符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span></span><br><span class="line">example.sh  hello.txt  image.png  mcd.sh  project1  project2  project42  <span class="built_in">test</span></span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span> project?</span><br><span class="line">project1:</span><br><span class="line">src</span><br><span class="line"></span><br><span class="line">project2:</span><br><span class="line">src</span><br></pre></td></tr></table></figure>

<p>现在我们得到了匹配的目录project1和project2</p>
<blockquote>
<p>src是匹配的目录下的子项</p>
</blockquote>
<p>总而言之，通配符非常强大，你也可以组合它们。</p>
<p>一个常用模式是花括号<code>&#123;&#125;</code>。</p>
<p>比如目录下有一个image.png图片，我们想转变该图像的格式，一般的做法是<code>convert image.png image.jpg</code>，但是你也可以键入<code>convert image.&#123;png,jpg&#125;</code>，它会展开成上面的那行。</p>
<p>又如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">touch</span> foo&#123;,1,2,10&#125;</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span></span><br><span class="line">example.sh  foo  foo1  foo10  foo2  hello.txt  mcd.sh project1  project2 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>如上所述，我们可以touch一串foo，所有的foo都会被展开。</p>
<p>你也可以进行多层操作，建立笛卡尔系：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">cat</span> &lt;(<span class="built_in">ls</span> project?/src/test)</span><br><span class="line">project1/src/test:</span><br><span class="line"></span><br><span class="line">project2/src/test:</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">touch</span> project&#123;1,2&#125;/src/test/test&#123;1,2,3&#125;.py</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">cat</span> &lt;(<span class="built_in">ls</span> project?/src/test)</span><br><span class="line">project1/src/test:</span><br><span class="line">test1.py</span><br><span class="line">test2.py</span><br><span class="line">test3.py</span><br><span class="line"></span><br><span class="line">project2/src/test:</span><br><span class="line">test1.py</span><br><span class="line">test2.py</span><br><span class="line">test3.py</span><br></pre></td></tr></table></figure>

<p>如上，我们在创建文件的路径上有两组花括号，这会用两组展开式形成笛卡尔积，意味着展开后所有的路径有2*3组。因此当我们运行命令<code>touch project&#123;1,2&#125;/src/test/test&#123;1,2,3&#125;.py</code>时，实际上分别在<code>./project1/src/test/</code>目录下和<code>./project2/src/test/</code>目录下创建了<code>test1.py</code>，<code>test2.py</code>，<code>test3.py</code>文件。</p>
<p>你也可以将<code>*</code>通配符和<code>&#123;&#125;</code>通配符结合，甚至用一些范围表示，如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">mkdir</span> foo bar</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">touch</span> &#123;foo,bar&#125;/&#123;a..d&#125;</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">cat</span> &lt;(<span class="built_in">ls</span> &#123;foo,bar&#125;/)</span><br><span class="line">bar/:</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line"></span><br><span class="line">foo/:</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure>

<p>如上，这将会从foo&#x2F;a一直到展开到foo&#x2F;d，而bar目录下同理。</p>
<ul>
<li>diff</li>
</ul>
<p>diff 命令用于比较文件的差异。diff 以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则 diff 会比较目录中相同文件名的文件，但不会比较其中子目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">touch</span> foo/x bar/y</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ diff &lt;(<span class="built_in">ls</span> foo) &lt;(<span class="built_in">ls</span> bar)</span><br><span class="line">5c5</span><br><span class="line">&lt; x</span><br><span class="line">---</span><br><span class="line">&gt; y</span><br></pre></td></tr></table></figure>

<p>如上，x只在第一个文件夹里，而y只在第二个文件夹内。</p>
<ul>
<li>其他Shell脚本</li>
</ul>
<p>目前为止我们只看了bash脚本，如果你喜欢其他脚本（bash对一些工作可能并不是最好的选择），你可以用很多语言写和Shell工具交互的脚本。注意，脚本并不一定只有用 bash 写才能在终端里调用。比如说，这是一段 Python 脚本，作用是将输入的参数倒序输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="built_in">reversed</span>(sys.argv[<span class="number">1</span>:]):</span><br><span class="line">    <span class="built_in">print</span>(arg)</span><br></pre></td></tr></table></figure>

<p>如上，python默认不会尝试和Shell交互，所以我们需要导入一些库<code>import sys</code>。第一行叫做shebang，Shell通过它了解怎么运行这个程序。</p>
<blockquote>
<p>shebang这个单词源于这行以<code>#!</code>开头，<code>#</code>是sharp，<code>!</code>是bang</p>
</blockquote>
<p>你可以随时键入类似<code>python script.py a b c</code>的命令来运行这个python脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ python script.py a b c</span><br><span class="line">c</span><br><span class="line">b</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p>但是如果想让它从Shell就能执行呢？这就需要用到shebang行。Shell用首行识别到需要用Python解释器运行这个程序，并且第一行给出了python解释器所在的路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ ./script.py a b c</span><br><span class="line">c</span><br><span class="line">b</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<p>需要注意的是不同的设备很可能会把python放在不同的地方，最好不要假设文件放在固定的位置，其他的东西要是如此。</p>
<p> <code>shebang</code> 行中使用 <a href="https://man7.org/linux/man-pages/man1/env.1.html"><code>env</code></a> 命令，会根据给出的参数（这里是python），<code>env</code> 会利用之前的<code>PATH</code> 环境变量来进行定位，在此路径中找python二进制文件，然后用该文件去解释这个脚本。这会有更好的可移植性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="built_in">reversed</span>(sys.argv[<span class="number">1</span>:]):</span><br><span class="line">    <span class="built_in">print</span>(arg)</span><br></pre></td></tr></table></figure>

<ul>
<li>shellcheck</li>
</ul>
<p>编写bash脚本有时候会很别扭和反直觉。例如 <a href="https://github.com/koalaman/shellcheck">shellcheck</a> 这样的工具可以帮助你定位sh&#x2F;bash脚本中的错误。</p>
<blockquote>
<p><a href="https://github.com/koalaman/shellcheck/tree/v0.7.1#installing">koalaman&#x2F;shellcheck at v0.7.1 (github.com)</a></p>
</blockquote>
<p>shellcheck可以给出warning和语法错误提示，还能指出哪些地方你没正确引用等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ shellcheck mcd.sh</span><br><span class="line"></span><br><span class="line">In mcd.sh line 1:</span><br><span class="line"><span class="function"><span class="title">mcd</span></span>()&#123;</span><br><span class="line">^-- SC2148: Tips depend on target shell and yours is unknown. Add a shebang.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Shell函数和脚本的区别</li>
</ul>
<p>shell函数和脚本有如下一些不同点：</p>
<ol>
<li>函数只能与shell使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 <code>shebang</code> 是很重要的。</li>
<li>函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。</li>
<li>函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 <a href="https://man7.org/linux/man-pages/man1/export.1p.html"><code>export</code></a> 将环境变量导出，并将值传递给环境变量。</li>
<li>与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell脚本中往往也会包含它们自己的函数定义。</li>
</ol>
<h2 id="Shell工具"><a href="#Shell工具" class="headerlink" title="Shell工具"></a>Shell工具</h2><h3 id="查看命令如何使用"><a href="#查看命令如何使用" class="headerlink" title="查看命令如何使用"></a>查看命令如何使用</h3><ul>
<li>man命令</li>
</ul>
<p>给出一个命令，应该怎样了解如何使用这个命令行并找出它的不同的选项呢？最常用的方法是为对应的命令行添加<code>-h</code> 或 <code>--help</code> 标记。另外一个更详细的方法则是使用<code>man</code> 命令。<code>man</code>命令是手册（manual）的缩写，它提供了命令的用户手册。</p>
<p>事实上，目前我们给出的所有命令的说明链接，都是网页版的Linux命令手册，即使是安装的第三方命令。当然前提是开发者编写了手册并将其包含在了安装包中。在交互式的、基于字符处理的终端窗口中，一般也可以通过 <code>:help</code> 命令或键入 <code>?</code> 来获取帮助。</p>
<ul>
<li>tldr (too long don’t read)</li>
</ul>
<p>有时候手册内容太过详实，让我们难以在其中查找哪些最常用的标记和语法。<a href="https://tldr.sh/">TLDR pages</a>是一个很不错的替代品，它提供了一些案例，可以帮助你快速找到正确的选项。</p>
<blockquote>
<p>下载tldr：<code>npm install -g tldr</code></p>
<p>使用npm命令之前要先下载 <code>yum -y install npm</code></p>
</blockquote>
<h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><p>你当然可以使用ls，但是如果你想查找一个已经知道名字的文件或者目录，我们可以有更好的做法</p>
<ul>
<li>find</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/gexiaobaohelloworld/article/details/8206889">linux-find</a></p>
</blockquote>
<p>find大概是每个UNIX系统都有的工具，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ find . -name src -<span class="built_in">type</span> d</span><br><span class="line">./project1/src</span><br><span class="line">./project2/src</span><br></pre></td></tr></table></figure>

<p>这里意为，在当前文件夹<code>.</code>调用find，查找名为<code>src</code> 并且类型为目录的东西。键入以上命令，它就可以在当前目录递归查看所有符合规则的文件或者文件夹（find默认递归指定目录）。</p>
<p>find还有许多有用的flag，比如你甚至可以查询指定格式的文件路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ find . -path <span class="string">&#x27;**/test/*.py&#x27;</span> -<span class="built_in">type</span> f</span><br><span class="line">./project1/src/test/test2.py</span><br><span class="line">./project1/src/test/test1.py</span><br><span class="line">./project1/src/test/test3.py</span><br><span class="line">./project2/src/test/test2.py</span><br><span class="line">./project2/src/test/test1.py</span><br><span class="line">./project2/src/test/test3.py</span><br></pre></td></tr></table></figure>

<p>这里<code>**</code>是指可以匹配零或者多个目录名，然后在此路径下找到拓展名为<code>.py</code>的文件，并要求它们在一个test文件夹内，同时检查它是否为F类型（f代表文件file）</p>
<p>运用不用的flag，可以进行非路径和非文件名的筛选：</p>
<p>比如可以查找被修改过的文件，这里<code>-mtime</code>代表修改时间，<code>.</code>当前目录下，最近<code>1</code>天被修改过的东西都会被列出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ find . -mtime -1</span><br><span class="line">.</span><br><span class="line">./project1</span><br><span class="line">./project1/src</span><br><span class="line">./project1/src/test</span><br><span class="line">./project1/src/test/test2.py</span><br><span class="line">./project1/src/test/test1.py</span><br><span class="line">./project1/src/test/test3.py</span><br><span class="line">./project2</span><br><span class="line">./project2/src</span><br><span class="line">./project2/src/test</span><br><span class="line">./project2/src/test/test2.py</span><br><span class="line">./project2/src/test/test1.py</span><br><span class="line">./project2/src/test/test3.py</span><br><span class="line">./test</span><br><span class="line">./mcd.sh</span><br></pre></td></tr></table></figure>

<p>你甚至可以使用其他条件，比如大小，所有者，权限等等。</p>
<p>强大的是，find不仅可以查找东西，找到之后还可以做别的：例如</p>
<p>我们可以在当前目录下查找所有扩展名为<code>.tmp</code>的文件，然后要求find对于所有这些文件，执行<code>rm</code>命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ find . -name <span class="string">&quot;*.tmp&quot;</span></span><br><span class="line">./project1/src/test/test3.tmp</span><br><span class="line">./project1/src/test/test1.tmp</span><br><span class="line">./project1/src/test/test2.tmp</span><br><span class="line">./project2/src/test/test3.tmp</span><br><span class="line">./project2/src/test/test1.tmp</span><br><span class="line">./project2/src/test/test2.tmp</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ find . -name <span class="string">&quot;*.tmp&quot;</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ find . -name <span class="string">&quot;*.tmp&quot;</span></span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ </span><br></pre></td></tr></table></figure>

<p>如上，执行<code>find . -name &quot;*.tmp&quot; -exec rm &#123;&#125; \;</code>后，对应的tmp文件都被删除了。</p>
<ul>
<li>fd</li>
</ul>
<p><a href="https://github.com/sharkdp/fd"><code>fd</code></a> 是一个更简单、更快速、更友好的程序，它可以用来作为<code>find</code>的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。以模式<code>PATTERN</code> 搜索的语法是 <code>fd PATTERN</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ fd <span class="string">&quot;.*py&quot;</span></span><br><span class="line">project1/src/test/test1.py</span><br><span class="line">project1/src/test/test2.py</span><br><span class="line">project1/src/test/test3.py</span><br><span class="line">project2/src/test/test1.py</span><br><span class="line">project2/src/test/test2.py</span><br><span class="line">project2/src/test/test3.py</span><br></pre></td></tr></table></figure>

<ul>
<li>locate</li>
</ul>
<p>大多数人都认为 <code>find</code> 和 <code>fd</code> 已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p>
<p>这就要靠 <a href="https://man7.org/linux/man-pages/man1/locate.1.html"><code>locate</code></a> 了。 <code>locate</code> 使用一个由 <a href="https://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a>负责更新的数据库，在大多数系统中 <code>updatedb</code> 都会通过 <a href="https://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a> 每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code> 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code>则只能通过文件名。 <a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">这里</a>有一个更详细的对比。</p>
<h3 id="查找代码"><a href="#查找代码" class="headerlink" title="查找代码"></a>查找代码</h3><p>查找文件是很有用的技能，但是很多时候你的目标其实是查看文件的内容。常见的场景是查找具有匹配某种模式的全部文件，并找它们的位置。</p>
<ul>
<li>grep</li>
</ul>
<p>grep是用于对输入文本进行匹配的通用工具。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ grep foobar mcd.sh </span><br><span class="line"><span class="comment"># foobar</span></span><br></pre></td></tr></table></figure>

<p>使用-R可以递归地搜索</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ grep -R foobar .</span><br><span class="line">./example.sh:        grep foobar <span class="string">&quot;<span class="variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">./example.sh:                <span class="built_in">echo</span> <span class="string">&quot;File <span class="variable">$file</span> does not have any foobar, adding one&quot;</span></span><br><span class="line">./example.sh:                <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">./hello.txt:<span class="comment"># foobar</span></span><br><span class="line">./mcd.sh:<span class="comment"># foobar</span></span><br></pre></td></tr></table></figure>

<p><code>grep</code> 有很多选项，这也使它成为一个非常全能的工具。 <code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。但是也有很多办法可以对 <code>grep -R</code> 进行改进，例如使其忽略<code>.git</code> 文件夹，使用多CPU等等。</p>
<ul>
<li>rg（ripgrep）</li>
</ul>
<p>此外还出现了很多grep的替代品，包括 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a>。它们都特别好用，但是功能也都差不多，比较常用的是 ripgrep (<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。</p>
<blockquote>
<p><a href="https://outmanzzq.github.io/2019/11/13/ripgrep/">rg安装</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ rg <span class="string">&quot;foobar&quot;</span> -t sh ~/</span><br><span class="line">/home/lighthouse/missing/tools/mcd.sh</span><br><span class="line">5:<span class="comment"># foobar</span></span><br><span class="line"></span><br><span class="line">/home/lighthouse/missing/tools/example.sh</span><br><span class="line">8:        grep foobar <span class="string">&quot;<span class="variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">12:                <span class="built_in">echo</span> <span class="string">&quot;File <span class="variable">$file</span> does not have any foobar, adding one&quot;</span></span><br><span class="line">13:                <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>如上，该命令在<code>~/</code>目录下搜索类型(-t即type)为sh，并且文件内有“foobar”子串的文件。</p>
<p>rg不仅能找到对应文件，还能精确到匹配的行，比起使用grep，它还增加了代码彩色显示和文件处理啥的，也有Unicode支持，并且运行很快。</p>
<p>rg有许多有用的flag，比如说你想要点上下文(匹配内容的附近内容)，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ rg <span class="string">&quot;foobar&quot;</span> -t sh -C 5 ~/</span><br><span class="line">/home/lighthouse/missing/tools/mcd.sh</span><br><span class="line">1-<span class="function"><span class="title">mcd</span></span>()&#123;</span><br><span class="line">2-	<span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">3-	<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">4-&#125;</span><br><span class="line">5:<span class="comment"># foobar</span></span><br><span class="line"></span><br><span class="line">/home/lighthouse/missing/tools/example.sh</span><br><span class="line">3-<span class="built_in">echo</span> <span class="string">&quot;Start program at <span class="subst">$(date)</span>&quot;</span> <span class="comment"># Date will be substituted</span></span><br><span class="line">4-</span><br><span class="line">5-<span class="built_in">echo</span> <span class="string">&quot;Running program <span class="variable">$0</span> with <span class="variable">$#</span> arguments with pid $$&quot;</span></span><br><span class="line">6-</span><br><span class="line">7-<span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>;<span class="keyword">do</span></span><br><span class="line">8:        grep foobar <span class="string">&quot;<span class="variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">9-        <span class="comment"># When pattern is not found,grep has exit status</span></span><br><span class="line">10-        <span class="comment"># We redirect STDOUT and STDERR to a null register ..</span></span><br><span class="line">11-        <span class="keyword">if</span> [[ <span class="string">&quot;$?&quot;</span> -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">12:                <span class="built_in">echo</span> <span class="string">&quot;File <span class="variable">$file</span> does not have any foobar, adding one&quot;</span></span><br><span class="line">13:                <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">14-        <span class="keyword">fi</span>      </span><br><span class="line">15-<span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>如上，我们加上<code>-C [num]</code>（C意为context），不仅能够搜索到匹配内容，还能对每一个匹配的内容显示其前后[num]行的内容。这样你就可以知道匹配内容大概在什么位置，它周围都是什么内容。这个功能在查找在哪调用了什么函数 上十分有用。</p>
<p>我们也可以使用一个更高级的用法：</p>
<p><code>-u</code>意为不忽略隐藏文件，<code>--files-without-match</code>是打印出所有不匹配这个pattern的内容，<code>&#39;#!&#39;</code>的意思是匹配有<code>#!</code>的内容。也就是说，我们在搜索没有shebang的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ rg -u --files-without-match <span class="string">&#x27;#!&#x27;</span> -t sh</span><br><span class="line">mcd.sh</span><br></pre></td></tr></table></figure>

<p>此外rg还有些好用的flag，比如<code>--stats</code>这个flag，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ rg <span class="string">&quot;foobar&quot;</span> -t sh -C 5 --stats ~/</span><br><span class="line">/home/lighthouse/missing/tools/mcd.sh</span><br><span class="line">1-<span class="function"><span class="title">mcd</span></span>()&#123;</span><br><span class="line">2-	<span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">3-	<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">4-&#125;</span><br><span class="line">5:<span class="comment"># foobar</span></span><br><span class="line"></span><br><span class="line">/home/lighthouse/missing/tools/example.sh</span><br><span class="line">3-<span class="built_in">echo</span> <span class="string">&quot;Start program at <span class="subst">$(date)</span>&quot;</span> <span class="comment"># Date will be substituted</span></span><br><span class="line">4-</span><br><span class="line">5-<span class="built_in">echo</span> <span class="string">&quot;Running program <span class="variable">$0</span> with <span class="variable">$#</span> arguments with pid $$&quot;</span></span><br><span class="line">6-</span><br><span class="line">7-<span class="keyword">for</span> file <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>;<span class="keyword">do</span></span><br><span class="line">8:        grep foobar <span class="string">&quot;<span class="variable">$file</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null</span><br><span class="line">9-        <span class="comment"># When pattern is not found,grep has exit status</span></span><br><span class="line">10-        <span class="comment"># We redirect STDOUT and STDERR to a null register ..</span></span><br><span class="line">11-        <span class="keyword">if</span> [[ <span class="string">&quot;$?&quot;</span> -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">12:                <span class="built_in">echo</span> <span class="string">&quot;File <span class="variable">$file</span> does not have any foobar, adding one&quot;</span></span><br><span class="line">13:                <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$file</span>&quot;</span></span><br><span class="line">14-        <span class="keyword">fi</span>      </span><br><span class="line">15-<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">4 matches</span><br><span class="line">4 matched lines</span><br><span class="line">2 files contained matches</span><br><span class="line">5 files searched</span><br><span class="line">643 bytes printed</span><br><span class="line">978 bytes searched</span><br><span class="line">0.000054 seconds spent searching</span><br><span class="line">0.002657 seconds</span><br></pre></td></tr></table></figure>

<p>如上，它除了搜索结果之外，还可以输出一些信息。比如成功匹配了多少行，查找了多少行和多少文件，打印了多少byte等。</p>
<ul>
<li>ack</li>
</ul>
<p><a href="https://beyondgrep.com/">ack</a>也是grep的一个替代工具，还有<a href="https://github.com/ggreer/the_silver_searcher">ag</a> 。当然这些工具都是可以替换的，只要会使用即可。</p>
<h3 id="查找shell命令"><a href="#查找shell命令" class="headerlink" title="查找shell命令"></a>查找shell命令</h3><ul>
<li>向上箭头</li>
</ul>
<p>首先，按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。</p>
<p>向上箭头并不是很有效率，所以bash有一些更加简单的方法。</p>
<ul>
<li>history</li>
</ul>
<p>它会打印出你的命令历史记录，当然一般来讲这会输出非常多的记录，你可以使用管道和grep来筛选。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">history</span> | grep <span class="built_in">echo</span></span><br><span class="line">   74  2022-12-29 01:16:27 <span class="built_in">echo</span> $?</span><br><span class="line">  112  2022-12-29 01:45:37 <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; mdc.sh</span><br><span class="line">  115  2022-12-29 01:46:01 <span class="built_in">echo</span> <span class="string">&quot;# foobar&quot;</span> &gt;&gt; mcd.sh</span><br><span class="line">  126  2022-12-29 01:50:42 <span class="built_in">echo</span> <span class="string">&quot;hello,i am a txt file&quot;</span> &gt; hello.txt</span><br><span class="line">  197  2022-12-30 01:06:13 <span class="built_in">history</span> | grep <span class="built_in">echo</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Ctrl+R</li>
</ul>
<p>基本上，所有Shell都会默认把Ctrl+R这个组合键设成（按执行时间）倒叙搜索（backward search）</p>
<p>我们打开（按ctrl+r）倒叙搜索，然后输入<code>echo</code>，就会找到与之匹配的命令，如果我们接着按ctrl+r，就会倒着往前搜索匹配的命令，也可以重新执行命令。</p>
<ul>
<li>fzf</li>
</ul>
<p><code>Ctrl+R</code> 可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a> 使用。<code>fzf</code> 是一个通用对模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出</p>
<ul>
<li>基于历史的自动补全</li>
</ul>
<p>另外一个和历史命令相关的技巧我喜欢称之为<strong>基于历史的自动补全</strong>。 这一特性最初是由 <a href="https://fishshell.com/">fish</a> shell 创建的，它可以根据你最近使用过的开头相同的命令，动态地对当前对shell命令进行补全。这一功能在 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh</a> 中也可以使用，它可以极大的提高用户体验。</p>
<blockquote>
<p>你可以修改 shell history 的行为，例如，如果在命令的开头加上一个空格，它就不会被加进shell记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。 为此你需要在<code>.bashrc</code>中添加<code>HISTCONTROL=ignorespace</code>或者向<code>.zshrc</code> 添加 <code>setopt HIST_IGNORE_SPACE</code>。 如果你不小心忘了在前面加空格，可以通过编辑。<code>bash_history</code>或 <code>.zhistory</code> 来手动地从历史记录中移除那一项。</p>
</blockquote>
<h3 id="文件夹导航"><a href="#文件夹导航" class="headerlink" title="文件夹导航"></a>文件夹导航</h3><p>你可以使用<code>ls -R</code>递归地列出某目录下所有的文件和目录，但是这样列出的东西比较难理解。</p>
<ul>
<li>tree</li>
</ul>
<p>有一个叫<code>tree</code>的工具可以以比较友好的格式打印出目录的结构。</p>
<blockquote>
<p>centos安装：sudo yum -y install tree</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ tree /home</span><br><span class="line">/home</span><br><span class="line">`-- lighthouse</span><br><span class="line">    `-- missing</span><br><span class="line">        `-- tools</span><br><span class="line">            |-- example.sh</span><br><span class="line">            |-- hello.txt</span><br><span class="line">            |-- mcd.sh</span><br><span class="line">            |-- project1</span><br><span class="line">            |   `-- src</span><br><span class="line">            |       `-- <span class="built_in">test</span></span><br><span class="line">            |           |-- test1.py</span><br><span class="line">            |           |-- test2.py</span><br><span class="line">            |           `-- test3.py</span><br><span class="line">            |-- project2</span><br><span class="line">            |   `-- src</span><br><span class="line">            |       `-- <span class="built_in">test</span></span><br><span class="line">            |           |-- test1.py</span><br><span class="line">            |           |-- test2.py</span><br><span class="line">            |           `-- test3.py</span><br><span class="line">            `-- <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">10 directories, 9 files</span><br></pre></td></tr></table></figure>

<ul>
<li>broot</li>
</ul>
<p>broot也是做差不多的事情，但是比起列出所有文件，它会提示[还有更多文件，未列出]。你可以输入字符，broot可以模糊匹配符合条件的文件，并进行动态显示。这样你就可以快速的选择和定位。</p>
<ul>
<li>nnn</li>
</ul>
<p>nnn 默认列出运行 nnn 的当前目录的文件和文件夹。 文件夹列在顶部，而文件列在底部。而且是一个交互性的窗口，你可以通过向左箭头返回上一级目录，通过向右箭头到达子目录。按q即可退出窗口。</p>
<blockquote>
<p>centos 安装 nnn ：sudo yum install nnn</p>
</blockquote>
<img src="https://liyuelian.oss-cn-shenzhen.aliyuncs.com/imgs/image-20221230014444510.png" alt="image-20221230014444510" style="zoom:60%;" />

<ul>
<li>ranger</li>
</ul>
<p>ranger 是一个基于文本的由 Python 编写的文件管理器。不同层级的目录分别在一个面板的三列中进行展示. 可以通过快捷键, 书签, 鼠标以及历史命令在它们之间移动. 当选中文件或目录时, 会自动显示文件或目录的内容。</p>
<hr>
<p>由于本课程的目的是尽可能对你的日常习惯进行优化。因此，我们可以使用<a href="https://github.com/clvv/fasd">fasd</a>和 <a href="https://github.com/wting/autojump">autojump</a> 这两个工具来查找最常用或最近使用的文件和目录。</p>
<p>Fasd 基于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm">frecency </a>对文件和文件排序，也就是说它会同时针对频率（frequency）和时效（recency）进行排序。默认情况下，<code>fasd</code>使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如， 如果您经常访问<code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于 autojump，则使用<code>j cool</code>代替即可。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>阅读 <a href="https://man7.org/linux/man-pages/man1/ls.1.html"><code>man ls</code></a> ，然后使用<code>ls</code> 命令进行如下操作：</p>
<ul>
<li>所有文件（包括隐藏文件）</li>
<li>文件打印以人类可以理解的格式输出 (例如，使用454M 而不是 454279954)</li>
<li>文件以最近访问顺序排序</li>
<li>以彩色文本显示输出结果</li>
</ul>
<p>典型输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rw-r--r--   1 user group 1.1M Jan 14 09:53 baz</span><br><span class="line">drwxr-xr-x   5 user group  160 Jan 14 09:53 .</span><br><span class="line">-rw-r--r--   1 user group  514 Jan 14 06:42 bar</span><br><span class="line">-rw-r--r--   1 user group 106M Jan 13 12:12 foo</span><br><span class="line">drwx------+ 47 user group 1.5K Jan 12 18:08 ..</span><br></pre></td></tr></table></figure>

<hr>
<p>练习：</p>
<p>(1) 显示包括隐藏文件</p>
<blockquote>
<p>-a, –all<br>             do not ignore entries starting with .</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span> -a</span><br><span class="line">.  ..  example.sh  hello.txt  mcd.sh  project1  project2  <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>(2) 文件以人类可以理解的格式输出</p>
<blockquote>
<p>-h, –human-readable<br>              with -l, print sizes in human readable format (e.g., 1K 234M 2G)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span> -hl</span><br><span class="line">total 24K</span><br><span class="line">-rwxrwxr-- 1 lighthouse lighthouse  494 Dec 29 01:49 example.sh</span><br><span class="line">-rw-rw-r-- 1 lighthouse lighthouse   31 Dec 29 01:55 hello.txt</span><br><span class="line">-rw-rwxr-- 1 lighthouse lighthouse   42 Dec 29 01:46 mcd.sh</span><br><span class="line">drwxrwxr-x 3 lighthouse lighthouse 4.0K Dec 29 00:47 project1</span><br><span class="line">drwxrwxr-x 3 lighthouse lighthouse 4.0K Dec 29 00:47 project2</span><br><span class="line">drwxrwxr-x 2 lighthouse lighthouse 4.0K Dec 29 00:55 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>(3) 文件以最近访问顺序排序</p>
<blockquote>
<p>-t     sort by modification time, newest first</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span> -lt</span><br><span class="line">total 24</span><br><span class="line">-rw-rw-r-- 1 lighthouse lighthouse   31 Dec 29 01:55 hello.txt</span><br><span class="line">-rwxrwxr-- 1 lighthouse lighthouse  494 Dec 29 01:49 example.sh</span><br><span class="line">-rw-rwxr-- 1 lighthouse lighthouse   42 Dec 29 01:46 mcd.sh</span><br><span class="line">drwxrwxr-x 2 lighthouse lighthouse 4096 Dec 29 00:55 <span class="built_in">test</span></span><br><span class="line">drwxrwxr-x 3 lighthouse lighthouse 4096 Dec 29 00:47 project1</span><br><span class="line">drwxrwxr-x 3 lighthouse lighthouse 4096 Dec 29 00:47 project2</span><br></pre></td></tr></table></figure>

<p>(4) 以彩色文本显示输出结果</p>
<blockquote>
<p>–color[&#x3D;WHEN]<br>             colorize the output; WHEN can be ‘never’, ‘auto’, or ‘always’ (the default); more info below</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span> --color=auto</span><br><span class="line">example.sh  hello.txt  mcd.sh  project1  project2  <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>综合：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">ls</span> -laht --color=auto</span><br><span class="line">total 32K</span><br><span class="line">drwxrwxr-x 5 lighthouse lighthouse 4.0K Dec 30 01:14 .</span><br><span class="line">-rw-rw-r-- 1 lighthouse lighthouse   31 Dec 29 01:55 hello.txt</span><br><span class="line">-rwxrwxr-- 1 lighthouse lighthouse  494 Dec 29 01:49 example.sh</span><br><span class="line">-rw-rwxr-- 1 lighthouse lighthouse   42 Dec 29 01:46 mcd.sh</span><br><span class="line">drwxrwxr-x 2 lighthouse lighthouse 4.0K Dec 29 00:55 <span class="built_in">test</span></span><br><span class="line">drwxrwxr-x 3 lighthouse lighthouse 4.0K Dec 29 00:47 project1</span><br><span class="line">drwxrwxr-x 3 lighthouse lighthouse 4.0K Dec 29 00:47 project2</span><br><span class="line">drwxrwxr-x 3 lighthouse lighthouse 4.0K Dec 29 00:46 ..</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写两个bash函数 <code>marco</code> 和 <code>polo</code> 执行下面的操作。 每当你执行 <code>marco</code> 时，当前的工作目录应当以某种形式保存，当执行 <code>polo</code> 时，无论现在处在什么目录下，都应当 <code>cd</code> 回到当时执行 <code>marco</code> 的目录。 为了方便debug，你可以把代码写在单独的文件 <code>marco.sh</code> 中，并通过 <code>source marco.sh</code>命令，（重新）加载函数。</p>
<p>练习：</p>
<p>marco.sh:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">marco</span></span>()&#123;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(pwd)</span>&quot;</span> &gt; ~/pwd.txt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">polo</span></span>()&#123;</span><br><span class="line">jump=$(<span class="built_in">cat</span> ~/pwd.txt)</span><br><span class="line"><span class="comment"># 使用$(命令)的方式可以赋给变量</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$jump</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;You had alread jump to --&gt;<span class="variable">$jump</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">source</span> marco.sh</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ marco</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ <span class="built_in">cd</span> /</span><br><span class="line">[lighthouse@VM-8-17-centos /]$ polo</span><br><span class="line">You had alread jump to --&gt;/home/lighthouse/missing/tools</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ </span><br></pre></td></tr></table></figure>
</li>
<li><p>假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段bash脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">   </span><br><span class="line">n=$(( RANDOM % <span class="number">100</span> ))</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> [[ n -eq 42 ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;Something went wrong&quot;</span></span><br><span class="line">   &gt;&amp;2 <span class="built_in">echo</span> <span class="string">&quot;The error was using magic numbers&quot;</span></span><br><span class="line">   <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">   </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Everything went according to plan&quot;</span></span><br></pre></td></tr></table></figure>

<p>练习：</p>
<p>上述脚本的意思是，取一个随机数（RANDOM变量用于生成0~32767之前的任意随机数），随机数模100。如果结果等于42，就输出两句话，然后返回1退出码；否则就输出”Everything went according to plan“</p>
<blockquote>
<p>这里的<code>&gt;&amp;2</code>的意思是  将标准输出1和标准错误输出2 都重定向到终端中（标准输出或标准错误输出的目的地默认都为终端）</p>
<p><a href="https://www.cnblogs.com/itsharehome/p/8503206.html">Linux shell标准输入，标准输出，错误输出</a></p>
</blockquote>
<p>run.sh（buggy.sh为题目的脚本名）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">count=1</span><br><span class="line">   </span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    ./buggy.sh 1&gt;&gt; out.log 2&gt;&amp;1 <span class="comment">#把stout和sterr一起重定向到out.log文件中(追加)</span></span><br><span class="line">    <span class="keyword">if</span> [[ $? -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line"> 	 <span class="built_in">echo</span> <span class="string">&quot;运行错误，记录在out.log中&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;共运行 <span class="variable">$count</span> 次&quot;</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    ((count++))</span><br><span class="line">   </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos tools]$ ./run.sh </span><br><span class="line">运行错误，记录在out.log中</span><br><span class="line">共运行 82 次</span><br><span class="line">[lighthouse@VM-8-17-centos tools]$ ./run.sh </span><br><span class="line">运行错误，记录在out.log中</span><br><span class="line">共运行 42 次</span><br></pre></td></tr></table></figure>
</li>
<li><p>本节课我们讲解的 <code>find</code> 命令中的 <code>-exec</code> 参数非常强大，它可以对我们查找的文件进行操作。但是，如果我们要对所有文件进行操作呢？例如创建一个zip压缩文件？我们已经知道，命令行可以从参数或标准输入接受输入。在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如<code>tar</code> 则需要从参数接受输入。这里我们可以使用<a href="https://man7.org/linux/man-pages/man1/xargs.1.html"><code>xargs</code></a> 命令，它可以使用标准输入中的内容作为参数。 例如 <code>ls | xargs rm</code> 会删除当前目录中的所有文件。</p>
<p>您的任务是编写一个命令，它可以递归地查找文件夹中所有的HTML文件，并将它们压缩成zip文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行（提示：查看 <code>xargs</code>的参数<code>-d</code>，译注：MacOS 上的 <code>xargs</code>没有<code>-d</code>，<a href="https://github.com/missing-semester/missing-semester/issues/93">查看这个issue</a>）</p>
<p>如果您使用的是 MacOS，请注意默认的 BSD <code>find</code> 与 <a href="https://en.wikipedia.org/wiki/List_of_GNU_Core_Utilities_commands">GNU coreutils</a> 中的是不一样的。你可以为<code>find</code>添加<code>-print0</code>选项，并为<code>xargs</code>添加<code>-0</code>选项。作为 Mac 用户，您需要注意 mac 系统自带的命令行工具和 GNU 中对应的工具是有区别的；如果你想使用 GNU 版本的工具，也可以使用 <a href="https://formulae.brew.sh/formula/coreutils">brew 来安装</a>。</p>
<p>练习：</p>
<p>事先在当前文件夹下创建了一些html文件（包括带有空格的he llo.html）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos question4]$ tree </span><br><span class="line">.</span><br><span class="line">|-- he\ llo.html</span><br><span class="line">|-- index.html</span><br><span class="line">|-- project1</span><br><span class="line">|   |-- <span class="built_in">test</span></span><br><span class="line">|   |-- test1.html</span><br><span class="line">|   |-- test2.html</span><br><span class="line">|   `-- test3.html</span><br><span class="line">|-- project2</span><br><span class="line">|   |-- <span class="built_in">test</span></span><br><span class="line">|   |-- test1.html</span><br><span class="line">|   |-- test2.html</span><br><span class="line">|   `-- test3.html</span><br><span class="line">|-- test1.html</span><br><span class="line">|-- test2.html</span><br><span class="line">|-- test3.html</span><br><span class="line">|-- test4.html</span><br><span class="line">|-- test5.html</span><br><span class="line">|-- test6.html</span><br><span class="line">|-- test7.html</span><br><span class="line">|-- test8.html</span><br><span class="line">`-- test9.html</span><br><span class="line"></span><br><span class="line">4 directories, 17 files</span><br></pre></td></tr></table></figure>

<p>使用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos question4]$ find .  -name <span class="string">&quot;*.html&quot;</span> | xargs -d <span class="string">&#x27;\n&#x27;</span> tar -cf html.zip</span><br></pre></td></tr></table></figure>

<p>查看压缩包内容：</p>
<p>可以看到包括有空格文件名的html在内全部压缩成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos question4]$ tar -tf html.zip </span><br><span class="line">./project1/test3.html</span><br><span class="line">./project1/test2.html</span><br><span class="line">./project1/test1.html</span><br><span class="line">./test6.html</span><br><span class="line">./test3.html</span><br><span class="line">./test8.html</span><br><span class="line">./test4.html</span><br><span class="line">./test9.html</span><br><span class="line">./project2/test3.html</span><br><span class="line">./project2/test2.html</span><br><span class="line">./project2/test1.html</span><br><span class="line">./test5.html</span><br><span class="line">./he llo.html</span><br><span class="line">./test2.html</span><br><span class="line">./index.html</span><br><span class="line">./test1.html</span><br><span class="line">./test7.html</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/141500550">xargs使用教程 </a>    <a href="https://zhuanlan.zhihu.com/p/91593509">Linux下查看压缩文件内容的 10 种方法</a></p>
<p>使用 <code>tar -tf</code> 命令可以在不提取 <code>tar</code> 文件的情况下查看压缩包内容。</p>
</blockquote>
</li>
<li><p>（进阶）编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lighthouse@VM-8-17-centos question4]$ find . -<span class="built_in">type</span> f -mmin -120 | xargs -d <span class="string">&#x27;\n&#x27;</span>  <span class="built_in">ls</span> -tl | <span class="built_in">head</span> -3</span><br><span class="line">-rw-rw-r-- 1 lighthouse lighthouse 10240 Jan  3 22:01 ./html.zip</span><br><span class="line">-rw-rw-r-- 1 lighthouse lighthouse     0 Jan  3 21:36 ./he llo.html</span><br><span class="line">-rw-rw-r-- 1 lighthouse lighthouse     0 Jan  3 21:15 ./project1/test1.html</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>the missing semester of cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
